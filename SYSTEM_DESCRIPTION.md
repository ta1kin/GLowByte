# Описание системы прогнозирования самовозгорания угля

## Обзор системы

**Coal Fire Predictor** — комплексная система для прогнозирования самовозгорания угля при открытом хранении на складах. Система использует машинное обучение (XGBoost) для анализа температурных данных, метеорологических условий и исторических данных о возгораниях с целью предсказания вероятности самовозгорания угольных штабелей.

---

## Архитектура системы

### Компоненты системы

Система построена по микросервисной архитектуре и состоит из следующих компонентов:

#### 1. **Backend API (NestJS)**
- **Технологии**: NestJS, TypeScript, Prisma ORM, PostgreSQL
- **Порт**: 3000
- **Назначение**: Основной API сервис, обрабатывающий бизнес-логику, управление данными и координацию между сервисами

#### 2. **ML Service (Python FastAPI)**
- **Технологии**: Python 3.11+, FastAPI, XGBoost, Pandas, SQLAlchemy
- **Порт**: 8000
- **Назначение**: Машинное обучение, прогнозирование, обучение моделей, расчет метрик

#### 3. **Telegram Bot (NestJS)**
- **Технологии**: NestJS, Telegraf
- **Порт**: 9000
- **Назначение**: Telegram бот для уведомлений и взаимодействия с пользователями

#### 4. **PostgreSQL**
- **Порт**: 5432
- **Назначение**: Основная база данных для хранения всех данных системы

#### 5. **RabbitMQ**
- **Порты**: 5672 (AMQP), 15672 (Management UI)
- **Назначение**: Очередь сообщений для асинхронной обработки задач

#### 6. **Redis**
- **Порт**: 6379
- **Назначение**: Кэширование данных и сессий

---

## Функционал системы

### 1. Управление данными (Data Management)

#### Импорт данных из CSV файлов
- **Типы файлов**:
  - `SUPPLIES` — данные о поставках угля (дата поступления, марка, склад, штабель)
  - `FIRES` — записи о самовозгораниях (дата возгорания, марка, склад, штабель)
  - `TEMPERATURE` — температурные измерения штабелей (максимальная температура, дата акта)
  - `WEATHER` — метеорологические данные (температура воздуха, влажность, осадки, давление)

#### Процесс импорта:
1. Пользователь загружает CSV файл через API (`POST /api/data/upload`)
2. Файл сохраняется на сервере с уникальным именем
3. Задача на обработку ставится в очередь RabbitMQ (`data.import`)
4. Асинхронный процессор (`DataImportProcessor`) обрабатывает файл:
   - Парсинг CSV
   - Валидация данных
   - Создание/обновление записей в БД через Prisma транзакции
   - Обработка состояний гонки (race conditions) при параллельной обработке
   - Очистка загруженного файла после обработки
5. Статус загрузки обновляется в БД (PENDING → PROCESSING → COMPLETED/FAILED)

#### Особенности:
- **Атомарность операций**: Использование Prisma транзакций для целостности данных
- **Обработка дубликатов**: Автоматическое определение существующих записей
- **Валидация**: Проверка размера файла (макс. 50 МБ), типа файла, формата данных
- **Асинхронность**: Обработка через RabbitMQ не блокирует API

### 2. Управление штабелями (Stockpile Management)

#### Функции:
- Создание и управление складами (`Sklad`)
- Создание и управление штабелями (`Shtabel`)
- Просмотр истории температурных измерений
- Архивация штабелей (вместо удаления)

#### API Endpoints:
- `GET /api/stockpiles/sklads` — список складов
- `POST /api/stockpiles/sklads` — создание склада
- `GET /api/stockpiles` — список штабелей
- `GET /api/stockpiles/:id` — детали штабеля
- `GET /api/stockpiles/:id/temperature` — история температуры
- `POST /api/stockpiles` — создание штабеля
- `PUT /api/stockpiles/:id` — обновление штабеля
- `DELETE /api/stockpiles/:id` — архивация штабеля

### 3. Прогнозирование самовозгорания (Prediction)

#### Процесс прогнозирования:

**Для одного штабеля:**
1. Пользователь запрашивает прогноз (`POST /api/predictions/:shtabelId`)
2. Задача ставится в очередь RabbitMQ (`prediction.calculate`)
3. Consumer (`PredictionConsumer`) обрабатывает задачу:
   - Получает данные штабеля из БД
   - Собирает признаки (features):
     - Максимальная температура
     - Возраст штабеля (age_days)
     - Температура воздуха
     - Влажность
     - Осадки
     - Изменение температуры за 3 дня (temp_delta_3d)
   - Отправляет запрос в ML Service (`POST /predict`)
4. ML Service:
   - Загружает обученную модель XGBoost
   - Выполняет предобработку признаков
   - Делает прогноз (вероятность возгорания, дата)
   - Определяет уровень риска (LOW, MEDIUM, HIGH, CRITICAL)
   - Возвращает результат
5. Результат сохраняется в БД (`Prediction`)
6. При необходимости создается уведомление

**Массовое прогнозирование:**
- `POST /api/predictions/batch/calculate` — прогноз для всех активных штабелей
- Обрабатывается через очередь `prediction.batch`
- Параллельная обработка нескольких штабелей

#### Уровни риска:
- **LOW** — низкий риск (вероятность < 0.3)
- **MEDIUM** — средний риск (0.3 ≤ вероятность < 0.6)
- **HIGH** — высокий риск (0.6 ≤ вероятность < 0.8)
- **CRITICAL** — критический риск (вероятность ≥ 0.8)

### 4. Машинное обучение (ML Service)

#### Обучение модели:
1. Запрос на обучение (`POST /api/ml/train` или `POST /ml-service/train`)
2. Задача ставится в очередь RabbitMQ (`model.train`)
3. Consumer (`ModelTrainingConsumer`) обрабатывает задачу:
   - Получает данные для обучения из БД
   - Вызывает ML Service (`POST /train`)
4. ML Service:
   - Загружает данные из БД через `DatabaseService.get_training_data()`
   - Выполняет предобработку (feature engineering)
   - Обучает модель XGBoost с гиперпараметрами:
     - n_estimators: 300
     - max_depth: 6
     - learning_rate: 0.1
     - scale_pos_weight: автоматически рассчитывается для несбалансированных классов
   - Рассчитывает метрики:
     - Accuracy, Precision, Recall, F1-score
     - MAE (Mean Absolute Error) в днях
     - RMSE (Root Mean Square Error) в днях
     - Accuracy within 2/3/5 days
   - Сохраняет модель в JSON формате
   - Сохраняет метаданные модели в БД (`ModelArtifact`, `Metric`)

#### Прогнозирование:
- `POST /predict` — прогноз для одного штабеля
- `POST /predict/batch` — массовый прогноз
- Использует обученную модель XGBoost
- Возвращает вероятность возгорания, дату, уровень риска, доверительный интервал

#### Метрики модели:
- `GET /metrics` — текущие метрики модели на основе реальных данных
- Рассчитываются из предсказаний с фактическими датами возгорания (`actualFireDate`)
- Метрики обновляются автоматически при создании `FireRecord`

### 5. Аналитика (Analytics)

#### Функции:
- Метрики качества модели
- Точность прогнозов (accuracy)
- Распределение по уровням риска
- Тренды температуры
- Dashboard статистика

#### API Endpoints:
- `GET /api/analytics/metrics` — метрики модели
- `GET /api/analytics/accuracy` — точность прогнозов
- `GET /api/analytics/dashboard` — статистика для dashboard
- `GET /api/analytics/risk-distribution` — распределение рисков
- `GET /api/analytics/temperature-trends` — тренды температуры

### 6. Уведомления (Notifications)

#### Функции:
- Создание уведомлений о критических рисках
- Интеграция с Telegram Bot
- Управление статусами уведомлений (прочитано/не прочитано)

#### API Endpoints:
- `GET /api/notifications` — список уведомлений пользователя
- `PUT /api/notifications/:id/read` — отметить как прочитанное

### 7. Аутентификация и пользователи

#### Аутентификация:
- Через Telegram ID
- Автоматическое создание пользователей при первом входе
- Роли: OPERATOR, ENGINEER, ADMIN, ANALYST

#### API Endpoints:
- `POST /api/auth/login` — вход через Telegram ID
- `POST /api/auth/check` — проверка аутентификации
- `GET /api/user/profile` — профиль пользователя
- `PUT /api/user/settings` — настройки пользователя

---

## Протоколы и каналы связи

### 1. HTTP/REST API

#### Backend API (порт 3000)
- **Протокол**: HTTP/1.1, HTTPS (в production)
- **Формат данных**: JSON
- **Аутентификация**: Bearer Token (JWT или Telegram-based)
- **Документация**: Swagger/OpenAPI (`/api/docs`)

**Пример запроса:**
```http
POST /api/predictions/123 HTTP/1.1
Host: localhost:3000
Authorization: Bearer <token>
Content-Type: application/json

{
  "horizonDays": 7
}
```

#### ML Service (порт 8000)
- **Протокол**: HTTP/1.1
- **Формат данных**: JSON
- **Framework**: FastAPI
- **CORS**: Разрешен для всех источников

**Пример запроса:**
```http
POST /predict HTTP/1.1
Host: localhost:8000
Content-Type: application/json

{
  "shtabel_id": 123,
  "horizon_days": 7
}
```

**Пример ответа:**
```json
{
  "shtabel_id": 123,
  "model_name": "coal_fire_model",
  "model_version": "1.0.1",
  "predicted_date": "2025-11-30T00:00:00Z",
  "prob_event": 0.75,
  "risk_level": "HIGH",
  "horizon_days": 7,
  "confidence": 0.85
}
```

### 2. RabbitMQ (AMQP)

#### Назначение:
Асинхронная обработка тяжелых задач:
- Импорт CSV файлов
- Расчет прогнозов
- Обучение моделей

#### Архитектура очередей:

**Exchange: `coalfire` (direct)**
- Маршрутизация сообщений по routing keys

**Очереди:**
1. **`data.import`**
   - Routing key: `data.import`
   - TTL: 1 час
   - DLQ: `data.import.failed`
   - Назначение: Обработка импорта CSV

2. **`prediction.calculate`**
   - Routing key: `prediction.calculate`
   - TTL: 30 минут
   - DLQ: `prediction.calculate.failed`
   - Назначение: Прогноз для одного штабеля

3. **`prediction.batch`**
   - Routing key: `prediction.batch`
   - TTL: 1 час
   - DLQ: `prediction.batch.failed`
   - Назначение: Массовый расчет прогнозов

4. **`model.train`**
   - Routing key: `model.train`
   - TTL: 2 часа
   - DLQ: `model.train.failed`
   - Назначение: Обучение ML модели

**Dead Letter Exchange: `coalfire.dlx`**
- Для сообщений, которые не удалось обработать после 3 попыток

#### Retry механизм:
- Максимум 3 попытки повтора
- Экспоненциальная отсрочка: 1s, 2s, 4s
- После 3 неудачных попыток → DLQ

**Пример сообщения:**
```json
{
  "shtabelId": 123,
  "horizonDays": 7
}
```

### 3. PostgreSQL (SQL)

#### Протокол:
- **Протокол**: PostgreSQL wire protocol
- **Порт**: 5432
- **ORM**: Prisma (NestJS), SQLAlchemy (Python)

#### Схема базы данных:
- **User** — пользователи
- **Sklad** — склады
- **Shtabel** — штабели
- **Supply** — поставки
- **FireRecord** — записи о возгораниях
- **TempRecord** — температурные измерения
- **Weather** — метеоданные
- **Prediction** — прогнозы
- **ModelArtifact** — артефакты моделей
- **Metric** — метрики моделей
- **Notification** — уведомления
- **Upload** — загрузки файлов

### 4. Redis

#### Назначение:
- Кэширование данных
- Хранение сессий
- Временное хранение результатов

#### Протокол:
- **Протокол**: Redis protocol (RESP)
- **Порт**: 6379

### 5. Telegram Bot API

#### Протокол:
- **Протокол**: HTTPS
- **API**: Telegram Bot API
- **Библиотека**: Telegraf

#### Функции:
- Отправка уведомлений пользователям
- Команды бота (`/start`, меню)
- Интеграция с Mini App

---

## Потоки данных

### 1. Импорт данных из CSV

```
Пользователь → API (POST /data/upload)
    ↓
Сохранение файла на диск
    ↓
Публикация в RabbitMQ (data.import)
    ↓
DataImportConsumer получает сообщение
    ↓
DataImportProcessor обрабатывает CSV
    ↓
Prisma транзакция → PostgreSQL
    ↓
Обновление статуса Upload в БД
    ↓
Очистка файла с диска
```

### 2. Создание прогноза

```
Пользователь → API (POST /predictions/:shtabelId)
    ↓
Публикация в RabbitMQ (prediction.calculate)
    ↓
PredictionConsumer получает сообщение
    ↓
PredictionProcessor:
    ├─ Получение данных штабеля из PostgreSQL
    ├─ Сбор признаков (features)
    └─ HTTP запрос → ML Service (POST /predict)
         ↓
    ML Service:
    ├─ Загрузка модели XGBoost
    ├─ Предобработка признаков
    ├─ Прогнозирование
    └─ HTTP ответ с результатом
         ↓
Сохранение Prediction в PostgreSQL
    ↓
Создание Notification (если критический риск)
    ↓
Отправка уведомления через Telegram Bot (если настроено)
```

### 3. Обучение модели

```
Администратор → API (POST /ml/train)
    ↓
Публикация в RabbitMQ (model.train)
    ↓
ModelTrainingConsumer получает сообщение
    ↓
ModelTrainingProcessor:
    └─ HTTP запрос → ML Service (POST /train)
         ↓
    ML Service:
    ├─ Получение данных из PostgreSQL
    ├─ Предобработка данных
    ├─ Обучение XGBoost модели
    ├─ Расчет метрик
    ├─ Сохранение модели в файл (JSON)
    └─ HTTP ответ с результатами
         ↓
Сохранение ModelArtifact и Metric в PostgreSQL
```

### 4. Обновление метрик при возгорании

```
Импорт FireRecord через CSV
    ↓
Создание FireRecord в PostgreSQL
    ↓
Автоматическое обновление Prediction:
    ├─ Установка actualFireDate
    ├─ Расчет accuracy_days
    └─ Обновление isAccurate
    ↓
Метрики пересчитываются при запросе GET /metrics
```

---

## Сценарии использования

### Сценарий 1: Первичная настройка системы

1. **Загрузка исторических данных**
   - Администратор загружает CSV файлы через API:
     - `supplies.csv` — данные о поставках
     - `fires.csv` — исторические возгорания
     - `temperature.csv` — температурные измерения
     - `weather_data_*.csv` — метеоданные
   - Данные обрабатываются асинхронно через RabbitMQ
   - Результат: База данных заполнена историческими данными

2. **Обучение модели**
   - Администратор запускает обучение через API (`POST /api/ml/train`)
   - ML Service обучает модель на исторических данных
   - Модель сохраняется и становится активной
   - Результат: Обученная модель готова к использованию

### Сценарий 2: Ежедневный мониторинг штабелей

1. **Получение температурных данных**
   - Оператор загружает `temperature.csv` с новыми измерениями
   - Данные обрабатываются и сохраняются в БД

2. **Массовое прогнозирование**
   - Администратор запускает массовый расчет (`POST /api/predictions/batch/calculate`)
   - Система рассчитывает прогнозы для всех активных штабелей
   - Результаты сохраняются в БД

3. **Просмотр результатов**
   - Пользователь просматривает прогнозы через API (`GET /api/predictions`)
   - Фильтрация по уровню риска, складу, штабелю
   - Dashboard показывает статистику и тренды

4. **Уведомления**
   - При обнаружении критического риска создается уведомление
   - Telegram Bot отправляет уведомление пользователю
   - Пользователь получает предупреждение в реальном времени

### Сценарий 3: Реагирование на критический риск

1. **Обнаружение критического риска**
   - Система рассчитывает прогноз для штабеля
   - Вероятность возгорания ≥ 0.8 → уровень риска CRITICAL
   - Создается Prediction с riskLevel = CRITICAL

2. **Уведомление**
   - Создается Notification
   - Telegram Bot отправляет сообщение пользователю
   - Пользователь получает уведомление с деталями

3. **Действия пользователя**
   - Пользователь просматривает детали прогноза
   - Проверяет текущую температуру штабеля
   - Принимает меры (охлаждение, перемещение угля)

4. **Обновление данных**
   - Оператор загружает новые температурные измерения
   - Система пересчитывает прогноз
   - Риск может снизиться или подтвердиться

### Сценарий 4: Регистрация реального возгорания

1. **Импорт данных о возгорании**
   - Оператор загружает `fires.csv` с записью о возгорании
   - Создается FireRecord в БД

2. **Автоматическое обновление прогнозов**
   - Система находит все Prediction для этого штабеля
   - Устанавливает `actualFireDate` в Prediction
   - Рассчитывает `accuracy_days` (разница между predicted_date и actualFireDate)
   - Обновляет `isAccurate` (true, если разница ≤ 2 дня)

3. **Обновление метрик**
   - Метрики модели пересчитываются при запросе `GET /metrics`
   - Обновляются:
     - MAE (Mean Absolute Error) в днях
     - RMSE (Root Mean Square Error) в днях
     - Accuracy within 2/3/5 days

4. **Анализ качества модели**
   - Администратор просматривает метрики через Analytics API
   - Оценивает точность модели
   - При необходимости запускает переобучение модели

### Сценарий 5: Переобучение модели

1. **Накопление новых данных**
   - Система работает несколько месяцев
   - Накоплены новые данные о возгораниях и прогнозах

2. **Запуск переобучения**
   - Администратор запускает обучение через API
   - Указывает новую версию модели (например, 1.0.2)
   - Задача ставится в очередь RabbitMQ

3. **Обучение модели**
   - ML Service получает все данные из БД
   - Обучает новую модель на расширенном датасете
   - Рассчитывает метрики на тестовой выборке

4. **Развертывание новой модели**
   - Новая модель сохраняется с версией 1.0.2
   - Старая модель остается для отката
   - ML Service загружает новую модель

5. **Сравнение моделей**
   - Администратор сравнивает метрики старой и новой модели
   - Принимает решение о переходе на новую модель
   - При необходимости откатывается на старую версию

---

## Технические детали

### Обработка ошибок

1. **Retry механизм для ML Service**
   - Максимум 3 попытки при ошибках сети
   - Экспоненциальная отсрочка: 1s, 2s, 4s
   - Не повторяет при клиентских ошибках (4xx)

2. **Retry механизм для RabbitMQ**
   - Максимум 3 попытки обработки сообщения
   - Экспоненциальная отсрочка
   - После 3 попыток → Dead Letter Queue

3. **Обработка состояний гонки (Race Conditions)**
   - При параллельной обработке CSV возможны попытки создать дубликаты
   - Используются Prisma транзакции
   - Retry логика при ошибке уникальности (P2002)

### Производительность

1. **Асинхронная обработка**
   - Тяжелые операции через RabbitMQ
   - API не блокируется при обработке больших файлов

2. **Кэширование**
   - Redis для кэширования часто запрашиваемых данных
   - Кэширование метрик модели

3. **Оптимизация запросов**
   - Индексы в БД для быстрого поиска
   - Пагинация результатов
   - Оптимизированные SQL запросы через Prisma

### Безопасность

1. **Аутентификация**
   - Bearer Token для API
   - Telegram-based аутентификация

2. **Валидация данных**
   - Проверка размера файлов (макс. 50 МБ)
   - Проверка типов файлов
   - Валидация формата CSV

3. **Логирование**
   - Централизованное логирование всех операций
   - Логи ошибок с детальной информацией
   - Аудит действий пользователей

---

## Заключение

Система **Coal Fire Predictor** представляет собой комплексное решение для прогнозирования самовозгорания угля, использующее современные технологии микросервисной архитектуры, машинного обучения и асинхронной обработки данных. Система обеспечивает:

- **Надежность**: Retry механизмы, обработка ошибок, транзакции
- **Масштабируемость**: Асинхронная обработка, очереди сообщений
- **Точность**: ML модель с метриками качества
- **Удобство**: REST API, Telegram Bot, Dashboard
- **Мониторинг**: Логирование, метрики, аналитика

Система готова к использованию в production среде и может быть расширена дополнительными функциями по мере необходимости.

