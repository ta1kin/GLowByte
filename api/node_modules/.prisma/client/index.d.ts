
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Upload
 * 
 */
export type Upload = $Result.DefaultSelection<Prisma.$UploadPayload>
/**
 * Model Sklad
 * 
 */
export type Sklad = $Result.DefaultSelection<Prisma.$SkladPayload>
/**
 * Model Shtabel
 * 
 */
export type Shtabel = $Result.DefaultSelection<Prisma.$ShtabelPayload>
/**
 * Model Supply
 * 
 */
export type Supply = $Result.DefaultSelection<Prisma.$SupplyPayload>
/**
 * Model FireRecord
 * 
 */
export type FireRecord = $Result.DefaultSelection<Prisma.$FireRecordPayload>
/**
 * Model TempRecord
 * 
 */
export type TempRecord = $Result.DefaultSelection<Prisma.$TempRecordPayload>
/**
 * Model Weather
 * 
 */
export type Weather = $Result.DefaultSelection<Prisma.$WeatherPayload>
/**
 * Model FeatureVector
 * 
 */
export type FeatureVector = $Result.DefaultSelection<Prisma.$FeatureVectorPayload>
/**
 * Model Prediction
 * 
 */
export type Prediction = $Result.DefaultSelection<Prisma.$PredictionPayload>
/**
 * Model ModelArtifact
 * 
 */
export type ModelArtifact = $Result.DefaultSelection<Prisma.$ModelArtifactPayload>
/**
 * Model Metric
 * 
 */
export type Metric = $Result.DefaultSelection<Prisma.$MetricPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  OPERATOR: 'OPERATOR',
  ENGINEER: 'ENGINEER',
  ADMIN: 'ADMIN',
  ANALYST: 'ANALYST'
};

export type Role = (typeof Role)[keyof typeof Role]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  BLOCKED: 'BLOCKED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UploadStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PARTIAL: 'PARTIAL'
};

export type UploadStatus = (typeof UploadStatus)[keyof typeof UploadStatus]


export const FileType: {
  SUPPLIES: 'SUPPLIES',
  FIRES: 'FIRES',
  TEMPERATURE: 'TEMPERATURE',
  WEATHER: 'WEATHER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const ShtabelStatus: {
  ACTIVE: 'ACTIVE',
  SHIPPED: 'SHIPPED',
  FIRED: 'FIRED',
  ARCHIVED: 'ARCHIVED'
};

export type ShtabelStatus = (typeof ShtabelStatus)[keyof typeof ShtabelStatus]


export const RiskLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const ModelStatus: {
  TRAINING: 'TRAINING',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  FAILED: 'FAILED'
};

export type ModelStatus = (typeof ModelStatus)[keyof typeof ModelStatus]


export const NotificationType: {
  CRITICAL_RISK: 'CRITICAL_RISK',
  HIGH_RISK: 'HIGH_RISK',
  PREDICTION_READY: 'PREDICTION_READY',
  DATA_IMPORTED: 'DATA_IMPORTED',
  MODEL_TRAINED: 'MODEL_TRAINED',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  READ: 'READ',
  FAILED: 'FAILED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  VIEW: 'VIEW',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT',
  PREDICT: 'PREDICT',
  TRAIN_MODEL: 'TRAIN_MODEL',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UploadStatus = $Enums.UploadStatus

export const UploadStatus: typeof $Enums.UploadStatus

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type ShtabelStatus = $Enums.ShtabelStatus

export const ShtabelStatus: typeof $Enums.ShtabelStatus

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type ModelStatus = $Enums.ModelStatus

export const ModelStatus: typeof $Enums.ModelStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upload`: Exposes CRUD operations for the **Upload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uploads
    * const uploads = await prisma.upload.findMany()
    * ```
    */
  get upload(): Prisma.UploadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sklad`: Exposes CRUD operations for the **Sklad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sklads
    * const sklads = await prisma.sklad.findMany()
    * ```
    */
  get sklad(): Prisma.SkladDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shtabel`: Exposes CRUD operations for the **Shtabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shtabels
    * const shtabels = await prisma.shtabel.findMany()
    * ```
    */
  get shtabel(): Prisma.ShtabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supply`: Exposes CRUD operations for the **Supply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supplies
    * const supplies = await prisma.supply.findMany()
    * ```
    */
  get supply(): Prisma.SupplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fireRecord`: Exposes CRUD operations for the **FireRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FireRecords
    * const fireRecords = await prisma.fireRecord.findMany()
    * ```
    */
  get fireRecord(): Prisma.FireRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tempRecord`: Exposes CRUD operations for the **TempRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TempRecords
    * const tempRecords = await prisma.tempRecord.findMany()
    * ```
    */
  get tempRecord(): Prisma.TempRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureVector`: Exposes CRUD operations for the **FeatureVector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureVectors
    * const featureVectors = await prisma.featureVector.findMany()
    * ```
    */
  get featureVector(): Prisma.FeatureVectorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prediction`: Exposes CRUD operations for the **Prediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Predictions
    * const predictions = await prisma.prediction.findMany()
    * ```
    */
  get prediction(): Prisma.PredictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelArtifact`: Exposes CRUD operations for the **ModelArtifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelArtifacts
    * const modelArtifacts = await prisma.modelArtifact.findMany()
    * ```
    */
  get modelArtifact(): Prisma.ModelArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSettings: 'UserSettings',
    Upload: 'Upload',
    Sklad: 'Sklad',
    Shtabel: 'Shtabel',
    Supply: 'Supply',
    FireRecord: 'FireRecord',
    TempRecord: 'TempRecord',
    Weather: 'Weather',
    FeatureVector: 'FeatureVector',
    Prediction: 'Prediction',
    ModelArtifact: 'ModelArtifact',
    Metric: 'Metric',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    SystemSettings: 'SystemSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSettings" | "upload" | "sklad" | "shtabel" | "supply" | "fireRecord" | "tempRecord" | "weather" | "featureVector" | "prediction" | "modelArtifact" | "metric" | "notification" | "auditLog" | "systemSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Upload: {
        payload: Prisma.$UploadPayload<ExtArgs>
        fields: Prisma.UploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findFirst: {
            args: Prisma.UploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findMany: {
            args: Prisma.UploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          create: {
            args: Prisma.UploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          createMany: {
            args: Prisma.UploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          delete: {
            args: Prisma.UploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          update: {
            args: Prisma.UploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          deleteMany: {
            args: Prisma.UploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          upsert: {
            args: Prisma.UploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          aggregate: {
            args: Prisma.UploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpload>
          }
          groupBy: {
            args: Prisma.UploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadCountArgs<ExtArgs>
            result: $Utils.Optional<UploadCountAggregateOutputType> | number
          }
        }
      }
      Sklad: {
        payload: Prisma.$SkladPayload<ExtArgs>
        fields: Prisma.SkladFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkladFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkladFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          findFirst: {
            args: Prisma.SkladFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkladFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          findMany: {
            args: Prisma.SkladFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>[]
          }
          create: {
            args: Prisma.SkladCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          createMany: {
            args: Prisma.SkladCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkladCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>[]
          }
          delete: {
            args: Prisma.SkladDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          update: {
            args: Prisma.SkladUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          deleteMany: {
            args: Prisma.SkladDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkladUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkladUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>[]
          }
          upsert: {
            args: Prisma.SkladUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkladPayload>
          }
          aggregate: {
            args: Prisma.SkladAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSklad>
          }
          groupBy: {
            args: Prisma.SkladGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkladGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkladCountArgs<ExtArgs>
            result: $Utils.Optional<SkladCountAggregateOutputType> | number
          }
        }
      }
      Shtabel: {
        payload: Prisma.$ShtabelPayload<ExtArgs>
        fields: Prisma.ShtabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShtabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShtabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          findFirst: {
            args: Prisma.ShtabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShtabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          findMany: {
            args: Prisma.ShtabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>[]
          }
          create: {
            args: Prisma.ShtabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          createMany: {
            args: Prisma.ShtabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShtabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>[]
          }
          delete: {
            args: Prisma.ShtabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          update: {
            args: Prisma.ShtabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          deleteMany: {
            args: Prisma.ShtabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShtabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShtabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>[]
          }
          upsert: {
            args: Prisma.ShtabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShtabelPayload>
          }
          aggregate: {
            args: Prisma.ShtabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShtabel>
          }
          groupBy: {
            args: Prisma.ShtabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShtabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShtabelCountArgs<ExtArgs>
            result: $Utils.Optional<ShtabelCountAggregateOutputType> | number
          }
        }
      }
      Supply: {
        payload: Prisma.$SupplyPayload<ExtArgs>
        fields: Prisma.SupplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          findFirst: {
            args: Prisma.SupplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          findMany: {
            args: Prisma.SupplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>[]
          }
          create: {
            args: Prisma.SupplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          createMany: {
            args: Prisma.SupplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>[]
          }
          delete: {
            args: Prisma.SupplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          update: {
            args: Prisma.SupplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          deleteMany: {
            args: Prisma.SupplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>[]
          }
          upsert: {
            args: Prisma.SupplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyPayload>
          }
          aggregate: {
            args: Prisma.SupplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupply>
          }
          groupBy: {
            args: Prisma.SupplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplyCountArgs<ExtArgs>
            result: $Utils.Optional<SupplyCountAggregateOutputType> | number
          }
        }
      }
      FireRecord: {
        payload: Prisma.$FireRecordPayload<ExtArgs>
        fields: Prisma.FireRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FireRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FireRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          findFirst: {
            args: Prisma.FireRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FireRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          findMany: {
            args: Prisma.FireRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>[]
          }
          create: {
            args: Prisma.FireRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          createMany: {
            args: Prisma.FireRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FireRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>[]
          }
          delete: {
            args: Prisma.FireRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          update: {
            args: Prisma.FireRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          deleteMany: {
            args: Prisma.FireRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FireRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FireRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>[]
          }
          upsert: {
            args: Prisma.FireRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FireRecordPayload>
          }
          aggregate: {
            args: Prisma.FireRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFireRecord>
          }
          groupBy: {
            args: Prisma.FireRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<FireRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.FireRecordCountArgs<ExtArgs>
            result: $Utils.Optional<FireRecordCountAggregateOutputType> | number
          }
        }
      }
      TempRecord: {
        payload: Prisma.$TempRecordPayload<ExtArgs>
        fields: Prisma.TempRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TempRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TempRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          findFirst: {
            args: Prisma.TempRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TempRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          findMany: {
            args: Prisma.TempRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>[]
          }
          create: {
            args: Prisma.TempRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          createMany: {
            args: Prisma.TempRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TempRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>[]
          }
          delete: {
            args: Prisma.TempRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          update: {
            args: Prisma.TempRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          deleteMany: {
            args: Prisma.TempRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TempRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TempRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>[]
          }
          upsert: {
            args: Prisma.TempRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempRecordPayload>
          }
          aggregate: {
            args: Prisma.TempRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTempRecord>
          }
          groupBy: {
            args: Prisma.TempRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TempRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TempRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TempRecordCountAggregateOutputType> | number
          }
        }
      }
      Weather: {
        payload: Prisma.$WeatherPayload<ExtArgs>
        fields: Prisma.WeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findFirst: {
            args: Prisma.WeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findMany: {
            args: Prisma.WeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          create: {
            args: Prisma.WeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          createMany: {
            args: Prisma.WeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          delete: {
            args: Prisma.WeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          update: {
            args: Prisma.WeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          upsert: {
            args: Prisma.WeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeather>
          }
          groupBy: {
            args: Prisma.WeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherCountAggregateOutputType> | number
          }
        }
      }
      FeatureVector: {
        payload: Prisma.$FeatureVectorPayload<ExtArgs>
        fields: Prisma.FeatureVectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureVectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureVectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          findFirst: {
            args: Prisma.FeatureVectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureVectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          findMany: {
            args: Prisma.FeatureVectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>[]
          }
          create: {
            args: Prisma.FeatureVectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          createMany: {
            args: Prisma.FeatureVectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureVectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>[]
          }
          delete: {
            args: Prisma.FeatureVectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          update: {
            args: Prisma.FeatureVectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          deleteMany: {
            args: Prisma.FeatureVectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureVectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureVectorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>[]
          }
          upsert: {
            args: Prisma.FeatureVectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureVectorPayload>
          }
          aggregate: {
            args: Prisma.FeatureVectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureVector>
          }
          groupBy: {
            args: Prisma.FeatureVectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureVectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureVectorCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureVectorCountAggregateOutputType> | number
          }
        }
      }
      Prediction: {
        payload: Prisma.$PredictionPayload<ExtArgs>
        fields: Prisma.PredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findFirst: {
            args: Prisma.PredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findMany: {
            args: Prisma.PredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          create: {
            args: Prisma.PredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          createMany: {
            args: Prisma.PredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          delete: {
            args: Prisma.PredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          update: {
            args: Prisma.PredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          deleteMany: {
            args: Prisma.PredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PredictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          upsert: {
            args: Prisma.PredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          aggregate: {
            args: Prisma.PredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrediction>
          }
          groupBy: {
            args: Prisma.PredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionCountArgs<ExtArgs>
            result: $Utils.Optional<PredictionCountAggregateOutputType> | number
          }
        }
      }
      ModelArtifact: {
        payload: Prisma.$ModelArtifactPayload<ExtArgs>
        fields: Prisma.ModelArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          findFirst: {
            args: Prisma.ModelArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          findMany: {
            args: Prisma.ModelArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>[]
          }
          create: {
            args: Prisma.ModelArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          createMany: {
            args: Prisma.ModelArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>[]
          }
          delete: {
            args: Prisma.ModelArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          update: {
            args: Prisma.ModelArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ModelArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ModelArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelArtifactPayload>
          }
          aggregate: {
            args: Prisma.ModelArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelArtifact>
          }
          groupBy: {
            args: Prisma.ModelArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ModelArtifactCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: Prisma.$MetricPayload<ExtArgs>
        fields: Prisma.MetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSettings?: UserSettingsOmit
    upload?: UploadOmit
    sklad?: SkladOmit
    shtabel?: ShtabelOmit
    supply?: SupplyOmit
    fireRecord?: FireRecordOmit
    tempRecord?: TempRecordOmit
    weather?: WeatherOmit
    featureVector?: FeatureVectorOmit
    prediction?: PredictionOmit
    modelArtifact?: ModelArtifactOmit
    metric?: MetricOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    systemSettings?: SystemSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    uploads: number
    auditLogs: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploads?: boolean | UserCountOutputTypeCountUploadsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type SkladCountOutputType
   */

  export type SkladCountOutputType = {
    shtabels: number
    fires: number
    temps: number
    supplies: number
    predictions: number
    featureVectors: number
  }

  export type SkladCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shtabels?: boolean | SkladCountOutputTypeCountShtabelsArgs
    fires?: boolean | SkladCountOutputTypeCountFiresArgs
    temps?: boolean | SkladCountOutputTypeCountTempsArgs
    supplies?: boolean | SkladCountOutputTypeCountSuppliesArgs
    predictions?: boolean | SkladCountOutputTypeCountPredictionsArgs
    featureVectors?: boolean | SkladCountOutputTypeCountFeatureVectorsArgs
  }

  // Custom InputTypes
  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkladCountOutputType
     */
    select?: SkladCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountShtabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShtabelWhereInput
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountFiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FireRecordWhereInput
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempRecordWhereInput
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountSuppliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplyWhereInput
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
  }

  /**
   * SkladCountOutputType without action
   */
  export type SkladCountOutputTypeCountFeatureVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureVectorWhereInput
  }


  /**
   * Count Type ShtabelCountOutputType
   */

  export type ShtabelCountOutputType = {
    supplies: number
    temps: number
    predictions: number
    fires: number
    featureVectors: number
  }

  export type ShtabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplies?: boolean | ShtabelCountOutputTypeCountSuppliesArgs
    temps?: boolean | ShtabelCountOutputTypeCountTempsArgs
    predictions?: boolean | ShtabelCountOutputTypeCountPredictionsArgs
    fires?: boolean | ShtabelCountOutputTypeCountFiresArgs
    featureVectors?: boolean | ShtabelCountOutputTypeCountFeatureVectorsArgs
  }

  // Custom InputTypes
  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShtabelCountOutputType
     */
    select?: ShtabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeCountSuppliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplyWhereInput
  }

  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeCountTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempRecordWhereInput
  }

  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
  }

  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeCountFiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FireRecordWhereInput
  }

  /**
   * ShtabelCountOutputType without action
   */
  export type ShtabelCountOutputTypeCountFeatureVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureVectorWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    lang: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    lang: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    fullName: number
    role: number
    status: number
    lang: number
    phone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    fullName?: true
    role?: true
    status?: true
    lang?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    fullName?: true
    role?: true
    status?: true
    lang?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    fullName?: true
    role?: true
    status?: true
    lang?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    role: $Enums.Role
    status: $Enums.UserStatus
    lang: string
    phone: string | null
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    lang?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    lang?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    lang?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    lang?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telegramId" | "username" | "firstName" | "lastName" | "fullName" | "role" | "status" | "lang" | "phone" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      uploads: Prisma.$UploadPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      userSettings: Prisma.$UserSettingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      fullName: string | null
      role: $Enums.Role
      status: $Enums.UserStatus
      lang: string
      phone: string | null
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploads<T extends User$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSettings<T extends User$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly lang: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.uploads
   */
  export type User$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    cursor?: UploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.userSettings
   */
  export type User$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    defaultSkladId: number | null
    predictionHorizon: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    defaultSkladId: number | null
    predictionHorizon: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    notifyCritical: boolean | null
    notifyHigh: boolean | null
    notifyMedium: boolean | null
    notifyLow: boolean | null
    defaultSkladId: number | null
    defaultView: string | null
    predictionHorizon: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    notifyCritical: boolean | null
    notifyHigh: boolean | null
    notifyMedium: boolean | null
    notifyLow: boolean | null
    defaultSkladId: number | null
    defaultView: string | null
    predictionHorizon: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    notifyCritical: number
    notifyHigh: number
    notifyMedium: number
    notifyLow: number
    defaultSkladId: number
    defaultView: number
    predictionHorizon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    id?: true
    userId?: true
    defaultSkladId?: true
    predictionHorizon?: true
  }

  export type UserSettingsSumAggregateInputType = {
    id?: true
    userId?: true
    defaultSkladId?: true
    predictionHorizon?: true
  }

  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    notifyCritical?: true
    notifyHigh?: true
    notifyMedium?: true
    notifyLow?: true
    defaultSkladId?: true
    defaultView?: true
    predictionHorizon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    notifyCritical?: true
    notifyHigh?: true
    notifyMedium?: true
    notifyLow?: true
    defaultSkladId?: true
    defaultView?: true
    predictionHorizon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    notifyCritical?: true
    notifyHigh?: true
    notifyMedium?: true
    notifyLow?: true
    defaultSkladId?: true
    defaultView?: true
    predictionHorizon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: number
    userId: number
    notifyCritical: boolean
    notifyHigh: boolean
    notifyMedium: boolean
    notifyLow: boolean
    defaultSkladId: number | null
    defaultView: string
    predictionHorizon: number
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: boolean
    defaultView?: boolean
    predictionHorizon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: boolean
    defaultView?: boolean
    predictionHorizon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: boolean
    defaultView?: boolean
    predictionHorizon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: boolean
    defaultView?: boolean
    predictionHorizon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "notifyCritical" | "notifyHigh" | "notifyMedium" | "notifyLow" | "defaultSkladId" | "defaultView" | "predictionHorizon" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      notifyCritical: boolean
      notifyHigh: boolean
      notifyMedium: boolean
      notifyLow: boolean
      defaultSkladId: number | null
      defaultView: string
      predictionHorizon: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'Int'>
    readonly userId: FieldRef<"UserSettings", 'Int'>
    readonly notifyCritical: FieldRef<"UserSettings", 'Boolean'>
    readonly notifyHigh: FieldRef<"UserSettings", 'Boolean'>
    readonly notifyMedium: FieldRef<"UserSettings", 'Boolean'>
    readonly notifyLow: FieldRef<"UserSettings", 'Boolean'>
    readonly defaultSkladId: FieldRef<"UserSettings", 'Int'>
    readonly defaultView: FieldRef<"UserSettings", 'String'>
    readonly predictionHorizon: FieldRef<"UserSettings", 'Int'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Upload
   */

  export type AggregateUpload = {
    _count: UploadCountAggregateOutputType | null
    _avg: UploadAvgAggregateOutputType | null
    _sum: UploadSumAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  export type UploadAvgAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
    rowsTotal: number | null
    rowsProcessed: number | null
    rowsFailed: number | null
  }

  export type UploadSumAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
    rowsTotal: number | null
    rowsProcessed: number | null
    rowsFailed: number | null
  }

  export type UploadMinAggregateOutputType = {
    id: number | null
    filename: string | null
    fileType: $Enums.FileType | null
    uploadedBy: number | null
    status: $Enums.UploadStatus | null
    rowsTotal: number | null
    rowsProcessed: number | null
    rowsFailed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    fileType: $Enums.FileType | null
    uploadedBy: number | null
    status: $Enums.UploadStatus | null
    rowsTotal: number | null
    rowsProcessed: number | null
    rowsFailed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadCountAggregateOutputType = {
    id: number
    filename: number
    fileType: number
    uploadedBy: number
    status: number
    rowsTotal: number
    rowsProcessed: number
    rowsFailed: number
    errors: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UploadAvgAggregateInputType = {
    id?: true
    uploadedBy?: true
    rowsTotal?: true
    rowsProcessed?: true
    rowsFailed?: true
  }

  export type UploadSumAggregateInputType = {
    id?: true
    uploadedBy?: true
    rowsTotal?: true
    rowsProcessed?: true
    rowsFailed?: true
  }

  export type UploadMinAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    uploadedBy?: true
    status?: true
    rowsTotal?: true
    rowsProcessed?: true
    rowsFailed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadMaxAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    uploadedBy?: true
    status?: true
    rowsTotal?: true
    rowsProcessed?: true
    rowsFailed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadCountAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    uploadedBy?: true
    status?: true
    rowsTotal?: true
    rowsProcessed?: true
    rowsFailed?: true
    errors?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Upload to aggregate.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Uploads
    **/
    _count?: true | UploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadMaxAggregateInputType
  }

  export type GetUploadAggregateType<T extends UploadAggregateArgs> = {
        [P in keyof T & keyof AggregateUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpload[P]>
      : GetScalarType<T[P], AggregateUpload[P]>
  }




  export type UploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithAggregationInput | UploadOrderByWithAggregationInput[]
    by: UploadScalarFieldEnum[] | UploadScalarFieldEnum
    having?: UploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadCountAggregateInputType | true
    _avg?: UploadAvgAggregateInputType
    _sum?: UploadSumAggregateInputType
    _min?: UploadMinAggregateInputType
    _max?: UploadMaxAggregateInputType
  }

  export type UploadGroupByOutputType = {
    id: number
    filename: string
    fileType: $Enums.FileType
    uploadedBy: number | null
    status: $Enums.UploadStatus
    rowsTotal: number | null
    rowsProcessed: number | null
    rowsFailed: number | null
    errors: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UploadCountAggregateOutputType | null
    _avg: UploadAvgAggregateOutputType | null
    _sum: UploadSumAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  type GetUploadGroupByPayload<T extends UploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadGroupByOutputType[P]>
            : GetScalarType<T[P], UploadGroupByOutputType[P]>
        }
      >
    >


  export type UploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    status?: boolean
    rowsTotal?: boolean
    rowsProcessed?: boolean
    rowsFailed?: boolean
    errors?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    status?: boolean
    rowsTotal?: boolean
    rowsProcessed?: boolean
    rowsFailed?: boolean
    errors?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    status?: boolean
    rowsTotal?: boolean
    rowsProcessed?: boolean
    rowsFailed?: boolean
    errors?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectScalar = {
    id?: boolean
    filename?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    status?: boolean
    rowsTotal?: boolean
    rowsProcessed?: boolean
    rowsFailed?: boolean
    errors?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "fileType" | "uploadedBy" | "status" | "rowsTotal" | "rowsProcessed" | "rowsFailed" | "errors" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["upload"]>
  export type UploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }
  export type UploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }
  export type UploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }

  export type $UploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Upload"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      fileType: $Enums.FileType
      uploadedBy: number | null
      status: $Enums.UploadStatus
      rowsTotal: number | null
      rowsProcessed: number | null
      rowsFailed: number | null
      errors: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["upload"]>
    composites: {}
  }

  type UploadGetPayload<S extends boolean | null | undefined | UploadDefaultArgs> = $Result.GetResult<Prisma.$UploadPayload, S>

  type UploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UploadCountAggregateInputType | true
    }

  export interface UploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Upload'], meta: { name: 'Upload' } }
    /**
     * Find zero or one Upload that matches the filter.
     * @param {UploadFindUniqueArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadFindUniqueArgs>(args: SelectSubset<T, UploadFindUniqueArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Upload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UploadFindUniqueOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadFindFirstArgs>(args?: SelectSubset<T, UploadFindFirstArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uploads
     * const uploads = await prisma.upload.findMany()
     * 
     * // Get first 10 Uploads
     * const uploads = await prisma.upload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadWithIdOnly = await prisma.upload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadFindManyArgs>(args?: SelectSubset<T, UploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Upload.
     * @param {UploadCreateArgs} args - Arguments to create a Upload.
     * @example
     * // Create one Upload
     * const Upload = await prisma.upload.create({
     *   data: {
     *     // ... data to create a Upload
     *   }
     * })
     * 
     */
    create<T extends UploadCreateArgs>(args: SelectSubset<T, UploadCreateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uploads.
     * @param {UploadCreateManyArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadCreateManyArgs>(args?: SelectSubset<T, UploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Uploads and returns the data saved in the database.
     * @param {UploadCreateManyAndReturnArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Upload.
     * @param {UploadDeleteArgs} args - Arguments to delete one Upload.
     * @example
     * // Delete one Upload
     * const Upload = await prisma.upload.delete({
     *   where: {
     *     // ... filter to delete one Upload
     *   }
     * })
     * 
     */
    delete<T extends UploadDeleteArgs>(args: SelectSubset<T, UploadDeleteArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Upload.
     * @param {UploadUpdateArgs} args - Arguments to update one Upload.
     * @example
     * // Update one Upload
     * const upload = await prisma.upload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadUpdateArgs>(args: SelectSubset<T, UploadUpdateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uploads.
     * @param {UploadDeleteManyArgs} args - Arguments to filter Uploads to delete.
     * @example
     * // Delete a few Uploads
     * const { count } = await prisma.upload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadDeleteManyArgs>(args?: SelectSubset<T, UploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadUpdateManyArgs>(args: SelectSubset<T, UploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads and returns the data updated in the database.
     * @param {UploadUpdateManyAndReturnArgs} args - Arguments to update many Uploads.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UploadUpdateManyAndReturnArgs>(args: SelectSubset<T, UploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Upload.
     * @param {UploadUpsertArgs} args - Arguments to update or create a Upload.
     * @example
     * // Update or create a Upload
     * const upload = await prisma.upload.upsert({
     *   create: {
     *     // ... data to create a Upload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upload we want to update
     *   }
     * })
     */
    upsert<T extends UploadUpsertArgs>(args: SelectSubset<T, UploadUpsertArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadCountArgs} args - Arguments to filter Uploads to count.
     * @example
     * // Count the number of Uploads
     * const count = await prisma.upload.count({
     *   where: {
     *     // ... the filter for the Uploads we want to count
     *   }
     * })
    **/
    count<T extends UploadCountArgs>(
      args?: Subset<T, UploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadAggregateArgs>(args: Subset<T, UploadAggregateArgs>): Prisma.PrismaPromise<GetUploadAggregateType<T>>

    /**
     * Group by Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadGroupByArgs['orderBy'] }
        : { orderBy?: UploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Upload model
   */
  readonly fields: UploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Upload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Upload$userArgs<ExtArgs> = {}>(args?: Subset<T, Upload$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Upload model
   */
  interface UploadFieldRefs {
    readonly id: FieldRef<"Upload", 'Int'>
    readonly filename: FieldRef<"Upload", 'String'>
    readonly fileType: FieldRef<"Upload", 'FileType'>
    readonly uploadedBy: FieldRef<"Upload", 'Int'>
    readonly status: FieldRef<"Upload", 'UploadStatus'>
    readonly rowsTotal: FieldRef<"Upload", 'Int'>
    readonly rowsProcessed: FieldRef<"Upload", 'Int'>
    readonly rowsFailed: FieldRef<"Upload", 'Int'>
    readonly errors: FieldRef<"Upload", 'Json'>
    readonly metadata: FieldRef<"Upload", 'Json'>
    readonly createdAt: FieldRef<"Upload", 'DateTime'>
    readonly updatedAt: FieldRef<"Upload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Upload findUnique
   */
  export type UploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findUniqueOrThrow
   */
  export type UploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findFirst
   */
  export type UploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findFirstOrThrow
   */
  export type UploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findMany
   */
  export type UploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Uploads to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload create
   */
  export type UploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to create a Upload.
     */
    data: XOR<UploadCreateInput, UploadUncheckedCreateInput>
  }

  /**
   * Upload createMany
   */
  export type UploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Upload createManyAndReturn
   */
  export type UploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload update
   */
  export type UploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to update a Upload.
     */
    data: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
    /**
     * Choose, which Upload to update.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload updateMany
   */
  export type UploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
  }

  /**
   * Upload updateManyAndReturn
   */
  export type UploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload upsert
   */
  export type UploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The filter to search for the Upload to update in case it exists.
     */
    where: UploadWhereUniqueInput
    /**
     * In case the Upload found by the `where` argument doesn't exist, create a new Upload with this data.
     */
    create: XOR<UploadCreateInput, UploadUncheckedCreateInput>
    /**
     * In case the Upload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
  }

  /**
   * Upload delete
   */
  export type UploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter which Upload to delete.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload deleteMany
   */
  export type UploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Uploads to delete
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to delete.
     */
    limit?: number
  }

  /**
   * Upload.user
   */
  export type Upload$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Upload without action
   */
  export type UploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
  }


  /**
   * Model Sklad
   */

  export type AggregateSklad = {
    _count: SkladCountAggregateOutputType | null
    _avg: SkladAvgAggregateOutputType | null
    _sum: SkladSumAggregateOutputType | null
    _min: SkladMinAggregateOutputType | null
    _max: SkladMaxAggregateOutputType | null
  }

  export type SkladAvgAggregateOutputType = {
    id: number | null
    number: number | null
  }

  export type SkladSumAggregateOutputType = {
    id: number | null
    number: number | null
  }

  export type SkladMinAggregateOutputType = {
    id: number | null
    number: number | null
    name: string | null
    locationRaw: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkladMaxAggregateOutputType = {
    id: number | null
    number: number | null
    name: string | null
    locationRaw: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkladCountAggregateOutputType = {
    id: number
    number: number
    name: number
    locationRaw: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkladAvgAggregateInputType = {
    id?: true
    number?: true
  }

  export type SkladSumAggregateInputType = {
    id?: true
    number?: true
  }

  export type SkladMinAggregateInputType = {
    id?: true
    number?: true
    name?: true
    locationRaw?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkladMaxAggregateInputType = {
    id?: true
    number?: true
    name?: true
    locationRaw?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkladCountAggregateInputType = {
    id?: true
    number?: true
    name?: true
    locationRaw?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkladAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sklad to aggregate.
     */
    where?: SkladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sklads to fetch.
     */
    orderBy?: SkladOrderByWithRelationInput | SkladOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sklads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sklads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sklads
    **/
    _count?: true | SkladCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkladAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkladSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkladMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkladMaxAggregateInputType
  }

  export type GetSkladAggregateType<T extends SkladAggregateArgs> = {
        [P in keyof T & keyof AggregateSklad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSklad[P]>
      : GetScalarType<T[P], AggregateSklad[P]>
  }




  export type SkladGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkladWhereInput
    orderBy?: SkladOrderByWithAggregationInput | SkladOrderByWithAggregationInput[]
    by: SkladScalarFieldEnum[] | SkladScalarFieldEnum
    having?: SkladScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkladCountAggregateInputType | true
    _avg?: SkladAvgAggregateInputType
    _sum?: SkladSumAggregateInputType
    _min?: SkladMinAggregateInputType
    _max?: SkladMaxAggregateInputType
  }

  export type SkladGroupByOutputType = {
    id: number
    number: number
    name: string | null
    locationRaw: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SkladCountAggregateOutputType | null
    _avg: SkladAvgAggregateOutputType | null
    _sum: SkladSumAggregateOutputType | null
    _min: SkladMinAggregateOutputType | null
    _max: SkladMaxAggregateOutputType | null
  }

  type GetSkladGroupByPayload<T extends SkladGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkladGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkladGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkladGroupByOutputType[P]>
            : GetScalarType<T[P], SkladGroupByOutputType[P]>
        }
      >
    >


  export type SkladSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    name?: boolean
    locationRaw?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shtabels?: boolean | Sklad$shtabelsArgs<ExtArgs>
    fires?: boolean | Sklad$firesArgs<ExtArgs>
    temps?: boolean | Sklad$tempsArgs<ExtArgs>
    supplies?: boolean | Sklad$suppliesArgs<ExtArgs>
    predictions?: boolean | Sklad$predictionsArgs<ExtArgs>
    featureVectors?: boolean | Sklad$featureVectorsArgs<ExtArgs>
    _count?: boolean | SkladCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sklad"]>

  export type SkladSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    name?: boolean
    locationRaw?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sklad"]>

  export type SkladSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    name?: boolean
    locationRaw?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sklad"]>

  export type SkladSelectScalar = {
    id?: boolean
    number?: boolean
    name?: boolean
    locationRaw?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkladOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "name" | "locationRaw" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["sklad"]>
  export type SkladInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shtabels?: boolean | Sklad$shtabelsArgs<ExtArgs>
    fires?: boolean | Sklad$firesArgs<ExtArgs>
    temps?: boolean | Sklad$tempsArgs<ExtArgs>
    supplies?: boolean | Sklad$suppliesArgs<ExtArgs>
    predictions?: boolean | Sklad$predictionsArgs<ExtArgs>
    featureVectors?: boolean | Sklad$featureVectorsArgs<ExtArgs>
    _count?: boolean | SkladCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkladIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkladIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkladPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sklad"
    objects: {
      shtabels: Prisma.$ShtabelPayload<ExtArgs>[]
      fires: Prisma.$FireRecordPayload<ExtArgs>[]
      temps: Prisma.$TempRecordPayload<ExtArgs>[]
      supplies: Prisma.$SupplyPayload<ExtArgs>[]
      predictions: Prisma.$PredictionPayload<ExtArgs>[]
      featureVectors: Prisma.$FeatureVectorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: number
      name: string | null
      locationRaw: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sklad"]>
    composites: {}
  }

  type SkladGetPayload<S extends boolean | null | undefined | SkladDefaultArgs> = $Result.GetResult<Prisma.$SkladPayload, S>

  type SkladCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkladFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkladCountAggregateInputType | true
    }

  export interface SkladDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sklad'], meta: { name: 'Sklad' } }
    /**
     * Find zero or one Sklad that matches the filter.
     * @param {SkladFindUniqueArgs} args - Arguments to find a Sklad
     * @example
     * // Get one Sklad
     * const sklad = await prisma.sklad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkladFindUniqueArgs>(args: SelectSubset<T, SkladFindUniqueArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sklad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkladFindUniqueOrThrowArgs} args - Arguments to find a Sklad
     * @example
     * // Get one Sklad
     * const sklad = await prisma.sklad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkladFindUniqueOrThrowArgs>(args: SelectSubset<T, SkladFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sklad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladFindFirstArgs} args - Arguments to find a Sklad
     * @example
     * // Get one Sklad
     * const sklad = await prisma.sklad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkladFindFirstArgs>(args?: SelectSubset<T, SkladFindFirstArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sklad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladFindFirstOrThrowArgs} args - Arguments to find a Sklad
     * @example
     * // Get one Sklad
     * const sklad = await prisma.sklad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkladFindFirstOrThrowArgs>(args?: SelectSubset<T, SkladFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sklads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sklads
     * const sklads = await prisma.sklad.findMany()
     * 
     * // Get first 10 Sklads
     * const sklads = await prisma.sklad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skladWithIdOnly = await prisma.sklad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkladFindManyArgs>(args?: SelectSubset<T, SkladFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sklad.
     * @param {SkladCreateArgs} args - Arguments to create a Sklad.
     * @example
     * // Create one Sklad
     * const Sklad = await prisma.sklad.create({
     *   data: {
     *     // ... data to create a Sklad
     *   }
     * })
     * 
     */
    create<T extends SkladCreateArgs>(args: SelectSubset<T, SkladCreateArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sklads.
     * @param {SkladCreateManyArgs} args - Arguments to create many Sklads.
     * @example
     * // Create many Sklads
     * const sklad = await prisma.sklad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkladCreateManyArgs>(args?: SelectSubset<T, SkladCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sklads and returns the data saved in the database.
     * @param {SkladCreateManyAndReturnArgs} args - Arguments to create many Sklads.
     * @example
     * // Create many Sklads
     * const sklad = await prisma.sklad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sklads and only return the `id`
     * const skladWithIdOnly = await prisma.sklad.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkladCreateManyAndReturnArgs>(args?: SelectSubset<T, SkladCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sklad.
     * @param {SkladDeleteArgs} args - Arguments to delete one Sklad.
     * @example
     * // Delete one Sklad
     * const Sklad = await prisma.sklad.delete({
     *   where: {
     *     // ... filter to delete one Sklad
     *   }
     * })
     * 
     */
    delete<T extends SkladDeleteArgs>(args: SelectSubset<T, SkladDeleteArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sklad.
     * @param {SkladUpdateArgs} args - Arguments to update one Sklad.
     * @example
     * // Update one Sklad
     * const sklad = await prisma.sklad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkladUpdateArgs>(args: SelectSubset<T, SkladUpdateArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sklads.
     * @param {SkladDeleteManyArgs} args - Arguments to filter Sklads to delete.
     * @example
     * // Delete a few Sklads
     * const { count } = await prisma.sklad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkladDeleteManyArgs>(args?: SelectSubset<T, SkladDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sklads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sklads
     * const sklad = await prisma.sklad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkladUpdateManyArgs>(args: SelectSubset<T, SkladUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sklads and returns the data updated in the database.
     * @param {SkladUpdateManyAndReturnArgs} args - Arguments to update many Sklads.
     * @example
     * // Update many Sklads
     * const sklad = await prisma.sklad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sklads and only return the `id`
     * const skladWithIdOnly = await prisma.sklad.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkladUpdateManyAndReturnArgs>(args: SelectSubset<T, SkladUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sklad.
     * @param {SkladUpsertArgs} args - Arguments to update or create a Sklad.
     * @example
     * // Update or create a Sklad
     * const sklad = await prisma.sklad.upsert({
     *   create: {
     *     // ... data to create a Sklad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sklad we want to update
     *   }
     * })
     */
    upsert<T extends SkladUpsertArgs>(args: SelectSubset<T, SkladUpsertArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sklads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladCountArgs} args - Arguments to filter Sklads to count.
     * @example
     * // Count the number of Sklads
     * const count = await prisma.sklad.count({
     *   where: {
     *     // ... the filter for the Sklads we want to count
     *   }
     * })
    **/
    count<T extends SkladCountArgs>(
      args?: Subset<T, SkladCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkladCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sklad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkladAggregateArgs>(args: Subset<T, SkladAggregateArgs>): Prisma.PrismaPromise<GetSkladAggregateType<T>>

    /**
     * Group by Sklad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkladGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkladGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkladGroupByArgs['orderBy'] }
        : { orderBy?: SkladGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkladGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkladGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sklad model
   */
  readonly fields: SkladFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sklad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkladClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shtabels<T extends Sklad$shtabelsArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$shtabelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fires<T extends Sklad$firesArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$firesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    temps<T extends Sklad$tempsArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$tempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplies<T extends Sklad$suppliesArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$suppliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    predictions<T extends Sklad$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featureVectors<T extends Sklad$featureVectorsArgs<ExtArgs> = {}>(args?: Subset<T, Sklad$featureVectorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sklad model
   */
  interface SkladFieldRefs {
    readonly id: FieldRef<"Sklad", 'Int'>
    readonly number: FieldRef<"Sklad", 'Int'>
    readonly name: FieldRef<"Sklad", 'String'>
    readonly locationRaw: FieldRef<"Sklad", 'String'>
    readonly description: FieldRef<"Sklad", 'String'>
    readonly createdAt: FieldRef<"Sklad", 'DateTime'>
    readonly updatedAt: FieldRef<"Sklad", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sklad findUnique
   */
  export type SkladFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter, which Sklad to fetch.
     */
    where: SkladWhereUniqueInput
  }

  /**
   * Sklad findUniqueOrThrow
   */
  export type SkladFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter, which Sklad to fetch.
     */
    where: SkladWhereUniqueInput
  }

  /**
   * Sklad findFirst
   */
  export type SkladFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter, which Sklad to fetch.
     */
    where?: SkladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sklads to fetch.
     */
    orderBy?: SkladOrderByWithRelationInput | SkladOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sklads.
     */
    cursor?: SkladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sklads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sklads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sklads.
     */
    distinct?: SkladScalarFieldEnum | SkladScalarFieldEnum[]
  }

  /**
   * Sklad findFirstOrThrow
   */
  export type SkladFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter, which Sklad to fetch.
     */
    where?: SkladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sklads to fetch.
     */
    orderBy?: SkladOrderByWithRelationInput | SkladOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sklads.
     */
    cursor?: SkladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sklads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sklads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sklads.
     */
    distinct?: SkladScalarFieldEnum | SkladScalarFieldEnum[]
  }

  /**
   * Sklad findMany
   */
  export type SkladFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter, which Sklads to fetch.
     */
    where?: SkladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sklads to fetch.
     */
    orderBy?: SkladOrderByWithRelationInput | SkladOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sklads.
     */
    cursor?: SkladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sklads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sklads.
     */
    skip?: number
    distinct?: SkladScalarFieldEnum | SkladScalarFieldEnum[]
  }

  /**
   * Sklad create
   */
  export type SkladCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * The data needed to create a Sklad.
     */
    data: XOR<SkladCreateInput, SkladUncheckedCreateInput>
  }

  /**
   * Sklad createMany
   */
  export type SkladCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sklads.
     */
    data: SkladCreateManyInput | SkladCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sklad createManyAndReturn
   */
  export type SkladCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * The data used to create many Sklads.
     */
    data: SkladCreateManyInput | SkladCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sklad update
   */
  export type SkladUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * The data needed to update a Sklad.
     */
    data: XOR<SkladUpdateInput, SkladUncheckedUpdateInput>
    /**
     * Choose, which Sklad to update.
     */
    where: SkladWhereUniqueInput
  }

  /**
   * Sklad updateMany
   */
  export type SkladUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sklads.
     */
    data: XOR<SkladUpdateManyMutationInput, SkladUncheckedUpdateManyInput>
    /**
     * Filter which Sklads to update
     */
    where?: SkladWhereInput
    /**
     * Limit how many Sklads to update.
     */
    limit?: number
  }

  /**
   * Sklad updateManyAndReturn
   */
  export type SkladUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * The data used to update Sklads.
     */
    data: XOR<SkladUpdateManyMutationInput, SkladUncheckedUpdateManyInput>
    /**
     * Filter which Sklads to update
     */
    where?: SkladWhereInput
    /**
     * Limit how many Sklads to update.
     */
    limit?: number
  }

  /**
   * Sklad upsert
   */
  export type SkladUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * The filter to search for the Sklad to update in case it exists.
     */
    where: SkladWhereUniqueInput
    /**
     * In case the Sklad found by the `where` argument doesn't exist, create a new Sklad with this data.
     */
    create: XOR<SkladCreateInput, SkladUncheckedCreateInput>
    /**
     * In case the Sklad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkladUpdateInput, SkladUncheckedUpdateInput>
  }

  /**
   * Sklad delete
   */
  export type SkladDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
    /**
     * Filter which Sklad to delete.
     */
    where: SkladWhereUniqueInput
  }

  /**
   * Sklad deleteMany
   */
  export type SkladDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sklads to delete
     */
    where?: SkladWhereInput
    /**
     * Limit how many Sklads to delete.
     */
    limit?: number
  }

  /**
   * Sklad.shtabels
   */
  export type Sklad$shtabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    where?: ShtabelWhereInput
    orderBy?: ShtabelOrderByWithRelationInput | ShtabelOrderByWithRelationInput[]
    cursor?: ShtabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShtabelScalarFieldEnum | ShtabelScalarFieldEnum[]
  }

  /**
   * Sklad.fires
   */
  export type Sklad$firesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    where?: FireRecordWhereInput
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    cursor?: FireRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FireRecordScalarFieldEnum | FireRecordScalarFieldEnum[]
  }

  /**
   * Sklad.temps
   */
  export type Sklad$tempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    where?: TempRecordWhereInput
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    cursor?: TempRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TempRecordScalarFieldEnum | TempRecordScalarFieldEnum[]
  }

  /**
   * Sklad.supplies
   */
  export type Sklad$suppliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    where?: SupplyWhereInput
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    cursor?: SupplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplyScalarFieldEnum | SupplyScalarFieldEnum[]
  }

  /**
   * Sklad.predictions
   */
  export type Sklad$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    cursor?: PredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Sklad.featureVectors
   */
  export type Sklad$featureVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    where?: FeatureVectorWhereInput
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    cursor?: FeatureVectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureVectorScalarFieldEnum | FeatureVectorScalarFieldEnum[]
  }

  /**
   * Sklad without action
   */
  export type SkladDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sklad
     */
    select?: SkladSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sklad
     */
    omit?: SkladOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkladInclude<ExtArgs> | null
  }


  /**
   * Model Shtabel
   */

  export type AggregateShtabel = {
    _count: ShtabelCountAggregateOutputType | null
    _avg: ShtabelAvgAggregateOutputType | null
    _sum: ShtabelSumAggregateOutputType | null
    _min: ShtabelMinAggregateOutputType | null
    _max: ShtabelMaxAggregateOutputType | null
  }

  export type ShtabelAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    height_m: number | null
    width_m: number | null
    length_m: number | null
    mass_t: number | null
    currentMass: number | null
    lastTemp: number | null
  }

  export type ShtabelSumAggregateOutputType = {
    id: number | null
    skladId: number | null
    height_m: number | null
    width_m: number | null
    length_m: number | null
    mass_t: number | null
    currentMass: number | null
    lastTemp: number | null
  }

  export type ShtabelMinAggregateOutputType = {
    id: number | null
    skladId: number | null
    label: string | null
    mark: string | null
    formedAt: Date | null
    height_m: number | null
    width_m: number | null
    length_m: number | null
    mass_t: number | null
    status: $Enums.ShtabelStatus | null
    currentMass: number | null
    lastTemp: number | null
    lastTempDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShtabelMaxAggregateOutputType = {
    id: number | null
    skladId: number | null
    label: string | null
    mark: string | null
    formedAt: Date | null
    height_m: number | null
    width_m: number | null
    length_m: number | null
    mass_t: number | null
    status: $Enums.ShtabelStatus | null
    currentMass: number | null
    lastTemp: number | null
    lastTempDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShtabelCountAggregateOutputType = {
    id: number
    skladId: number
    label: number
    mark: number
    formedAt: number
    height_m: number
    width_m: number
    length_m: number
    mass_t: number
    status: number
    currentMass: number
    lastTemp: number
    lastTempDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShtabelAvgAggregateInputType = {
    id?: true
    skladId?: true
    height_m?: true
    width_m?: true
    length_m?: true
    mass_t?: true
    currentMass?: true
    lastTemp?: true
  }

  export type ShtabelSumAggregateInputType = {
    id?: true
    skladId?: true
    height_m?: true
    width_m?: true
    length_m?: true
    mass_t?: true
    currentMass?: true
    lastTemp?: true
  }

  export type ShtabelMinAggregateInputType = {
    id?: true
    skladId?: true
    label?: true
    mark?: true
    formedAt?: true
    height_m?: true
    width_m?: true
    length_m?: true
    mass_t?: true
    status?: true
    currentMass?: true
    lastTemp?: true
    lastTempDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShtabelMaxAggregateInputType = {
    id?: true
    skladId?: true
    label?: true
    mark?: true
    formedAt?: true
    height_m?: true
    width_m?: true
    length_m?: true
    mass_t?: true
    status?: true
    currentMass?: true
    lastTemp?: true
    lastTempDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShtabelCountAggregateInputType = {
    id?: true
    skladId?: true
    label?: true
    mark?: true
    formedAt?: true
    height_m?: true
    width_m?: true
    length_m?: true
    mass_t?: true
    status?: true
    currentMass?: true
    lastTemp?: true
    lastTempDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShtabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shtabel to aggregate.
     */
    where?: ShtabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shtabels to fetch.
     */
    orderBy?: ShtabelOrderByWithRelationInput | ShtabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShtabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shtabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shtabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shtabels
    **/
    _count?: true | ShtabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShtabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShtabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShtabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShtabelMaxAggregateInputType
  }

  export type GetShtabelAggregateType<T extends ShtabelAggregateArgs> = {
        [P in keyof T & keyof AggregateShtabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShtabel[P]>
      : GetScalarType<T[P], AggregateShtabel[P]>
  }




  export type ShtabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShtabelWhereInput
    orderBy?: ShtabelOrderByWithAggregationInput | ShtabelOrderByWithAggregationInput[]
    by: ShtabelScalarFieldEnum[] | ShtabelScalarFieldEnum
    having?: ShtabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShtabelCountAggregateInputType | true
    _avg?: ShtabelAvgAggregateInputType
    _sum?: ShtabelSumAggregateInputType
    _min?: ShtabelMinAggregateInputType
    _max?: ShtabelMaxAggregateInputType
  }

  export type ShtabelGroupByOutputType = {
    id: number
    skladId: number
    label: string
    mark: string | null
    formedAt: Date | null
    height_m: number | null
    width_m: number | null
    length_m: number | null
    mass_t: number | null
    status: $Enums.ShtabelStatus
    currentMass: number | null
    lastTemp: number | null
    lastTempDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ShtabelCountAggregateOutputType | null
    _avg: ShtabelAvgAggregateOutputType | null
    _sum: ShtabelSumAggregateOutputType | null
    _min: ShtabelMinAggregateOutputType | null
    _max: ShtabelMaxAggregateOutputType | null
  }

  type GetShtabelGroupByPayload<T extends ShtabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShtabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShtabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShtabelGroupByOutputType[P]>
            : GetScalarType<T[P], ShtabelGroupByOutputType[P]>
        }
      >
    >


  export type ShtabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    label?: boolean
    mark?: boolean
    formedAt?: boolean
    height_m?: boolean
    width_m?: boolean
    length_m?: boolean
    mass_t?: boolean
    status?: boolean
    currentMass?: boolean
    lastTemp?: boolean
    lastTempDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    supplies?: boolean | Shtabel$suppliesArgs<ExtArgs>
    temps?: boolean | Shtabel$tempsArgs<ExtArgs>
    predictions?: boolean | Shtabel$predictionsArgs<ExtArgs>
    fires?: boolean | Shtabel$firesArgs<ExtArgs>
    featureVectors?: boolean | Shtabel$featureVectorsArgs<ExtArgs>
    _count?: boolean | ShtabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shtabel"]>

  export type ShtabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    label?: boolean
    mark?: boolean
    formedAt?: boolean
    height_m?: boolean
    width_m?: boolean
    length_m?: boolean
    mass_t?: boolean
    status?: boolean
    currentMass?: boolean
    lastTemp?: boolean
    lastTempDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shtabel"]>

  export type ShtabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    label?: boolean
    mark?: boolean
    formedAt?: boolean
    height_m?: boolean
    width_m?: boolean
    length_m?: boolean
    mass_t?: boolean
    status?: boolean
    currentMass?: boolean
    lastTemp?: boolean
    lastTempDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shtabel"]>

  export type ShtabelSelectScalar = {
    id?: boolean
    skladId?: boolean
    label?: boolean
    mark?: boolean
    formedAt?: boolean
    height_m?: boolean
    width_m?: boolean
    length_m?: boolean
    mass_t?: boolean
    status?: boolean
    currentMass?: boolean
    lastTemp?: boolean
    lastTempDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShtabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skladId" | "label" | "mark" | "formedAt" | "height_m" | "width_m" | "length_m" | "mass_t" | "status" | "currentMass" | "lastTemp" | "lastTempDate" | "createdAt" | "updatedAt", ExtArgs["result"]["shtabel"]>
  export type ShtabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    supplies?: boolean | Shtabel$suppliesArgs<ExtArgs>
    temps?: boolean | Shtabel$tempsArgs<ExtArgs>
    predictions?: boolean | Shtabel$predictionsArgs<ExtArgs>
    fires?: boolean | Shtabel$firesArgs<ExtArgs>
    featureVectors?: boolean | Shtabel$featureVectorsArgs<ExtArgs>
    _count?: boolean | ShtabelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShtabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
  }
  export type ShtabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
  }

  export type $ShtabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shtabel"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      supplies: Prisma.$SupplyPayload<ExtArgs>[]
      temps: Prisma.$TempRecordPayload<ExtArgs>[]
      predictions: Prisma.$PredictionPayload<ExtArgs>[]
      fires: Prisma.$FireRecordPayload<ExtArgs>[]
      featureVectors: Prisma.$FeatureVectorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      skladId: number
      label: string
      mark: string | null
      formedAt: Date | null
      height_m: number | null
      width_m: number | null
      length_m: number | null
      mass_t: number | null
      status: $Enums.ShtabelStatus
      currentMass: number | null
      lastTemp: number | null
      lastTempDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shtabel"]>
    composites: {}
  }

  type ShtabelGetPayload<S extends boolean | null | undefined | ShtabelDefaultArgs> = $Result.GetResult<Prisma.$ShtabelPayload, S>

  type ShtabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShtabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShtabelCountAggregateInputType | true
    }

  export interface ShtabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shtabel'], meta: { name: 'Shtabel' } }
    /**
     * Find zero or one Shtabel that matches the filter.
     * @param {ShtabelFindUniqueArgs} args - Arguments to find a Shtabel
     * @example
     * // Get one Shtabel
     * const shtabel = await prisma.shtabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShtabelFindUniqueArgs>(args: SelectSubset<T, ShtabelFindUniqueArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shtabel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShtabelFindUniqueOrThrowArgs} args - Arguments to find a Shtabel
     * @example
     * // Get one Shtabel
     * const shtabel = await prisma.shtabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShtabelFindUniqueOrThrowArgs>(args: SelectSubset<T, ShtabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shtabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelFindFirstArgs} args - Arguments to find a Shtabel
     * @example
     * // Get one Shtabel
     * const shtabel = await prisma.shtabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShtabelFindFirstArgs>(args?: SelectSubset<T, ShtabelFindFirstArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shtabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelFindFirstOrThrowArgs} args - Arguments to find a Shtabel
     * @example
     * // Get one Shtabel
     * const shtabel = await prisma.shtabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShtabelFindFirstOrThrowArgs>(args?: SelectSubset<T, ShtabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shtabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shtabels
     * const shtabels = await prisma.shtabel.findMany()
     * 
     * // Get first 10 Shtabels
     * const shtabels = await prisma.shtabel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shtabelWithIdOnly = await prisma.shtabel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShtabelFindManyArgs>(args?: SelectSubset<T, ShtabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shtabel.
     * @param {ShtabelCreateArgs} args - Arguments to create a Shtabel.
     * @example
     * // Create one Shtabel
     * const Shtabel = await prisma.shtabel.create({
     *   data: {
     *     // ... data to create a Shtabel
     *   }
     * })
     * 
     */
    create<T extends ShtabelCreateArgs>(args: SelectSubset<T, ShtabelCreateArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shtabels.
     * @param {ShtabelCreateManyArgs} args - Arguments to create many Shtabels.
     * @example
     * // Create many Shtabels
     * const shtabel = await prisma.shtabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShtabelCreateManyArgs>(args?: SelectSubset<T, ShtabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shtabels and returns the data saved in the database.
     * @param {ShtabelCreateManyAndReturnArgs} args - Arguments to create many Shtabels.
     * @example
     * // Create many Shtabels
     * const shtabel = await prisma.shtabel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shtabels and only return the `id`
     * const shtabelWithIdOnly = await prisma.shtabel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShtabelCreateManyAndReturnArgs>(args?: SelectSubset<T, ShtabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shtabel.
     * @param {ShtabelDeleteArgs} args - Arguments to delete one Shtabel.
     * @example
     * // Delete one Shtabel
     * const Shtabel = await prisma.shtabel.delete({
     *   where: {
     *     // ... filter to delete one Shtabel
     *   }
     * })
     * 
     */
    delete<T extends ShtabelDeleteArgs>(args: SelectSubset<T, ShtabelDeleteArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shtabel.
     * @param {ShtabelUpdateArgs} args - Arguments to update one Shtabel.
     * @example
     * // Update one Shtabel
     * const shtabel = await prisma.shtabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShtabelUpdateArgs>(args: SelectSubset<T, ShtabelUpdateArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shtabels.
     * @param {ShtabelDeleteManyArgs} args - Arguments to filter Shtabels to delete.
     * @example
     * // Delete a few Shtabels
     * const { count } = await prisma.shtabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShtabelDeleteManyArgs>(args?: SelectSubset<T, ShtabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shtabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shtabels
     * const shtabel = await prisma.shtabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShtabelUpdateManyArgs>(args: SelectSubset<T, ShtabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shtabels and returns the data updated in the database.
     * @param {ShtabelUpdateManyAndReturnArgs} args - Arguments to update many Shtabels.
     * @example
     * // Update many Shtabels
     * const shtabel = await prisma.shtabel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shtabels and only return the `id`
     * const shtabelWithIdOnly = await prisma.shtabel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShtabelUpdateManyAndReturnArgs>(args: SelectSubset<T, ShtabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shtabel.
     * @param {ShtabelUpsertArgs} args - Arguments to update or create a Shtabel.
     * @example
     * // Update or create a Shtabel
     * const shtabel = await prisma.shtabel.upsert({
     *   create: {
     *     // ... data to create a Shtabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shtabel we want to update
     *   }
     * })
     */
    upsert<T extends ShtabelUpsertArgs>(args: SelectSubset<T, ShtabelUpsertArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shtabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelCountArgs} args - Arguments to filter Shtabels to count.
     * @example
     * // Count the number of Shtabels
     * const count = await prisma.shtabel.count({
     *   where: {
     *     // ... the filter for the Shtabels we want to count
     *   }
     * })
    **/
    count<T extends ShtabelCountArgs>(
      args?: Subset<T, ShtabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShtabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shtabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShtabelAggregateArgs>(args: Subset<T, ShtabelAggregateArgs>): Prisma.PrismaPromise<GetShtabelAggregateType<T>>

    /**
     * Group by Shtabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShtabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShtabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShtabelGroupByArgs['orderBy'] }
        : { orderBy?: ShtabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShtabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShtabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shtabel model
   */
  readonly fields: ShtabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shtabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShtabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplies<T extends Shtabel$suppliesArgs<ExtArgs> = {}>(args?: Subset<T, Shtabel$suppliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    temps<T extends Shtabel$tempsArgs<ExtArgs> = {}>(args?: Subset<T, Shtabel$tempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    predictions<T extends Shtabel$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, Shtabel$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fires<T extends Shtabel$firesArgs<ExtArgs> = {}>(args?: Subset<T, Shtabel$firesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featureVectors<T extends Shtabel$featureVectorsArgs<ExtArgs> = {}>(args?: Subset<T, Shtabel$featureVectorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shtabel model
   */
  interface ShtabelFieldRefs {
    readonly id: FieldRef<"Shtabel", 'Int'>
    readonly skladId: FieldRef<"Shtabel", 'Int'>
    readonly label: FieldRef<"Shtabel", 'String'>
    readonly mark: FieldRef<"Shtabel", 'String'>
    readonly formedAt: FieldRef<"Shtabel", 'DateTime'>
    readonly height_m: FieldRef<"Shtabel", 'Float'>
    readonly width_m: FieldRef<"Shtabel", 'Float'>
    readonly length_m: FieldRef<"Shtabel", 'Float'>
    readonly mass_t: FieldRef<"Shtabel", 'Float'>
    readonly status: FieldRef<"Shtabel", 'ShtabelStatus'>
    readonly currentMass: FieldRef<"Shtabel", 'Float'>
    readonly lastTemp: FieldRef<"Shtabel", 'Float'>
    readonly lastTempDate: FieldRef<"Shtabel", 'DateTime'>
    readonly createdAt: FieldRef<"Shtabel", 'DateTime'>
    readonly updatedAt: FieldRef<"Shtabel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shtabel findUnique
   */
  export type ShtabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter, which Shtabel to fetch.
     */
    where: ShtabelWhereUniqueInput
  }

  /**
   * Shtabel findUniqueOrThrow
   */
  export type ShtabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter, which Shtabel to fetch.
     */
    where: ShtabelWhereUniqueInput
  }

  /**
   * Shtabel findFirst
   */
  export type ShtabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter, which Shtabel to fetch.
     */
    where?: ShtabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shtabels to fetch.
     */
    orderBy?: ShtabelOrderByWithRelationInput | ShtabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shtabels.
     */
    cursor?: ShtabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shtabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shtabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shtabels.
     */
    distinct?: ShtabelScalarFieldEnum | ShtabelScalarFieldEnum[]
  }

  /**
   * Shtabel findFirstOrThrow
   */
  export type ShtabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter, which Shtabel to fetch.
     */
    where?: ShtabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shtabels to fetch.
     */
    orderBy?: ShtabelOrderByWithRelationInput | ShtabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shtabels.
     */
    cursor?: ShtabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shtabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shtabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shtabels.
     */
    distinct?: ShtabelScalarFieldEnum | ShtabelScalarFieldEnum[]
  }

  /**
   * Shtabel findMany
   */
  export type ShtabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter, which Shtabels to fetch.
     */
    where?: ShtabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shtabels to fetch.
     */
    orderBy?: ShtabelOrderByWithRelationInput | ShtabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shtabels.
     */
    cursor?: ShtabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shtabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shtabels.
     */
    skip?: number
    distinct?: ShtabelScalarFieldEnum | ShtabelScalarFieldEnum[]
  }

  /**
   * Shtabel create
   */
  export type ShtabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Shtabel.
     */
    data: XOR<ShtabelCreateInput, ShtabelUncheckedCreateInput>
  }

  /**
   * Shtabel createMany
   */
  export type ShtabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shtabels.
     */
    data: ShtabelCreateManyInput | ShtabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shtabel createManyAndReturn
   */
  export type ShtabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * The data used to create many Shtabels.
     */
    data: ShtabelCreateManyInput | ShtabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shtabel update
   */
  export type ShtabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Shtabel.
     */
    data: XOR<ShtabelUpdateInput, ShtabelUncheckedUpdateInput>
    /**
     * Choose, which Shtabel to update.
     */
    where: ShtabelWhereUniqueInput
  }

  /**
   * Shtabel updateMany
   */
  export type ShtabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shtabels.
     */
    data: XOR<ShtabelUpdateManyMutationInput, ShtabelUncheckedUpdateManyInput>
    /**
     * Filter which Shtabels to update
     */
    where?: ShtabelWhereInput
    /**
     * Limit how many Shtabels to update.
     */
    limit?: number
  }

  /**
   * Shtabel updateManyAndReturn
   */
  export type ShtabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * The data used to update Shtabels.
     */
    data: XOR<ShtabelUpdateManyMutationInput, ShtabelUncheckedUpdateManyInput>
    /**
     * Filter which Shtabels to update
     */
    where?: ShtabelWhereInput
    /**
     * Limit how many Shtabels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shtabel upsert
   */
  export type ShtabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Shtabel to update in case it exists.
     */
    where: ShtabelWhereUniqueInput
    /**
     * In case the Shtabel found by the `where` argument doesn't exist, create a new Shtabel with this data.
     */
    create: XOR<ShtabelCreateInput, ShtabelUncheckedCreateInput>
    /**
     * In case the Shtabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShtabelUpdateInput, ShtabelUncheckedUpdateInput>
  }

  /**
   * Shtabel delete
   */
  export type ShtabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    /**
     * Filter which Shtabel to delete.
     */
    where: ShtabelWhereUniqueInput
  }

  /**
   * Shtabel deleteMany
   */
  export type ShtabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shtabels to delete
     */
    where?: ShtabelWhereInput
    /**
     * Limit how many Shtabels to delete.
     */
    limit?: number
  }

  /**
   * Shtabel.supplies
   */
  export type Shtabel$suppliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    where?: SupplyWhereInput
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    cursor?: SupplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplyScalarFieldEnum | SupplyScalarFieldEnum[]
  }

  /**
   * Shtabel.temps
   */
  export type Shtabel$tempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    where?: TempRecordWhereInput
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    cursor?: TempRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TempRecordScalarFieldEnum | TempRecordScalarFieldEnum[]
  }

  /**
   * Shtabel.predictions
   */
  export type Shtabel$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    cursor?: PredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Shtabel.fires
   */
  export type Shtabel$firesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    where?: FireRecordWhereInput
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    cursor?: FireRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FireRecordScalarFieldEnum | FireRecordScalarFieldEnum[]
  }

  /**
   * Shtabel.featureVectors
   */
  export type Shtabel$featureVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    where?: FeatureVectorWhereInput
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    cursor?: FeatureVectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureVectorScalarFieldEnum | FeatureVectorScalarFieldEnum[]
  }

  /**
   * Shtabel without action
   */
  export type ShtabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
  }


  /**
   * Model Supply
   */

  export type AggregateSupply = {
    _count: SupplyCountAggregateOutputType | null
    _avg: SupplyAvgAggregateOutputType | null
    _sum: SupplySumAggregateOutputType | null
    _min: SupplyMinAggregateOutputType | null
    _max: SupplyMaxAggregateOutputType | null
  }

  export type SupplyAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    toStorage_t: number | null
    toShip_t: number | null
  }

  export type SupplySumAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    toStorage_t: number | null
    toShip_t: number | null
  }

  export type SupplyMinAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    dateIn: Date | null
    mark: string | null
    dateShip: Date | null
    toStorage_t: number | null
    toShip_t: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplyMaxAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    dateIn: Date | null
    mark: string | null
    dateShip: Date | null
    toStorage_t: number | null
    toShip_t: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplyCountAggregateOutputType = {
    id: number
    skladId: number
    shtabelId: number
    dateIn: number
    mark: number
    dateShip: number
    toStorage_t: number
    toShip_t: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplyAvgAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    toStorage_t?: true
    toShip_t?: true
  }

  export type SupplySumAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    toStorage_t?: true
    toShip_t?: true
  }

  export type SupplyMinAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    dateIn?: true
    mark?: true
    dateShip?: true
    toStorage_t?: true
    toShip_t?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplyMaxAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    dateIn?: true
    mark?: true
    dateShip?: true
    toStorage_t?: true
    toShip_t?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplyCountAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    dateIn?: true
    mark?: true
    dateShip?: true
    toStorage_t?: true
    toShip_t?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supply to aggregate.
     */
    where?: SupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supplies to fetch.
     */
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Supplies
    **/
    _count?: true | SupplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplyMaxAggregateInputType
  }

  export type GetSupplyAggregateType<T extends SupplyAggregateArgs> = {
        [P in keyof T & keyof AggregateSupply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupply[P]>
      : GetScalarType<T[P], AggregateSupply[P]>
  }




  export type SupplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplyWhereInput
    orderBy?: SupplyOrderByWithAggregationInput | SupplyOrderByWithAggregationInput[]
    by: SupplyScalarFieldEnum[] | SupplyScalarFieldEnum
    having?: SupplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplyCountAggregateInputType | true
    _avg?: SupplyAvgAggregateInputType
    _sum?: SupplySumAggregateInputType
    _min?: SupplyMinAggregateInputType
    _max?: SupplyMaxAggregateInputType
  }

  export type SupplyGroupByOutputType = {
    id: number
    skladId: number
    shtabelId: number
    dateIn: Date
    mark: string | null
    dateShip: Date | null
    toStorage_t: number | null
    toShip_t: number | null
    createdAt: Date
    updatedAt: Date
    _count: SupplyCountAggregateOutputType | null
    _avg: SupplyAvgAggregateOutputType | null
    _sum: SupplySumAggregateOutputType | null
    _min: SupplyMinAggregateOutputType | null
    _max: SupplyMaxAggregateOutputType | null
  }

  type GetSupplyGroupByPayload<T extends SupplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplyGroupByOutputType[P]>
            : GetScalarType<T[P], SupplyGroupByOutputType[P]>
        }
      >
    >


  export type SupplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    dateIn?: boolean
    mark?: boolean
    dateShip?: boolean
    toStorage_t?: boolean
    toShip_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supply"]>

  export type SupplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    dateIn?: boolean
    mark?: boolean
    dateShip?: boolean
    toStorage_t?: boolean
    toShip_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supply"]>

  export type SupplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    dateIn?: boolean
    mark?: boolean
    dateShip?: boolean
    toStorage_t?: boolean
    toShip_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supply"]>

  export type SupplySelectScalar = {
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    dateIn?: boolean
    mark?: boolean
    dateShip?: boolean
    toStorage_t?: boolean
    toShip_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skladId" | "shtabelId" | "dateIn" | "mark" | "dateShip" | "toStorage_t" | "toShip_t" | "createdAt" | "updatedAt", ExtArgs["result"]["supply"]>
  export type SupplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type SupplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type SupplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }

  export type $SupplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supply"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      shtabel: Prisma.$ShtabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      skladId: number
      shtabelId: number
      dateIn: Date
      mark: string | null
      dateShip: Date | null
      toStorage_t: number | null
      toShip_t: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supply"]>
    composites: {}
  }

  type SupplyGetPayload<S extends boolean | null | undefined | SupplyDefaultArgs> = $Result.GetResult<Prisma.$SupplyPayload, S>

  type SupplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplyCountAggregateInputType | true
    }

  export interface SupplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supply'], meta: { name: 'Supply' } }
    /**
     * Find zero or one Supply that matches the filter.
     * @param {SupplyFindUniqueArgs} args - Arguments to find a Supply
     * @example
     * // Get one Supply
     * const supply = await prisma.supply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplyFindUniqueArgs>(args: SelectSubset<T, SupplyFindUniqueArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplyFindUniqueOrThrowArgs} args - Arguments to find a Supply
     * @example
     * // Get one Supply
     * const supply = await prisma.supply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplyFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyFindFirstArgs} args - Arguments to find a Supply
     * @example
     * // Get one Supply
     * const supply = await prisma.supply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplyFindFirstArgs>(args?: SelectSubset<T, SupplyFindFirstArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyFindFirstOrThrowArgs} args - Arguments to find a Supply
     * @example
     * // Get one Supply
     * const supply = await prisma.supply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplyFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Supplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supplies
     * const supplies = await prisma.supply.findMany()
     * 
     * // Get first 10 Supplies
     * const supplies = await prisma.supply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplyWithIdOnly = await prisma.supply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplyFindManyArgs>(args?: SelectSubset<T, SupplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supply.
     * @param {SupplyCreateArgs} args - Arguments to create a Supply.
     * @example
     * // Create one Supply
     * const Supply = await prisma.supply.create({
     *   data: {
     *     // ... data to create a Supply
     *   }
     * })
     * 
     */
    create<T extends SupplyCreateArgs>(args: SelectSubset<T, SupplyCreateArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Supplies.
     * @param {SupplyCreateManyArgs} args - Arguments to create many Supplies.
     * @example
     * // Create many Supplies
     * const supply = await prisma.supply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplyCreateManyArgs>(args?: SelectSubset<T, SupplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Supplies and returns the data saved in the database.
     * @param {SupplyCreateManyAndReturnArgs} args - Arguments to create many Supplies.
     * @example
     * // Create many Supplies
     * const supply = await prisma.supply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Supplies and only return the `id`
     * const supplyWithIdOnly = await prisma.supply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplyCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supply.
     * @param {SupplyDeleteArgs} args - Arguments to delete one Supply.
     * @example
     * // Delete one Supply
     * const Supply = await prisma.supply.delete({
     *   where: {
     *     // ... filter to delete one Supply
     *   }
     * })
     * 
     */
    delete<T extends SupplyDeleteArgs>(args: SelectSubset<T, SupplyDeleteArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supply.
     * @param {SupplyUpdateArgs} args - Arguments to update one Supply.
     * @example
     * // Update one Supply
     * const supply = await prisma.supply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplyUpdateArgs>(args: SelectSubset<T, SupplyUpdateArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Supplies.
     * @param {SupplyDeleteManyArgs} args - Arguments to filter Supplies to delete.
     * @example
     * // Delete a few Supplies
     * const { count } = await prisma.supply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplyDeleteManyArgs>(args?: SelectSubset<T, SupplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supplies
     * const supply = await prisma.supply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplyUpdateManyArgs>(args: SelectSubset<T, SupplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supplies and returns the data updated in the database.
     * @param {SupplyUpdateManyAndReturnArgs} args - Arguments to update many Supplies.
     * @example
     * // Update many Supplies
     * const supply = await prisma.supply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Supplies and only return the `id`
     * const supplyWithIdOnly = await prisma.supply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplyUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supply.
     * @param {SupplyUpsertArgs} args - Arguments to update or create a Supply.
     * @example
     * // Update or create a Supply
     * const supply = await prisma.supply.upsert({
     *   create: {
     *     // ... data to create a Supply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supply we want to update
     *   }
     * })
     */
    upsert<T extends SupplyUpsertArgs>(args: SelectSubset<T, SupplyUpsertArgs<ExtArgs>>): Prisma__SupplyClient<$Result.GetResult<Prisma.$SupplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Supplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyCountArgs} args - Arguments to filter Supplies to count.
     * @example
     * // Count the number of Supplies
     * const count = await prisma.supply.count({
     *   where: {
     *     // ... the filter for the Supplies we want to count
     *   }
     * })
    **/
    count<T extends SupplyCountArgs>(
      args?: Subset<T, SupplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplyAggregateArgs>(args: Subset<T, SupplyAggregateArgs>): Prisma.PrismaPromise<GetSupplyAggregateType<T>>

    /**
     * Group by Supply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplyGroupByArgs['orderBy'] }
        : { orderBy?: SupplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supply model
   */
  readonly fields: SupplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shtabel<T extends ShtabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShtabelDefaultArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supply model
   */
  interface SupplyFieldRefs {
    readonly id: FieldRef<"Supply", 'Int'>
    readonly skladId: FieldRef<"Supply", 'Int'>
    readonly shtabelId: FieldRef<"Supply", 'Int'>
    readonly dateIn: FieldRef<"Supply", 'DateTime'>
    readonly mark: FieldRef<"Supply", 'String'>
    readonly dateShip: FieldRef<"Supply", 'DateTime'>
    readonly toStorage_t: FieldRef<"Supply", 'Float'>
    readonly toShip_t: FieldRef<"Supply", 'Float'>
    readonly createdAt: FieldRef<"Supply", 'DateTime'>
    readonly updatedAt: FieldRef<"Supply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supply findUnique
   */
  export type SupplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter, which Supply to fetch.
     */
    where: SupplyWhereUniqueInput
  }

  /**
   * Supply findUniqueOrThrow
   */
  export type SupplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter, which Supply to fetch.
     */
    where: SupplyWhereUniqueInput
  }

  /**
   * Supply findFirst
   */
  export type SupplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter, which Supply to fetch.
     */
    where?: SupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supplies to fetch.
     */
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supplies.
     */
    cursor?: SupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supplies.
     */
    distinct?: SupplyScalarFieldEnum | SupplyScalarFieldEnum[]
  }

  /**
   * Supply findFirstOrThrow
   */
  export type SupplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter, which Supply to fetch.
     */
    where?: SupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supplies to fetch.
     */
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supplies.
     */
    cursor?: SupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supplies.
     */
    distinct?: SupplyScalarFieldEnum | SupplyScalarFieldEnum[]
  }

  /**
   * Supply findMany
   */
  export type SupplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter, which Supplies to fetch.
     */
    where?: SupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supplies to fetch.
     */
    orderBy?: SupplyOrderByWithRelationInput | SupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Supplies.
     */
    cursor?: SupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supplies.
     */
    skip?: number
    distinct?: SupplyScalarFieldEnum | SupplyScalarFieldEnum[]
  }

  /**
   * Supply create
   */
  export type SupplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * The data needed to create a Supply.
     */
    data: XOR<SupplyCreateInput, SupplyUncheckedCreateInput>
  }

  /**
   * Supply createMany
   */
  export type SupplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Supplies.
     */
    data: SupplyCreateManyInput | SupplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supply createManyAndReturn
   */
  export type SupplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * The data used to create many Supplies.
     */
    data: SupplyCreateManyInput | SupplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supply update
   */
  export type SupplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * The data needed to update a Supply.
     */
    data: XOR<SupplyUpdateInput, SupplyUncheckedUpdateInput>
    /**
     * Choose, which Supply to update.
     */
    where: SupplyWhereUniqueInput
  }

  /**
   * Supply updateMany
   */
  export type SupplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Supplies.
     */
    data: XOR<SupplyUpdateManyMutationInput, SupplyUncheckedUpdateManyInput>
    /**
     * Filter which Supplies to update
     */
    where?: SupplyWhereInput
    /**
     * Limit how many Supplies to update.
     */
    limit?: number
  }

  /**
   * Supply updateManyAndReturn
   */
  export type SupplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * The data used to update Supplies.
     */
    data: XOR<SupplyUpdateManyMutationInput, SupplyUncheckedUpdateManyInput>
    /**
     * Filter which Supplies to update
     */
    where?: SupplyWhereInput
    /**
     * Limit how many Supplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supply upsert
   */
  export type SupplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * The filter to search for the Supply to update in case it exists.
     */
    where: SupplyWhereUniqueInput
    /**
     * In case the Supply found by the `where` argument doesn't exist, create a new Supply with this data.
     */
    create: XOR<SupplyCreateInput, SupplyUncheckedCreateInput>
    /**
     * In case the Supply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplyUpdateInput, SupplyUncheckedUpdateInput>
  }

  /**
   * Supply delete
   */
  export type SupplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
    /**
     * Filter which Supply to delete.
     */
    where: SupplyWhereUniqueInput
  }

  /**
   * Supply deleteMany
   */
  export type SupplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplies to delete
     */
    where?: SupplyWhereInput
    /**
     * Limit how many Supplies to delete.
     */
    limit?: number
  }

  /**
   * Supply without action
   */
  export type SupplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supply
     */
    select?: SupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supply
     */
    omit?: SupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplyInclude<ExtArgs> | null
  }


  /**
   * Model FireRecord
   */

  export type AggregateFireRecord = {
    _count: FireRecordCountAggregateOutputType | null
    _avg: FireRecordAvgAggregateOutputType | null
    _sum: FireRecordSumAggregateOutputType | null
    _min: FireRecordMinAggregateOutputType | null
    _max: FireRecordMaxAggregateOutputType | null
  }

  export type FireRecordAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    weight_t: number | null
    duration_hours: number | null
    damage_t: number | null
  }

  export type FireRecordSumAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    weight_t: number | null
    duration_hours: number | null
    damage_t: number | null
  }

  export type FireRecordMinAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    reportDate: Date | null
    mark: string | null
    weight_t: number | null
    startDate: Date | null
    endDate: Date | null
    formedAt: Date | null
    duration_hours: number | null
    damage_t: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FireRecordMaxAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    reportDate: Date | null
    mark: string | null
    weight_t: number | null
    startDate: Date | null
    endDate: Date | null
    formedAt: Date | null
    duration_hours: number | null
    damage_t: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FireRecordCountAggregateOutputType = {
    id: number
    skladId: number
    shtabelId: number
    reportDate: number
    mark: number
    weight_t: number
    startDate: number
    endDate: number
    formedAt: number
    duration_hours: number
    damage_t: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FireRecordAvgAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    weight_t?: true
    duration_hours?: true
    damage_t?: true
  }

  export type FireRecordSumAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    weight_t?: true
    duration_hours?: true
    damage_t?: true
  }

  export type FireRecordMinAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    reportDate?: true
    mark?: true
    weight_t?: true
    startDate?: true
    endDate?: true
    formedAt?: true
    duration_hours?: true
    damage_t?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FireRecordMaxAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    reportDate?: true
    mark?: true
    weight_t?: true
    startDate?: true
    endDate?: true
    formedAt?: true
    duration_hours?: true
    damage_t?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FireRecordCountAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    reportDate?: true
    mark?: true
    weight_t?: true
    startDate?: true
    endDate?: true
    formedAt?: true
    duration_hours?: true
    damage_t?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FireRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FireRecord to aggregate.
     */
    where?: FireRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FireRecords to fetch.
     */
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FireRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FireRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FireRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FireRecords
    **/
    _count?: true | FireRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FireRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FireRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FireRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FireRecordMaxAggregateInputType
  }

  export type GetFireRecordAggregateType<T extends FireRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateFireRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFireRecord[P]>
      : GetScalarType<T[P], AggregateFireRecord[P]>
  }




  export type FireRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FireRecordWhereInput
    orderBy?: FireRecordOrderByWithAggregationInput | FireRecordOrderByWithAggregationInput[]
    by: FireRecordScalarFieldEnum[] | FireRecordScalarFieldEnum
    having?: FireRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FireRecordCountAggregateInputType | true
    _avg?: FireRecordAvgAggregateInputType
    _sum?: FireRecordSumAggregateInputType
    _min?: FireRecordMinAggregateInputType
    _max?: FireRecordMaxAggregateInputType
  }

  export type FireRecordGroupByOutputType = {
    id: number
    skladId: number
    shtabelId: number | null
    reportDate: Date
    mark: string | null
    weight_t: number | null
    startDate: Date
    endDate: Date | null
    formedAt: Date | null
    duration_hours: number | null
    damage_t: number | null
    createdAt: Date
    updatedAt: Date
    _count: FireRecordCountAggregateOutputType | null
    _avg: FireRecordAvgAggregateOutputType | null
    _sum: FireRecordSumAggregateOutputType | null
    _min: FireRecordMinAggregateOutputType | null
    _max: FireRecordMaxAggregateOutputType | null
  }

  type GetFireRecordGroupByPayload<T extends FireRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FireRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FireRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FireRecordGroupByOutputType[P]>
            : GetScalarType<T[P], FireRecordGroupByOutputType[P]>
        }
      >
    >


  export type FireRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    reportDate?: boolean
    mark?: boolean
    weight_t?: boolean
    startDate?: boolean
    endDate?: boolean
    formedAt?: boolean
    duration_hours?: boolean
    damage_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }, ExtArgs["result"]["fireRecord"]>

  export type FireRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    reportDate?: boolean
    mark?: boolean
    weight_t?: boolean
    startDate?: boolean
    endDate?: boolean
    formedAt?: boolean
    duration_hours?: boolean
    damage_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }, ExtArgs["result"]["fireRecord"]>

  export type FireRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    reportDate?: boolean
    mark?: boolean
    weight_t?: boolean
    startDate?: boolean
    endDate?: boolean
    formedAt?: boolean
    duration_hours?: boolean
    damage_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }, ExtArgs["result"]["fireRecord"]>

  export type FireRecordSelectScalar = {
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    reportDate?: boolean
    mark?: boolean
    weight_t?: boolean
    startDate?: boolean
    endDate?: boolean
    formedAt?: boolean
    duration_hours?: boolean
    damage_t?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FireRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skladId" | "shtabelId" | "reportDate" | "mark" | "weight_t" | "startDate" | "endDate" | "formedAt" | "duration_hours" | "damage_t" | "createdAt" | "updatedAt", ExtArgs["result"]["fireRecord"]>
  export type FireRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }
  export type FireRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }
  export type FireRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | FireRecord$shtabelArgs<ExtArgs>
  }

  export type $FireRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FireRecord"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      shtabel: Prisma.$ShtabelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      skladId: number
      shtabelId: number | null
      reportDate: Date
      mark: string | null
      weight_t: number | null
      startDate: Date
      endDate: Date | null
      formedAt: Date | null
      duration_hours: number | null
      damage_t: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fireRecord"]>
    composites: {}
  }

  type FireRecordGetPayload<S extends boolean | null | undefined | FireRecordDefaultArgs> = $Result.GetResult<Prisma.$FireRecordPayload, S>

  type FireRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FireRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FireRecordCountAggregateInputType | true
    }

  export interface FireRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FireRecord'], meta: { name: 'FireRecord' } }
    /**
     * Find zero or one FireRecord that matches the filter.
     * @param {FireRecordFindUniqueArgs} args - Arguments to find a FireRecord
     * @example
     * // Get one FireRecord
     * const fireRecord = await prisma.fireRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FireRecordFindUniqueArgs>(args: SelectSubset<T, FireRecordFindUniqueArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FireRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FireRecordFindUniqueOrThrowArgs} args - Arguments to find a FireRecord
     * @example
     * // Get one FireRecord
     * const fireRecord = await prisma.fireRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FireRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, FireRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FireRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordFindFirstArgs} args - Arguments to find a FireRecord
     * @example
     * // Get one FireRecord
     * const fireRecord = await prisma.fireRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FireRecordFindFirstArgs>(args?: SelectSubset<T, FireRecordFindFirstArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FireRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordFindFirstOrThrowArgs} args - Arguments to find a FireRecord
     * @example
     * // Get one FireRecord
     * const fireRecord = await prisma.fireRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FireRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, FireRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FireRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FireRecords
     * const fireRecords = await prisma.fireRecord.findMany()
     * 
     * // Get first 10 FireRecords
     * const fireRecords = await prisma.fireRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fireRecordWithIdOnly = await prisma.fireRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FireRecordFindManyArgs>(args?: SelectSubset<T, FireRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FireRecord.
     * @param {FireRecordCreateArgs} args - Arguments to create a FireRecord.
     * @example
     * // Create one FireRecord
     * const FireRecord = await prisma.fireRecord.create({
     *   data: {
     *     // ... data to create a FireRecord
     *   }
     * })
     * 
     */
    create<T extends FireRecordCreateArgs>(args: SelectSubset<T, FireRecordCreateArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FireRecords.
     * @param {FireRecordCreateManyArgs} args - Arguments to create many FireRecords.
     * @example
     * // Create many FireRecords
     * const fireRecord = await prisma.fireRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FireRecordCreateManyArgs>(args?: SelectSubset<T, FireRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FireRecords and returns the data saved in the database.
     * @param {FireRecordCreateManyAndReturnArgs} args - Arguments to create many FireRecords.
     * @example
     * // Create many FireRecords
     * const fireRecord = await prisma.fireRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FireRecords and only return the `id`
     * const fireRecordWithIdOnly = await prisma.fireRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FireRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, FireRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FireRecord.
     * @param {FireRecordDeleteArgs} args - Arguments to delete one FireRecord.
     * @example
     * // Delete one FireRecord
     * const FireRecord = await prisma.fireRecord.delete({
     *   where: {
     *     // ... filter to delete one FireRecord
     *   }
     * })
     * 
     */
    delete<T extends FireRecordDeleteArgs>(args: SelectSubset<T, FireRecordDeleteArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FireRecord.
     * @param {FireRecordUpdateArgs} args - Arguments to update one FireRecord.
     * @example
     * // Update one FireRecord
     * const fireRecord = await prisma.fireRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FireRecordUpdateArgs>(args: SelectSubset<T, FireRecordUpdateArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FireRecords.
     * @param {FireRecordDeleteManyArgs} args - Arguments to filter FireRecords to delete.
     * @example
     * // Delete a few FireRecords
     * const { count } = await prisma.fireRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FireRecordDeleteManyArgs>(args?: SelectSubset<T, FireRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FireRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FireRecords
     * const fireRecord = await prisma.fireRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FireRecordUpdateManyArgs>(args: SelectSubset<T, FireRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FireRecords and returns the data updated in the database.
     * @param {FireRecordUpdateManyAndReturnArgs} args - Arguments to update many FireRecords.
     * @example
     * // Update many FireRecords
     * const fireRecord = await prisma.fireRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FireRecords and only return the `id`
     * const fireRecordWithIdOnly = await prisma.fireRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FireRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, FireRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FireRecord.
     * @param {FireRecordUpsertArgs} args - Arguments to update or create a FireRecord.
     * @example
     * // Update or create a FireRecord
     * const fireRecord = await prisma.fireRecord.upsert({
     *   create: {
     *     // ... data to create a FireRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FireRecord we want to update
     *   }
     * })
     */
    upsert<T extends FireRecordUpsertArgs>(args: SelectSubset<T, FireRecordUpsertArgs<ExtArgs>>): Prisma__FireRecordClient<$Result.GetResult<Prisma.$FireRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FireRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordCountArgs} args - Arguments to filter FireRecords to count.
     * @example
     * // Count the number of FireRecords
     * const count = await prisma.fireRecord.count({
     *   where: {
     *     // ... the filter for the FireRecords we want to count
     *   }
     * })
    **/
    count<T extends FireRecordCountArgs>(
      args?: Subset<T, FireRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FireRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FireRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FireRecordAggregateArgs>(args: Subset<T, FireRecordAggregateArgs>): Prisma.PrismaPromise<GetFireRecordAggregateType<T>>

    /**
     * Group by FireRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FireRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FireRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FireRecordGroupByArgs['orderBy'] }
        : { orderBy?: FireRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FireRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFireRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FireRecord model
   */
  readonly fields: FireRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FireRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FireRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shtabel<T extends FireRecord$shtabelArgs<ExtArgs> = {}>(args?: Subset<T, FireRecord$shtabelArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FireRecord model
   */
  interface FireRecordFieldRefs {
    readonly id: FieldRef<"FireRecord", 'Int'>
    readonly skladId: FieldRef<"FireRecord", 'Int'>
    readonly shtabelId: FieldRef<"FireRecord", 'Int'>
    readonly reportDate: FieldRef<"FireRecord", 'DateTime'>
    readonly mark: FieldRef<"FireRecord", 'String'>
    readonly weight_t: FieldRef<"FireRecord", 'Float'>
    readonly startDate: FieldRef<"FireRecord", 'DateTime'>
    readonly endDate: FieldRef<"FireRecord", 'DateTime'>
    readonly formedAt: FieldRef<"FireRecord", 'DateTime'>
    readonly duration_hours: FieldRef<"FireRecord", 'Float'>
    readonly damage_t: FieldRef<"FireRecord", 'Float'>
    readonly createdAt: FieldRef<"FireRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"FireRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FireRecord findUnique
   */
  export type FireRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter, which FireRecord to fetch.
     */
    where: FireRecordWhereUniqueInput
  }

  /**
   * FireRecord findUniqueOrThrow
   */
  export type FireRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter, which FireRecord to fetch.
     */
    where: FireRecordWhereUniqueInput
  }

  /**
   * FireRecord findFirst
   */
  export type FireRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter, which FireRecord to fetch.
     */
    where?: FireRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FireRecords to fetch.
     */
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FireRecords.
     */
    cursor?: FireRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FireRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FireRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FireRecords.
     */
    distinct?: FireRecordScalarFieldEnum | FireRecordScalarFieldEnum[]
  }

  /**
   * FireRecord findFirstOrThrow
   */
  export type FireRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter, which FireRecord to fetch.
     */
    where?: FireRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FireRecords to fetch.
     */
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FireRecords.
     */
    cursor?: FireRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FireRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FireRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FireRecords.
     */
    distinct?: FireRecordScalarFieldEnum | FireRecordScalarFieldEnum[]
  }

  /**
   * FireRecord findMany
   */
  export type FireRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter, which FireRecords to fetch.
     */
    where?: FireRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FireRecords to fetch.
     */
    orderBy?: FireRecordOrderByWithRelationInput | FireRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FireRecords.
     */
    cursor?: FireRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FireRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FireRecords.
     */
    skip?: number
    distinct?: FireRecordScalarFieldEnum | FireRecordScalarFieldEnum[]
  }

  /**
   * FireRecord create
   */
  export type FireRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a FireRecord.
     */
    data: XOR<FireRecordCreateInput, FireRecordUncheckedCreateInput>
  }

  /**
   * FireRecord createMany
   */
  export type FireRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FireRecords.
     */
    data: FireRecordCreateManyInput | FireRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FireRecord createManyAndReturn
   */
  export type FireRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * The data used to create many FireRecords.
     */
    data: FireRecordCreateManyInput | FireRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FireRecord update
   */
  export type FireRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a FireRecord.
     */
    data: XOR<FireRecordUpdateInput, FireRecordUncheckedUpdateInput>
    /**
     * Choose, which FireRecord to update.
     */
    where: FireRecordWhereUniqueInput
  }

  /**
   * FireRecord updateMany
   */
  export type FireRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FireRecords.
     */
    data: XOR<FireRecordUpdateManyMutationInput, FireRecordUncheckedUpdateManyInput>
    /**
     * Filter which FireRecords to update
     */
    where?: FireRecordWhereInput
    /**
     * Limit how many FireRecords to update.
     */
    limit?: number
  }

  /**
   * FireRecord updateManyAndReturn
   */
  export type FireRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * The data used to update FireRecords.
     */
    data: XOR<FireRecordUpdateManyMutationInput, FireRecordUncheckedUpdateManyInput>
    /**
     * Filter which FireRecords to update
     */
    where?: FireRecordWhereInput
    /**
     * Limit how many FireRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FireRecord upsert
   */
  export type FireRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the FireRecord to update in case it exists.
     */
    where: FireRecordWhereUniqueInput
    /**
     * In case the FireRecord found by the `where` argument doesn't exist, create a new FireRecord with this data.
     */
    create: XOR<FireRecordCreateInput, FireRecordUncheckedCreateInput>
    /**
     * In case the FireRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FireRecordUpdateInput, FireRecordUncheckedUpdateInput>
  }

  /**
   * FireRecord delete
   */
  export type FireRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
    /**
     * Filter which FireRecord to delete.
     */
    where: FireRecordWhereUniqueInput
  }

  /**
   * FireRecord deleteMany
   */
  export type FireRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FireRecords to delete
     */
    where?: FireRecordWhereInput
    /**
     * Limit how many FireRecords to delete.
     */
    limit?: number
  }

  /**
   * FireRecord.shtabel
   */
  export type FireRecord$shtabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shtabel
     */
    select?: ShtabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shtabel
     */
    omit?: ShtabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShtabelInclude<ExtArgs> | null
    where?: ShtabelWhereInput
  }

  /**
   * FireRecord without action
   */
  export type FireRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FireRecord
     */
    select?: FireRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FireRecord
     */
    omit?: FireRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FireRecordInclude<ExtArgs> | null
  }


  /**
   * Model TempRecord
   */

  export type AggregateTempRecord = {
    _count: TempRecordCountAggregateOutputType | null
    _avg: TempRecordAvgAggregateOutputType | null
    _sum: TempRecordSumAggregateOutputType | null
    _min: TempRecordMinAggregateOutputType | null
    _max: TempRecordMaxAggregateOutputType | null
  }

  export type TempRecordAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    maxTemp: number | null
    shift: number | null
  }

  export type TempRecordSumAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    maxTemp: number | null
    shift: number | null
  }

  export type TempRecordMinAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    mark: string | null
    maxTemp: number | null
    piket: string | null
    recordDate: Date | null
    shift: number | null
    riskLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TempRecordMaxAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    mark: string | null
    maxTemp: number | null
    piket: string | null
    recordDate: Date | null
    shift: number | null
    riskLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TempRecordCountAggregateOutputType = {
    id: number
    skladId: number
    shtabelId: number
    mark: number
    maxTemp: number
    piket: number
    recordDate: number
    shift: number
    riskLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TempRecordAvgAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    maxTemp?: true
    shift?: true
  }

  export type TempRecordSumAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    maxTemp?: true
    shift?: true
  }

  export type TempRecordMinAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    mark?: true
    maxTemp?: true
    piket?: true
    recordDate?: true
    shift?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TempRecordMaxAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    mark?: true
    maxTemp?: true
    piket?: true
    recordDate?: true
    shift?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TempRecordCountAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    mark?: true
    maxTemp?: true
    piket?: true
    recordDate?: true
    shift?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TempRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempRecord to aggregate.
     */
    where?: TempRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempRecords to fetch.
     */
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TempRecords
    **/
    _count?: true | TempRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TempRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TempRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempRecordMaxAggregateInputType
  }

  export type GetTempRecordAggregateType<T extends TempRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTempRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempRecord[P]>
      : GetScalarType<T[P], AggregateTempRecord[P]>
  }




  export type TempRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempRecordWhereInput
    orderBy?: TempRecordOrderByWithAggregationInput | TempRecordOrderByWithAggregationInput[]
    by: TempRecordScalarFieldEnum[] | TempRecordScalarFieldEnum
    having?: TempRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempRecordCountAggregateInputType | true
    _avg?: TempRecordAvgAggregateInputType
    _sum?: TempRecordSumAggregateInputType
    _min?: TempRecordMinAggregateInputType
    _max?: TempRecordMaxAggregateInputType
  }

  export type TempRecordGroupByOutputType = {
    id: number
    skladId: number
    shtabelId: number
    mark: string | null
    maxTemp: number
    piket: string | null
    recordDate: Date
    shift: number | null
    riskLevel: string | null
    createdAt: Date
    updatedAt: Date
    _count: TempRecordCountAggregateOutputType | null
    _avg: TempRecordAvgAggregateOutputType | null
    _sum: TempRecordSumAggregateOutputType | null
    _min: TempRecordMinAggregateOutputType | null
    _max: TempRecordMaxAggregateOutputType | null
  }

  type GetTempRecordGroupByPayload<T extends TempRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TempRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TempRecordGroupByOutputType[P]>
        }
      >
    >


  export type TempRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    mark?: boolean
    maxTemp?: boolean
    piket?: boolean
    recordDate?: boolean
    shift?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tempRecord"]>

  export type TempRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    mark?: boolean
    maxTemp?: boolean
    piket?: boolean
    recordDate?: boolean
    shift?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tempRecord"]>

  export type TempRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    mark?: boolean
    maxTemp?: boolean
    piket?: boolean
    recordDate?: boolean
    shift?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tempRecord"]>

  export type TempRecordSelectScalar = {
    id?: boolean
    skladId?: boolean
    shtabelId?: boolean
    mark?: boolean
    maxTemp?: boolean
    piket?: boolean
    recordDate?: boolean
    shift?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TempRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skladId" | "shtabelId" | "mark" | "maxTemp" | "piket" | "recordDate" | "shift" | "riskLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["tempRecord"]>
  export type TempRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type TempRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type TempRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }

  export type $TempRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TempRecord"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      shtabel: Prisma.$ShtabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      skladId: number
      shtabelId: number
      mark: string | null
      maxTemp: number
      piket: string | null
      recordDate: Date
      shift: number | null
      riskLevel: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tempRecord"]>
    composites: {}
  }

  type TempRecordGetPayload<S extends boolean | null | undefined | TempRecordDefaultArgs> = $Result.GetResult<Prisma.$TempRecordPayload, S>

  type TempRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TempRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TempRecordCountAggregateInputType | true
    }

  export interface TempRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TempRecord'], meta: { name: 'TempRecord' } }
    /**
     * Find zero or one TempRecord that matches the filter.
     * @param {TempRecordFindUniqueArgs} args - Arguments to find a TempRecord
     * @example
     * // Get one TempRecord
     * const tempRecord = await prisma.tempRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TempRecordFindUniqueArgs>(args: SelectSubset<T, TempRecordFindUniqueArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TempRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TempRecordFindUniqueOrThrowArgs} args - Arguments to find a TempRecord
     * @example
     * // Get one TempRecord
     * const tempRecord = await prisma.tempRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TempRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TempRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordFindFirstArgs} args - Arguments to find a TempRecord
     * @example
     * // Get one TempRecord
     * const tempRecord = await prisma.tempRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TempRecordFindFirstArgs>(args?: SelectSubset<T, TempRecordFindFirstArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordFindFirstOrThrowArgs} args - Arguments to find a TempRecord
     * @example
     * // Get one TempRecord
     * const tempRecord = await prisma.tempRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TempRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TempRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TempRecords
     * const tempRecords = await prisma.tempRecord.findMany()
     * 
     * // Get first 10 TempRecords
     * const tempRecords = await prisma.tempRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tempRecordWithIdOnly = await prisma.tempRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TempRecordFindManyArgs>(args?: SelectSubset<T, TempRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TempRecord.
     * @param {TempRecordCreateArgs} args - Arguments to create a TempRecord.
     * @example
     * // Create one TempRecord
     * const TempRecord = await prisma.tempRecord.create({
     *   data: {
     *     // ... data to create a TempRecord
     *   }
     * })
     * 
     */
    create<T extends TempRecordCreateArgs>(args: SelectSubset<T, TempRecordCreateArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TempRecords.
     * @param {TempRecordCreateManyArgs} args - Arguments to create many TempRecords.
     * @example
     * // Create many TempRecords
     * const tempRecord = await prisma.tempRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TempRecordCreateManyArgs>(args?: SelectSubset<T, TempRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TempRecords and returns the data saved in the database.
     * @param {TempRecordCreateManyAndReturnArgs} args - Arguments to create many TempRecords.
     * @example
     * // Create many TempRecords
     * const tempRecord = await prisma.tempRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TempRecords and only return the `id`
     * const tempRecordWithIdOnly = await prisma.tempRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TempRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TempRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TempRecord.
     * @param {TempRecordDeleteArgs} args - Arguments to delete one TempRecord.
     * @example
     * // Delete one TempRecord
     * const TempRecord = await prisma.tempRecord.delete({
     *   where: {
     *     // ... filter to delete one TempRecord
     *   }
     * })
     * 
     */
    delete<T extends TempRecordDeleteArgs>(args: SelectSubset<T, TempRecordDeleteArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TempRecord.
     * @param {TempRecordUpdateArgs} args - Arguments to update one TempRecord.
     * @example
     * // Update one TempRecord
     * const tempRecord = await prisma.tempRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TempRecordUpdateArgs>(args: SelectSubset<T, TempRecordUpdateArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TempRecords.
     * @param {TempRecordDeleteManyArgs} args - Arguments to filter TempRecords to delete.
     * @example
     * // Delete a few TempRecords
     * const { count } = await prisma.tempRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TempRecordDeleteManyArgs>(args?: SelectSubset<T, TempRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TempRecords
     * const tempRecord = await prisma.tempRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TempRecordUpdateManyArgs>(args: SelectSubset<T, TempRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempRecords and returns the data updated in the database.
     * @param {TempRecordUpdateManyAndReturnArgs} args - Arguments to update many TempRecords.
     * @example
     * // Update many TempRecords
     * const tempRecord = await prisma.tempRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TempRecords and only return the `id`
     * const tempRecordWithIdOnly = await prisma.tempRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TempRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TempRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TempRecord.
     * @param {TempRecordUpsertArgs} args - Arguments to update or create a TempRecord.
     * @example
     * // Update or create a TempRecord
     * const tempRecord = await prisma.tempRecord.upsert({
     *   create: {
     *     // ... data to create a TempRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TempRecord we want to update
     *   }
     * })
     */
    upsert<T extends TempRecordUpsertArgs>(args: SelectSubset<T, TempRecordUpsertArgs<ExtArgs>>): Prisma__TempRecordClient<$Result.GetResult<Prisma.$TempRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TempRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordCountArgs} args - Arguments to filter TempRecords to count.
     * @example
     * // Count the number of TempRecords
     * const count = await prisma.tempRecord.count({
     *   where: {
     *     // ... the filter for the TempRecords we want to count
     *   }
     * })
    **/
    count<T extends TempRecordCountArgs>(
      args?: Subset<T, TempRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TempRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempRecordAggregateArgs>(args: Subset<T, TempRecordAggregateArgs>): Prisma.PrismaPromise<GetTempRecordAggregateType<T>>

    /**
     * Group by TempRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempRecordGroupByArgs['orderBy'] }
        : { orderBy?: TempRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TempRecord model
   */
  readonly fields: TempRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TempRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TempRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shtabel<T extends ShtabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShtabelDefaultArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TempRecord model
   */
  interface TempRecordFieldRefs {
    readonly id: FieldRef<"TempRecord", 'Int'>
    readonly skladId: FieldRef<"TempRecord", 'Int'>
    readonly shtabelId: FieldRef<"TempRecord", 'Int'>
    readonly mark: FieldRef<"TempRecord", 'String'>
    readonly maxTemp: FieldRef<"TempRecord", 'Float'>
    readonly piket: FieldRef<"TempRecord", 'String'>
    readonly recordDate: FieldRef<"TempRecord", 'DateTime'>
    readonly shift: FieldRef<"TempRecord", 'Float'>
    readonly riskLevel: FieldRef<"TempRecord", 'String'>
    readonly createdAt: FieldRef<"TempRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TempRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TempRecord findUnique
   */
  export type TempRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter, which TempRecord to fetch.
     */
    where: TempRecordWhereUniqueInput
  }

  /**
   * TempRecord findUniqueOrThrow
   */
  export type TempRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter, which TempRecord to fetch.
     */
    where: TempRecordWhereUniqueInput
  }

  /**
   * TempRecord findFirst
   */
  export type TempRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter, which TempRecord to fetch.
     */
    where?: TempRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempRecords to fetch.
     */
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempRecords.
     */
    cursor?: TempRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempRecords.
     */
    distinct?: TempRecordScalarFieldEnum | TempRecordScalarFieldEnum[]
  }

  /**
   * TempRecord findFirstOrThrow
   */
  export type TempRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter, which TempRecord to fetch.
     */
    where?: TempRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempRecords to fetch.
     */
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempRecords.
     */
    cursor?: TempRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempRecords.
     */
    distinct?: TempRecordScalarFieldEnum | TempRecordScalarFieldEnum[]
  }

  /**
   * TempRecord findMany
   */
  export type TempRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter, which TempRecords to fetch.
     */
    where?: TempRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempRecords to fetch.
     */
    orderBy?: TempRecordOrderByWithRelationInput | TempRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TempRecords.
     */
    cursor?: TempRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempRecords.
     */
    skip?: number
    distinct?: TempRecordScalarFieldEnum | TempRecordScalarFieldEnum[]
  }

  /**
   * TempRecord create
   */
  export type TempRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TempRecord.
     */
    data: XOR<TempRecordCreateInput, TempRecordUncheckedCreateInput>
  }

  /**
   * TempRecord createMany
   */
  export type TempRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TempRecords.
     */
    data: TempRecordCreateManyInput | TempRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TempRecord createManyAndReturn
   */
  export type TempRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TempRecords.
     */
    data: TempRecordCreateManyInput | TempRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TempRecord update
   */
  export type TempRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TempRecord.
     */
    data: XOR<TempRecordUpdateInput, TempRecordUncheckedUpdateInput>
    /**
     * Choose, which TempRecord to update.
     */
    where: TempRecordWhereUniqueInput
  }

  /**
   * TempRecord updateMany
   */
  export type TempRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TempRecords.
     */
    data: XOR<TempRecordUpdateManyMutationInput, TempRecordUncheckedUpdateManyInput>
    /**
     * Filter which TempRecords to update
     */
    where?: TempRecordWhereInput
    /**
     * Limit how many TempRecords to update.
     */
    limit?: number
  }

  /**
   * TempRecord updateManyAndReturn
   */
  export type TempRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * The data used to update TempRecords.
     */
    data: XOR<TempRecordUpdateManyMutationInput, TempRecordUncheckedUpdateManyInput>
    /**
     * Filter which TempRecords to update
     */
    where?: TempRecordWhereInput
    /**
     * Limit how many TempRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TempRecord upsert
   */
  export type TempRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TempRecord to update in case it exists.
     */
    where: TempRecordWhereUniqueInput
    /**
     * In case the TempRecord found by the `where` argument doesn't exist, create a new TempRecord with this data.
     */
    create: XOR<TempRecordCreateInput, TempRecordUncheckedCreateInput>
    /**
     * In case the TempRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempRecordUpdateInput, TempRecordUncheckedUpdateInput>
  }

  /**
   * TempRecord delete
   */
  export type TempRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
    /**
     * Filter which TempRecord to delete.
     */
    where: TempRecordWhereUniqueInput
  }

  /**
   * TempRecord deleteMany
   */
  export type TempRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempRecords to delete
     */
    where?: TempRecordWhereInput
    /**
     * Limit how many TempRecords to delete.
     */
    limit?: number
  }

  /**
   * TempRecord without action
   */
  export type TempRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempRecord
     */
    select?: TempRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempRecord
     */
    omit?: TempRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempRecordInclude<ExtArgs> | null
  }


  /**
   * Model Weather
   */

  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    id: number | null
    t: number | null
    p: number | null
    humidity: number | null
    precipitation: number | null
    wind_dir: number | null
    v_avg: number | null
    v_max: number | null
    cloudcover: number | null
    visibility: number | null
    weather_code: number | null
  }

  export type WeatherSumAggregateOutputType = {
    id: number | null
    t: number | null
    p: number | null
    humidity: number | null
    precipitation: number | null
    wind_dir: number | null
    v_avg: number | null
    v_max: number | null
    cloudcover: number | null
    visibility: number | null
    weather_code: number | null
  }

  export type WeatherMinAggregateOutputType = {
    id: number | null
    ts: Date | null
    t: number | null
    p: number | null
    humidity: number | null
    precipitation: number | null
    wind_dir: number | null
    v_avg: number | null
    v_max: number | null
    cloudcover: number | null
    visibility: number | null
    weather_code: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherMaxAggregateOutputType = {
    id: number | null
    ts: Date | null
    t: number | null
    p: number | null
    humidity: number | null
    precipitation: number | null
    wind_dir: number | null
    v_avg: number | null
    v_max: number | null
    cloudcover: number | null
    visibility: number | null
    weather_code: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherCountAggregateOutputType = {
    id: number
    ts: number
    t: number
    p: number
    humidity: number
    precipitation: number
    wind_dir: number
    v_avg: number
    v_max: number
    cloudcover: number
    visibility: number
    weather_code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    id?: true
    t?: true
    p?: true
    humidity?: true
    precipitation?: true
    wind_dir?: true
    v_avg?: true
    v_max?: true
    cloudcover?: true
    visibility?: true
    weather_code?: true
  }

  export type WeatherSumAggregateInputType = {
    id?: true
    t?: true
    p?: true
    humidity?: true
    precipitation?: true
    wind_dir?: true
    v_avg?: true
    v_max?: true
    cloudcover?: true
    visibility?: true
    weather_code?: true
  }

  export type WeatherMinAggregateInputType = {
    id?: true
    ts?: true
    t?: true
    p?: true
    humidity?: true
    precipitation?: true
    wind_dir?: true
    v_avg?: true
    v_max?: true
    cloudcover?: true
    visibility?: true
    weather_code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherMaxAggregateInputType = {
    id?: true
    ts?: true
    t?: true
    p?: true
    humidity?: true
    precipitation?: true
    wind_dir?: true
    v_avg?: true
    v_max?: true
    cloudcover?: true
    visibility?: true
    weather_code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherCountAggregateInputType = {
    id?: true
    ts?: true
    t?: true
    p?: true
    humidity?: true
    precipitation?: true
    wind_dir?: true
    v_avg?: true
    v_max?: true
    cloudcover?: true
    visibility?: true
    weather_code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weather to aggregate.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }




  export type WeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithAggregationInput | WeatherOrderByWithAggregationInput[]
    by: WeatherScalarFieldEnum[] | WeatherScalarFieldEnum
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }

  export type WeatherGroupByOutputType = {
    id: number
    ts: Date
    t: number | null
    p: number | null
    humidity: number | null
    precipitation: number | null
    wind_dir: number | null
    v_avg: number | null
    v_max: number | null
    cloudcover: number | null
    visibility: number | null
    weather_code: number | null
    createdAt: Date
    updatedAt: Date
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      >
    >


  export type WeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    t?: boolean
    p?: boolean
    humidity?: boolean
    precipitation?: boolean
    wind_dir?: boolean
    v_avg?: boolean
    v_max?: boolean
    cloudcover?: boolean
    visibility?: boolean
    weather_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    t?: boolean
    p?: boolean
    humidity?: boolean
    precipitation?: boolean
    wind_dir?: boolean
    v_avg?: boolean
    v_max?: boolean
    cloudcover?: boolean
    visibility?: boolean
    weather_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    t?: boolean
    p?: boolean
    humidity?: boolean
    precipitation?: boolean
    wind_dir?: boolean
    v_avg?: boolean
    v_max?: boolean
    cloudcover?: boolean
    visibility?: boolean
    weather_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectScalar = {
    id?: boolean
    ts?: boolean
    t?: boolean
    p?: boolean
    humidity?: boolean
    precipitation?: boolean
    wind_dir?: boolean
    v_avg?: boolean
    v_max?: boolean
    cloudcover?: boolean
    visibility?: boolean
    weather_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "t" | "p" | "humidity" | "precipitation" | "wind_dir" | "v_avg" | "v_max" | "cloudcover" | "visibility" | "weather_code" | "createdAt" | "updatedAt", ExtArgs["result"]["weather"]>

  export type $WeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weather"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ts: Date
      t: number | null
      p: number | null
      humidity: number | null
      precipitation: number | null
      wind_dir: number | null
      v_avg: number | null
      v_max: number | null
      cloudcover: number | null
      visibility: number | null
      weather_code: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weather"]>
    composites: {}
  }

  type WeatherGetPayload<S extends boolean | null | undefined | WeatherDefaultArgs> = $Result.GetResult<Prisma.$WeatherPayload, S>

  type WeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherCountAggregateInputType | true
    }

  export interface WeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weather'], meta: { name: 'Weather' } }
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherFindUniqueArgs>(args: SelectSubset<T, WeatherFindUniqueArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherFindUniqueOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherFindFirstArgs>(args?: SelectSubset<T, WeatherFindFirstArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherFindManyArgs>(args?: SelectSubset<T, WeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
     */
    create<T extends WeatherCreateArgs>(args: SelectSubset<T, WeatherCreateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weathers.
     * @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherCreateManyArgs>(args?: SelectSubset<T, WeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weathers and returns the data saved in the database.
     * @param {WeatherCreateManyAndReturnArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
     */
    delete<T extends WeatherDeleteArgs>(args: SelectSubset<T, WeatherDeleteArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherUpdateArgs>(args: SelectSubset<T, WeatherUpdateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDeleteManyArgs>(args?: SelectSubset<T, WeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherUpdateManyArgs>(args: SelectSubset<T, WeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers and returns the data updated in the database.
     * @param {WeatherUpdateManyAndReturnArgs} args - Arguments to update many Weathers.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
     */
    upsert<T extends WeatherUpsertArgs>(args: SelectSubset<T, WeatherUpsertArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weather model
   */
  readonly fields: WeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weather model
   */
  interface WeatherFieldRefs {
    readonly id: FieldRef<"Weather", 'Int'>
    readonly ts: FieldRef<"Weather", 'DateTime'>
    readonly t: FieldRef<"Weather", 'Float'>
    readonly p: FieldRef<"Weather", 'Float'>
    readonly humidity: FieldRef<"Weather", 'Float'>
    readonly precipitation: FieldRef<"Weather", 'Float'>
    readonly wind_dir: FieldRef<"Weather", 'Int'>
    readonly v_avg: FieldRef<"Weather", 'Float'>
    readonly v_max: FieldRef<"Weather", 'Float'>
    readonly cloudcover: FieldRef<"Weather", 'Float'>
    readonly visibility: FieldRef<"Weather", 'Float'>
    readonly weather_code: FieldRef<"Weather", 'Int'>
    readonly createdAt: FieldRef<"Weather", 'DateTime'>
    readonly updatedAt: FieldRef<"Weather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findUniqueOrThrow
   */
  export type WeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findFirstOrThrow
   */
  export type WeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weathers to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather create
   */
  export type WeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data needed to create a Weather.
     */
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }

  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weather createManyAndReturn
   */
  export type WeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weather update
   */
  export type WeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data needed to update a Weather.
     */
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather updateManyAndReturn
   */
  export type WeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The filter to search for the Weather to update in case it exists.
     */
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     */
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }

  /**
   * Weather delete
   */
  export type WeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter which Weather to delete.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weathers to delete
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to delete.
     */
    limit?: number
  }

  /**
   * Weather without action
   */
  export type WeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
  }


  /**
   * Model FeatureVector
   */

  export type AggregateFeatureVector = {
    _count: FeatureVectorCountAggregateOutputType | null
    _avg: FeatureVectorAvgAggregateOutputType | null
    _sum: FeatureVectorSumAggregateOutputType | null
    _min: FeatureVectorMinAggregateOutputType | null
    _max: FeatureVectorMaxAggregateOutputType | null
  }

  export type FeatureVectorAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
  }

  export type FeatureVectorSumAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
  }

  export type FeatureVectorMinAggregateOutputType = {
    id: number | null
    ts: Date | null
    skladId: number | null
    shtabelId: number | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type FeatureVectorMaxAggregateOutputType = {
    id: number | null
    ts: Date | null
    skladId: number | null
    shtabelId: number | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type FeatureVectorCountAggregateOutputType = {
    id: number
    ts: number
    skladId: number
    shtabelId: number
    features: number
    modelVersion: number
    createdAt: number
    _all: number
  }


  export type FeatureVectorAvgAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
  }

  export type FeatureVectorSumAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
  }

  export type FeatureVectorMinAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    modelVersion?: true
    createdAt?: true
  }

  export type FeatureVectorMaxAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    modelVersion?: true
    createdAt?: true
  }

  export type FeatureVectorCountAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    features?: true
    modelVersion?: true
    createdAt?: true
    _all?: true
  }

  export type FeatureVectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureVector to aggregate.
     */
    where?: FeatureVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureVectors to fetch.
     */
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureVectors
    **/
    _count?: true | FeatureVectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureVectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureVectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureVectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureVectorMaxAggregateInputType
  }

  export type GetFeatureVectorAggregateType<T extends FeatureVectorAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureVector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureVector[P]>
      : GetScalarType<T[P], AggregateFeatureVector[P]>
  }




  export type FeatureVectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureVectorWhereInput
    orderBy?: FeatureVectorOrderByWithAggregationInput | FeatureVectorOrderByWithAggregationInput[]
    by: FeatureVectorScalarFieldEnum[] | FeatureVectorScalarFieldEnum
    having?: FeatureVectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureVectorCountAggregateInputType | true
    _avg?: FeatureVectorAvgAggregateInputType
    _sum?: FeatureVectorSumAggregateInputType
    _min?: FeatureVectorMinAggregateInputType
    _max?: FeatureVectorMaxAggregateInputType
  }

  export type FeatureVectorGroupByOutputType = {
    id: number
    ts: Date
    skladId: number
    shtabelId: number
    features: JsonValue
    modelVersion: string | null
    createdAt: Date
    _count: FeatureVectorCountAggregateOutputType | null
    _avg: FeatureVectorAvgAggregateOutputType | null
    _sum: FeatureVectorSumAggregateOutputType | null
    _min: FeatureVectorMinAggregateOutputType | null
    _max: FeatureVectorMaxAggregateOutputType | null
  }

  type GetFeatureVectorGroupByPayload<T extends FeatureVectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureVectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureVectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureVectorGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureVectorGroupByOutputType[P]>
        }
      >
    >


  export type FeatureVectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    features?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureVector"]>

  export type FeatureVectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    features?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureVector"]>

  export type FeatureVectorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    features?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureVector"]>

  export type FeatureVectorSelectScalar = {
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    features?: boolean
    modelVersion?: boolean
    createdAt?: boolean
  }

  export type FeatureVectorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "skladId" | "shtabelId" | "features" | "modelVersion" | "createdAt", ExtArgs["result"]["featureVector"]>
  export type FeatureVectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type FeatureVectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type FeatureVectorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }

  export type $FeatureVectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureVector"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      shtabel: Prisma.$ShtabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ts: Date
      skladId: number
      shtabelId: number
      features: Prisma.JsonValue
      modelVersion: string | null
      createdAt: Date
    }, ExtArgs["result"]["featureVector"]>
    composites: {}
  }

  type FeatureVectorGetPayload<S extends boolean | null | undefined | FeatureVectorDefaultArgs> = $Result.GetResult<Prisma.$FeatureVectorPayload, S>

  type FeatureVectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureVectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureVectorCountAggregateInputType | true
    }

  export interface FeatureVectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureVector'], meta: { name: 'FeatureVector' } }
    /**
     * Find zero or one FeatureVector that matches the filter.
     * @param {FeatureVectorFindUniqueArgs} args - Arguments to find a FeatureVector
     * @example
     * // Get one FeatureVector
     * const featureVector = await prisma.featureVector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureVectorFindUniqueArgs>(args: SelectSubset<T, FeatureVectorFindUniqueArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureVector that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureVectorFindUniqueOrThrowArgs} args - Arguments to find a FeatureVector
     * @example
     * // Get one FeatureVector
     * const featureVector = await prisma.featureVector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureVectorFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureVectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureVector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorFindFirstArgs} args - Arguments to find a FeatureVector
     * @example
     * // Get one FeatureVector
     * const featureVector = await prisma.featureVector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureVectorFindFirstArgs>(args?: SelectSubset<T, FeatureVectorFindFirstArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureVector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorFindFirstOrThrowArgs} args - Arguments to find a FeatureVector
     * @example
     * // Get one FeatureVector
     * const featureVector = await prisma.featureVector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureVectorFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureVectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureVectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureVectors
     * const featureVectors = await prisma.featureVector.findMany()
     * 
     * // Get first 10 FeatureVectors
     * const featureVectors = await prisma.featureVector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureVectorWithIdOnly = await prisma.featureVector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureVectorFindManyArgs>(args?: SelectSubset<T, FeatureVectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureVector.
     * @param {FeatureVectorCreateArgs} args - Arguments to create a FeatureVector.
     * @example
     * // Create one FeatureVector
     * const FeatureVector = await prisma.featureVector.create({
     *   data: {
     *     // ... data to create a FeatureVector
     *   }
     * })
     * 
     */
    create<T extends FeatureVectorCreateArgs>(args: SelectSubset<T, FeatureVectorCreateArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureVectors.
     * @param {FeatureVectorCreateManyArgs} args - Arguments to create many FeatureVectors.
     * @example
     * // Create many FeatureVectors
     * const featureVector = await prisma.featureVector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureVectorCreateManyArgs>(args?: SelectSubset<T, FeatureVectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureVectors and returns the data saved in the database.
     * @param {FeatureVectorCreateManyAndReturnArgs} args - Arguments to create many FeatureVectors.
     * @example
     * // Create many FeatureVectors
     * const featureVector = await prisma.featureVector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureVectors and only return the `id`
     * const featureVectorWithIdOnly = await prisma.featureVector.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureVectorCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureVectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureVector.
     * @param {FeatureVectorDeleteArgs} args - Arguments to delete one FeatureVector.
     * @example
     * // Delete one FeatureVector
     * const FeatureVector = await prisma.featureVector.delete({
     *   where: {
     *     // ... filter to delete one FeatureVector
     *   }
     * })
     * 
     */
    delete<T extends FeatureVectorDeleteArgs>(args: SelectSubset<T, FeatureVectorDeleteArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureVector.
     * @param {FeatureVectorUpdateArgs} args - Arguments to update one FeatureVector.
     * @example
     * // Update one FeatureVector
     * const featureVector = await prisma.featureVector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureVectorUpdateArgs>(args: SelectSubset<T, FeatureVectorUpdateArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureVectors.
     * @param {FeatureVectorDeleteManyArgs} args - Arguments to filter FeatureVectors to delete.
     * @example
     * // Delete a few FeatureVectors
     * const { count } = await prisma.featureVector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureVectorDeleteManyArgs>(args?: SelectSubset<T, FeatureVectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureVectors
     * const featureVector = await prisma.featureVector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureVectorUpdateManyArgs>(args: SelectSubset<T, FeatureVectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureVectors and returns the data updated in the database.
     * @param {FeatureVectorUpdateManyAndReturnArgs} args - Arguments to update many FeatureVectors.
     * @example
     * // Update many FeatureVectors
     * const featureVector = await prisma.featureVector.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureVectors and only return the `id`
     * const featureVectorWithIdOnly = await prisma.featureVector.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureVectorUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureVectorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureVector.
     * @param {FeatureVectorUpsertArgs} args - Arguments to update or create a FeatureVector.
     * @example
     * // Update or create a FeatureVector
     * const featureVector = await prisma.featureVector.upsert({
     *   create: {
     *     // ... data to create a FeatureVector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureVector we want to update
     *   }
     * })
     */
    upsert<T extends FeatureVectorUpsertArgs>(args: SelectSubset<T, FeatureVectorUpsertArgs<ExtArgs>>): Prisma__FeatureVectorClient<$Result.GetResult<Prisma.$FeatureVectorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorCountArgs} args - Arguments to filter FeatureVectors to count.
     * @example
     * // Count the number of FeatureVectors
     * const count = await prisma.featureVector.count({
     *   where: {
     *     // ... the filter for the FeatureVectors we want to count
     *   }
     * })
    **/
    count<T extends FeatureVectorCountArgs>(
      args?: Subset<T, FeatureVectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureVectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureVectorAggregateArgs>(args: Subset<T, FeatureVectorAggregateArgs>): Prisma.PrismaPromise<GetFeatureVectorAggregateType<T>>

    /**
     * Group by FeatureVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureVectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureVectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureVectorGroupByArgs['orderBy'] }
        : { orderBy?: FeatureVectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureVectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureVectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureVector model
   */
  readonly fields: FeatureVectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureVector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureVectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shtabel<T extends ShtabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShtabelDefaultArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureVector model
   */
  interface FeatureVectorFieldRefs {
    readonly id: FieldRef<"FeatureVector", 'Int'>
    readonly ts: FieldRef<"FeatureVector", 'DateTime'>
    readonly skladId: FieldRef<"FeatureVector", 'Int'>
    readonly shtabelId: FieldRef<"FeatureVector", 'Int'>
    readonly features: FieldRef<"FeatureVector", 'Json'>
    readonly modelVersion: FieldRef<"FeatureVector", 'String'>
    readonly createdAt: FieldRef<"FeatureVector", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureVector findUnique
   */
  export type FeatureVectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter, which FeatureVector to fetch.
     */
    where: FeatureVectorWhereUniqueInput
  }

  /**
   * FeatureVector findUniqueOrThrow
   */
  export type FeatureVectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter, which FeatureVector to fetch.
     */
    where: FeatureVectorWhereUniqueInput
  }

  /**
   * FeatureVector findFirst
   */
  export type FeatureVectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter, which FeatureVector to fetch.
     */
    where?: FeatureVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureVectors to fetch.
     */
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureVectors.
     */
    cursor?: FeatureVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureVectors.
     */
    distinct?: FeatureVectorScalarFieldEnum | FeatureVectorScalarFieldEnum[]
  }

  /**
   * FeatureVector findFirstOrThrow
   */
  export type FeatureVectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter, which FeatureVector to fetch.
     */
    where?: FeatureVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureVectors to fetch.
     */
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureVectors.
     */
    cursor?: FeatureVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureVectors.
     */
    distinct?: FeatureVectorScalarFieldEnum | FeatureVectorScalarFieldEnum[]
  }

  /**
   * FeatureVector findMany
   */
  export type FeatureVectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter, which FeatureVectors to fetch.
     */
    where?: FeatureVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureVectors to fetch.
     */
    orderBy?: FeatureVectorOrderByWithRelationInput | FeatureVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureVectors.
     */
    cursor?: FeatureVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureVectors.
     */
    skip?: number
    distinct?: FeatureVectorScalarFieldEnum | FeatureVectorScalarFieldEnum[]
  }

  /**
   * FeatureVector create
   */
  export type FeatureVectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureVector.
     */
    data: XOR<FeatureVectorCreateInput, FeatureVectorUncheckedCreateInput>
  }

  /**
   * FeatureVector createMany
   */
  export type FeatureVectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureVectors.
     */
    data: FeatureVectorCreateManyInput | FeatureVectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureVector createManyAndReturn
   */
  export type FeatureVectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureVectors.
     */
    data: FeatureVectorCreateManyInput | FeatureVectorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureVector update
   */
  export type FeatureVectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureVector.
     */
    data: XOR<FeatureVectorUpdateInput, FeatureVectorUncheckedUpdateInput>
    /**
     * Choose, which FeatureVector to update.
     */
    where: FeatureVectorWhereUniqueInput
  }

  /**
   * FeatureVector updateMany
   */
  export type FeatureVectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureVectors.
     */
    data: XOR<FeatureVectorUpdateManyMutationInput, FeatureVectorUncheckedUpdateManyInput>
    /**
     * Filter which FeatureVectors to update
     */
    where?: FeatureVectorWhereInput
    /**
     * Limit how many FeatureVectors to update.
     */
    limit?: number
  }

  /**
   * FeatureVector updateManyAndReturn
   */
  export type FeatureVectorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * The data used to update FeatureVectors.
     */
    data: XOR<FeatureVectorUpdateManyMutationInput, FeatureVectorUncheckedUpdateManyInput>
    /**
     * Filter which FeatureVectors to update
     */
    where?: FeatureVectorWhereInput
    /**
     * Limit how many FeatureVectors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureVector upsert
   */
  export type FeatureVectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureVector to update in case it exists.
     */
    where: FeatureVectorWhereUniqueInput
    /**
     * In case the FeatureVector found by the `where` argument doesn't exist, create a new FeatureVector with this data.
     */
    create: XOR<FeatureVectorCreateInput, FeatureVectorUncheckedCreateInput>
    /**
     * In case the FeatureVector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureVectorUpdateInput, FeatureVectorUncheckedUpdateInput>
  }

  /**
   * FeatureVector delete
   */
  export type FeatureVectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
    /**
     * Filter which FeatureVector to delete.
     */
    where: FeatureVectorWhereUniqueInput
  }

  /**
   * FeatureVector deleteMany
   */
  export type FeatureVectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureVectors to delete
     */
    where?: FeatureVectorWhereInput
    /**
     * Limit how many FeatureVectors to delete.
     */
    limit?: number
  }

  /**
   * FeatureVector without action
   */
  export type FeatureVectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureVector
     */
    select?: FeatureVectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureVector
     */
    omit?: FeatureVectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureVectorInclude<ExtArgs> | null
  }


  /**
   * Model Prediction
   */

  export type AggregatePrediction = {
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  export type PredictionAvgAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    probEvent: number | null
    horizonDays: number | null
    confidence: number | null
    accuracy_days: number | null
  }

  export type PredictionSumAggregateOutputType = {
    id: number | null
    skladId: number | null
    shtabelId: number | null
    probEvent: number | null
    horizonDays: number | null
    confidence: number | null
    accuracy_days: number | null
  }

  export type PredictionMinAggregateOutputType = {
    id: number | null
    ts: Date | null
    skladId: number | null
    shtabelId: number | null
    modelName: string | null
    modelVersion: string | null
    predictedDate: Date | null
    probEvent: number | null
    riskLevel: $Enums.RiskLevel | null
    horizonDays: number | null
    intervalLow: Date | null
    intervalHigh: Date | null
    confidence: number | null
    actualFireDate: Date | null
    accuracy_days: number | null
    isAccurate: boolean | null
    notified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictionMaxAggregateOutputType = {
    id: number | null
    ts: Date | null
    skladId: number | null
    shtabelId: number | null
    modelName: string | null
    modelVersion: string | null
    predictedDate: Date | null
    probEvent: number | null
    riskLevel: $Enums.RiskLevel | null
    horizonDays: number | null
    intervalLow: Date | null
    intervalHigh: Date | null
    confidence: number | null
    actualFireDate: Date | null
    accuracy_days: number | null
    isAccurate: boolean | null
    notified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictionCountAggregateOutputType = {
    id: number
    ts: number
    skladId: number
    shtabelId: number
    modelName: number
    modelVersion: number
    predictedDate: number
    probEvent: number
    riskLevel: number
    horizonDays: number
    intervalLow: number
    intervalHigh: number
    confidence: number
    actualFireDate: number
    accuracy_days: number
    isAccurate: number
    meta: number
    notified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PredictionAvgAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    probEvent?: true
    horizonDays?: true
    confidence?: true
    accuracy_days?: true
  }

  export type PredictionSumAggregateInputType = {
    id?: true
    skladId?: true
    shtabelId?: true
    probEvent?: true
    horizonDays?: true
    confidence?: true
    accuracy_days?: true
  }

  export type PredictionMinAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    modelName?: true
    modelVersion?: true
    predictedDate?: true
    probEvent?: true
    riskLevel?: true
    horizonDays?: true
    intervalLow?: true
    intervalHigh?: true
    confidence?: true
    actualFireDate?: true
    accuracy_days?: true
    isAccurate?: true
    notified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictionMaxAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    modelName?: true
    modelVersion?: true
    predictedDate?: true
    probEvent?: true
    riskLevel?: true
    horizonDays?: true
    intervalLow?: true
    intervalHigh?: true
    confidence?: true
    actualFireDate?: true
    accuracy_days?: true
    isAccurate?: true
    notified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictionCountAggregateInputType = {
    id?: true
    ts?: true
    skladId?: true
    shtabelId?: true
    modelName?: true
    modelVersion?: true
    predictedDate?: true
    probEvent?: true
    riskLevel?: true
    horizonDays?: true
    intervalLow?: true
    intervalHigh?: true
    confidence?: true
    actualFireDate?: true
    accuracy_days?: true
    isAccurate?: true
    meta?: true
    notified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prediction to aggregate.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Predictions
    **/
    _count?: true | PredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionMaxAggregateInputType
  }

  export type GetPredictionAggregateType<T extends PredictionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrediction[P]>
      : GetScalarType<T[P], AggregatePrediction[P]>
  }




  export type PredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithAggregationInput | PredictionOrderByWithAggregationInput[]
    by: PredictionScalarFieldEnum[] | PredictionScalarFieldEnum
    having?: PredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionCountAggregateInputType | true
    _avg?: PredictionAvgAggregateInputType
    _sum?: PredictionSumAggregateInputType
    _min?: PredictionMinAggregateInputType
    _max?: PredictionMaxAggregateInputType
  }

  export type PredictionGroupByOutputType = {
    id: number
    ts: Date
    skladId: number
    shtabelId: number
    modelName: string
    modelVersion: string | null
    predictedDate: Date | null
    probEvent: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays: number
    intervalLow: Date | null
    intervalHigh: Date | null
    confidence: number | null
    actualFireDate: Date | null
    accuracy_days: number | null
    isAccurate: boolean | null
    meta: JsonValue | null
    notified: boolean
    createdAt: Date
    updatedAt: Date
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  type GetPredictionGroupByPayload<T extends PredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionGroupByOutputType[P]>
        }
      >
    >


  export type PredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    predictedDate?: boolean
    probEvent?: boolean
    riskLevel?: boolean
    horizonDays?: boolean
    intervalLow?: boolean
    intervalHigh?: boolean
    confidence?: boolean
    actualFireDate?: boolean
    accuracy_days?: boolean
    isAccurate?: boolean
    meta?: boolean
    notified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    predictedDate?: boolean
    probEvent?: boolean
    riskLevel?: boolean
    horizonDays?: boolean
    intervalLow?: boolean
    intervalHigh?: boolean
    confidence?: boolean
    actualFireDate?: boolean
    accuracy_days?: boolean
    isAccurate?: boolean
    meta?: boolean
    notified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    predictedDate?: boolean
    probEvent?: boolean
    riskLevel?: boolean
    horizonDays?: boolean
    intervalLow?: boolean
    intervalHigh?: boolean
    confidence?: boolean
    actualFireDate?: boolean
    accuracy_days?: boolean
    isAccurate?: boolean
    meta?: boolean
    notified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectScalar = {
    id?: boolean
    ts?: boolean
    skladId?: boolean
    shtabelId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    predictedDate?: boolean
    probEvent?: boolean
    riskLevel?: boolean
    horizonDays?: boolean
    intervalLow?: boolean
    intervalHigh?: boolean
    confidence?: boolean
    actualFireDate?: boolean
    accuracy_days?: boolean
    isAccurate?: boolean
    meta?: boolean
    notified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PredictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "skladId" | "shtabelId" | "modelName" | "modelVersion" | "predictedDate" | "probEvent" | "riskLevel" | "horizonDays" | "intervalLow" | "intervalHigh" | "confidence" | "actualFireDate" | "accuracy_days" | "isAccurate" | "meta" | "notified" | "createdAt" | "updatedAt", ExtArgs["result"]["prediction"]>
  export type PredictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type PredictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }
  export type PredictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sklad?: boolean | SkladDefaultArgs<ExtArgs>
    shtabel?: boolean | ShtabelDefaultArgs<ExtArgs>
  }

  export type $PredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prediction"
    objects: {
      sklad: Prisma.$SkladPayload<ExtArgs>
      shtabel: Prisma.$ShtabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ts: Date
      skladId: number
      shtabelId: number
      modelName: string
      modelVersion: string | null
      predictedDate: Date | null
      probEvent: number | null
      riskLevel: $Enums.RiskLevel
      horizonDays: number
      intervalLow: Date | null
      intervalHigh: Date | null
      confidence: number | null
      actualFireDate: Date | null
      accuracy_days: number | null
      isAccurate: boolean | null
      meta: Prisma.JsonValue | null
      notified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prediction"]>
    composites: {}
  }

  type PredictionGetPayload<S extends boolean | null | undefined | PredictionDefaultArgs> = $Result.GetResult<Prisma.$PredictionPayload, S>

  type PredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PredictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PredictionCountAggregateInputType | true
    }

  export interface PredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prediction'], meta: { name: 'Prediction' } }
    /**
     * Find zero or one Prediction that matches the filter.
     * @param {PredictionFindUniqueArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictionFindUniqueArgs>(args: SelectSubset<T, PredictionFindUniqueArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prediction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PredictionFindUniqueOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictionFindFirstArgs>(args?: SelectSubset<T, PredictionFindFirstArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Predictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Predictions
     * const predictions = await prisma.prediction.findMany()
     * 
     * // Get first 10 Predictions
     * const predictions = await prisma.prediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionWithIdOnly = await prisma.prediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictionFindManyArgs>(args?: SelectSubset<T, PredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prediction.
     * @param {PredictionCreateArgs} args - Arguments to create a Prediction.
     * @example
     * // Create one Prediction
     * const Prediction = await prisma.prediction.create({
     *   data: {
     *     // ... data to create a Prediction
     *   }
     * })
     * 
     */
    create<T extends PredictionCreateArgs>(args: SelectSubset<T, PredictionCreateArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Predictions.
     * @param {PredictionCreateManyArgs} args - Arguments to create many Predictions.
     * @example
     * // Create many Predictions
     * const prediction = await prisma.prediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictionCreateManyArgs>(args?: SelectSubset<T, PredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Predictions and returns the data saved in the database.
     * @param {PredictionCreateManyAndReturnArgs} args - Arguments to create many Predictions.
     * @example
     * // Create many Predictions
     * const prediction = await prisma.prediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Predictions and only return the `id`
     * const predictionWithIdOnly = await prisma.prediction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, PredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prediction.
     * @param {PredictionDeleteArgs} args - Arguments to delete one Prediction.
     * @example
     * // Delete one Prediction
     * const Prediction = await prisma.prediction.delete({
     *   where: {
     *     // ... filter to delete one Prediction
     *   }
     * })
     * 
     */
    delete<T extends PredictionDeleteArgs>(args: SelectSubset<T, PredictionDeleteArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prediction.
     * @param {PredictionUpdateArgs} args - Arguments to update one Prediction.
     * @example
     * // Update one Prediction
     * const prediction = await prisma.prediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictionUpdateArgs>(args: SelectSubset<T, PredictionUpdateArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Predictions.
     * @param {PredictionDeleteManyArgs} args - Arguments to filter Predictions to delete.
     * @example
     * // Delete a few Predictions
     * const { count } = await prisma.prediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictionDeleteManyArgs>(args?: SelectSubset<T, PredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Predictions
     * const prediction = await prisma.prediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictionUpdateManyArgs>(args: SelectSubset<T, PredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predictions and returns the data updated in the database.
     * @param {PredictionUpdateManyAndReturnArgs} args - Arguments to update many Predictions.
     * @example
     * // Update many Predictions
     * const prediction = await prisma.prediction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Predictions and only return the `id`
     * const predictionWithIdOnly = await prisma.prediction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PredictionUpdateManyAndReturnArgs>(args: SelectSubset<T, PredictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prediction.
     * @param {PredictionUpsertArgs} args - Arguments to update or create a Prediction.
     * @example
     * // Update or create a Prediction
     * const prediction = await prisma.prediction.upsert({
     *   create: {
     *     // ... data to create a Prediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prediction we want to update
     *   }
     * })
     */
    upsert<T extends PredictionUpsertArgs>(args: SelectSubset<T, PredictionUpsertArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionCountArgs} args - Arguments to filter Predictions to count.
     * @example
     * // Count the number of Predictions
     * const count = await prisma.prediction.count({
     *   where: {
     *     // ... the filter for the Predictions we want to count
     *   }
     * })
    **/
    count<T extends PredictionCountArgs>(
      args?: Subset<T, PredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionAggregateArgs>(args: Subset<T, PredictionAggregateArgs>): Prisma.PrismaPromise<GetPredictionAggregateType<T>>

    /**
     * Group by Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionGroupByArgs['orderBy'] }
        : { orderBy?: PredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prediction model
   */
  readonly fields: PredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sklad<T extends SkladDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkladDefaultArgs<ExtArgs>>): Prisma__SkladClient<$Result.GetResult<Prisma.$SkladPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shtabel<T extends ShtabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShtabelDefaultArgs<ExtArgs>>): Prisma__ShtabelClient<$Result.GetResult<Prisma.$ShtabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prediction model
   */
  interface PredictionFieldRefs {
    readonly id: FieldRef<"Prediction", 'Int'>
    readonly ts: FieldRef<"Prediction", 'DateTime'>
    readonly skladId: FieldRef<"Prediction", 'Int'>
    readonly shtabelId: FieldRef<"Prediction", 'Int'>
    readonly modelName: FieldRef<"Prediction", 'String'>
    readonly modelVersion: FieldRef<"Prediction", 'String'>
    readonly predictedDate: FieldRef<"Prediction", 'DateTime'>
    readonly probEvent: FieldRef<"Prediction", 'Float'>
    readonly riskLevel: FieldRef<"Prediction", 'RiskLevel'>
    readonly horizonDays: FieldRef<"Prediction", 'Int'>
    readonly intervalLow: FieldRef<"Prediction", 'DateTime'>
    readonly intervalHigh: FieldRef<"Prediction", 'DateTime'>
    readonly confidence: FieldRef<"Prediction", 'Float'>
    readonly actualFireDate: FieldRef<"Prediction", 'DateTime'>
    readonly accuracy_days: FieldRef<"Prediction", 'Float'>
    readonly isAccurate: FieldRef<"Prediction", 'Boolean'>
    readonly meta: FieldRef<"Prediction", 'Json'>
    readonly notified: FieldRef<"Prediction", 'Boolean'>
    readonly createdAt: FieldRef<"Prediction", 'DateTime'>
    readonly updatedAt: FieldRef<"Prediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prediction findUnique
   */
  export type PredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction findUniqueOrThrow
   */
  export type PredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction findFirst
   */
  export type PredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction findFirstOrThrow
   */
  export type PredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction findMany
   */
  export type PredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Predictions to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction create
   */
  export type PredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prediction.
     */
    data: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
  }

  /**
   * Prediction createMany
   */
  export type PredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Predictions.
     */
    data: PredictionCreateManyInput | PredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prediction createManyAndReturn
   */
  export type PredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * The data used to create many Predictions.
     */
    data: PredictionCreateManyInput | PredictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prediction update
   */
  export type PredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prediction.
     */
    data: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
    /**
     * Choose, which Prediction to update.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction updateMany
   */
  export type PredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Predictions.
     */
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyInput>
    /**
     * Filter which Predictions to update
     */
    where?: PredictionWhereInput
    /**
     * Limit how many Predictions to update.
     */
    limit?: number
  }

  /**
   * Prediction updateManyAndReturn
   */
  export type PredictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * The data used to update Predictions.
     */
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyInput>
    /**
     * Filter which Predictions to update
     */
    where?: PredictionWhereInput
    /**
     * Limit how many Predictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prediction upsert
   */
  export type PredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prediction to update in case it exists.
     */
    where: PredictionWhereUniqueInput
    /**
     * In case the Prediction found by the `where` argument doesn't exist, create a new Prediction with this data.
     */
    create: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
    /**
     * In case the Prediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
  }

  /**
   * Prediction delete
   */
  export type PredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter which Prediction to delete.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction deleteMany
   */
  export type PredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Predictions to delete
     */
    where?: PredictionWhereInput
    /**
     * Limit how many Predictions to delete.
     */
    limit?: number
  }

  /**
   * Prediction without action
   */
  export type PredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prediction
     */
    omit?: PredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
  }


  /**
   * Model ModelArtifact
   */

  export type AggregateModelArtifact = {
    _count: ModelArtifactCountAggregateOutputType | null
    _avg: ModelArtifactAvgAggregateOutputType | null
    _sum: ModelArtifactSumAggregateOutputType | null
    _min: ModelArtifactMinAggregateOutputType | null
    _max: ModelArtifactMaxAggregateOutputType | null
  }

  export type ModelArtifactAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
  }

  export type ModelArtifactSumAggregateOutputType = {
    id: number | null
    fileSize: bigint | null
  }

  export type ModelArtifactMinAggregateOutputType = {
    id: number | null
    name: string | null
    version: string | null
    status: $Enums.ModelStatus | null
    path: string | null
    fileSize: bigint | null
    trainedAt: Date | null
    trainedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelArtifactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    version: string | null
    status: $Enums.ModelStatus | null
    path: string | null
    fileSize: bigint | null
    trainedAt: Date | null
    trainedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelArtifactCountAggregateOutputType = {
    id: number
    name: number
    version: number
    status: number
    path: number
    fileSize: number
    trainedAt: number
    trainedBy: number
    trainingData: number
    hyperparams: number
    trainMetrics: number
    valMetrics: number
    testMetrics: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelArtifactAvgAggregateInputType = {
    id?: true
    fileSize?: true
  }

  export type ModelArtifactSumAggregateInputType = {
    id?: true
    fileSize?: true
  }

  export type ModelArtifactMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    status?: true
    path?: true
    fileSize?: true
    trainedAt?: true
    trainedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelArtifactMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    status?: true
    path?: true
    fileSize?: true
    trainedAt?: true
    trainedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelArtifactCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    status?: true
    path?: true
    fileSize?: true
    trainedAt?: true
    trainedBy?: true
    trainingData?: true
    hyperparams?: true
    trainMetrics?: true
    valMetrics?: true
    testMetrics?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelArtifact to aggregate.
     */
    where?: ModelArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelArtifacts to fetch.
     */
    orderBy?: ModelArtifactOrderByWithRelationInput | ModelArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelArtifacts
    **/
    _count?: true | ModelArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelArtifactMaxAggregateInputType
  }

  export type GetModelArtifactAggregateType<T extends ModelArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateModelArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelArtifact[P]>
      : GetScalarType<T[P], AggregateModelArtifact[P]>
  }




  export type ModelArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelArtifactWhereInput
    orderBy?: ModelArtifactOrderByWithAggregationInput | ModelArtifactOrderByWithAggregationInput[]
    by: ModelArtifactScalarFieldEnum[] | ModelArtifactScalarFieldEnum
    having?: ModelArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelArtifactCountAggregateInputType | true
    _avg?: ModelArtifactAvgAggregateInputType
    _sum?: ModelArtifactSumAggregateInputType
    _min?: ModelArtifactMinAggregateInputType
    _max?: ModelArtifactMaxAggregateInputType
  }

  export type ModelArtifactGroupByOutputType = {
    id: number
    name: string
    version: string
    status: $Enums.ModelStatus
    path: string
    fileSize: bigint | null
    trainedAt: Date | null
    trainedBy: string | null
    trainingData: JsonValue | null
    hyperparams: JsonValue | null
    trainMetrics: JsonValue | null
    valMetrics: JsonValue | null
    testMetrics: JsonValue | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ModelArtifactCountAggregateOutputType | null
    _avg: ModelArtifactAvgAggregateOutputType | null
    _sum: ModelArtifactSumAggregateOutputType | null
    _min: ModelArtifactMinAggregateOutputType | null
    _max: ModelArtifactMaxAggregateOutputType | null
  }

  type GetModelArtifactGroupByPayload<T extends ModelArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ModelArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ModelArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    path?: boolean
    fileSize?: boolean
    trainedAt?: boolean
    trainedBy?: boolean
    trainingData?: boolean
    hyperparams?: boolean
    trainMetrics?: boolean
    valMetrics?: boolean
    testMetrics?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelArtifact"]>

  export type ModelArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    path?: boolean
    fileSize?: boolean
    trainedAt?: boolean
    trainedBy?: boolean
    trainingData?: boolean
    hyperparams?: boolean
    trainMetrics?: boolean
    valMetrics?: boolean
    testMetrics?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelArtifact"]>

  export type ModelArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    path?: boolean
    fileSize?: boolean
    trainedAt?: boolean
    trainedBy?: boolean
    trainingData?: boolean
    hyperparams?: boolean
    trainMetrics?: boolean
    valMetrics?: boolean
    testMetrics?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modelArtifact"]>

  export type ModelArtifactSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    path?: boolean
    fileSize?: boolean
    trainedAt?: boolean
    trainedBy?: boolean
    trainingData?: boolean
    hyperparams?: boolean
    trainMetrics?: boolean
    valMetrics?: boolean
    testMetrics?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version" | "status" | "path" | "fileSize" | "trainedAt" | "trainedBy" | "trainingData" | "hyperparams" | "trainMetrics" | "valMetrics" | "testMetrics" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["modelArtifact"]>

  export type $ModelArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelArtifact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      version: string
      status: $Enums.ModelStatus
      path: string
      fileSize: bigint | null
      trainedAt: Date | null
      trainedBy: string | null
      trainingData: Prisma.JsonValue | null
      hyperparams: Prisma.JsonValue | null
      trainMetrics: Prisma.JsonValue | null
      valMetrics: Prisma.JsonValue | null
      testMetrics: Prisma.JsonValue | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modelArtifact"]>
    composites: {}
  }

  type ModelArtifactGetPayload<S extends boolean | null | undefined | ModelArtifactDefaultArgs> = $Result.GetResult<Prisma.$ModelArtifactPayload, S>

  type ModelArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelArtifactCountAggregateInputType | true
    }

  export interface ModelArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelArtifact'], meta: { name: 'ModelArtifact' } }
    /**
     * Find zero or one ModelArtifact that matches the filter.
     * @param {ModelArtifactFindUniqueArgs} args - Arguments to find a ModelArtifact
     * @example
     * // Get one ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelArtifactFindUniqueArgs>(args: SelectSubset<T, ModelArtifactFindUniqueArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelArtifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelArtifactFindUniqueOrThrowArgs} args - Arguments to find a ModelArtifact
     * @example
     * // Get one ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactFindFirstArgs} args - Arguments to find a ModelArtifact
     * @example
     * // Get one ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelArtifactFindFirstArgs>(args?: SelectSubset<T, ModelArtifactFindFirstArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactFindFirstOrThrowArgs} args - Arguments to find a ModelArtifact
     * @example
     * // Get one ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelArtifacts
     * const modelArtifacts = await prisma.modelArtifact.findMany()
     * 
     * // Get first 10 ModelArtifacts
     * const modelArtifacts = await prisma.modelArtifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelArtifactWithIdOnly = await prisma.modelArtifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelArtifactFindManyArgs>(args?: SelectSubset<T, ModelArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelArtifact.
     * @param {ModelArtifactCreateArgs} args - Arguments to create a ModelArtifact.
     * @example
     * // Create one ModelArtifact
     * const ModelArtifact = await prisma.modelArtifact.create({
     *   data: {
     *     // ... data to create a ModelArtifact
     *   }
     * })
     * 
     */
    create<T extends ModelArtifactCreateArgs>(args: SelectSubset<T, ModelArtifactCreateArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelArtifacts.
     * @param {ModelArtifactCreateManyArgs} args - Arguments to create many ModelArtifacts.
     * @example
     * // Create many ModelArtifacts
     * const modelArtifact = await prisma.modelArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelArtifactCreateManyArgs>(args?: SelectSubset<T, ModelArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelArtifacts and returns the data saved in the database.
     * @param {ModelArtifactCreateManyAndReturnArgs} args - Arguments to create many ModelArtifacts.
     * @example
     * // Create many ModelArtifacts
     * const modelArtifact = await prisma.modelArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelArtifacts and only return the `id`
     * const modelArtifactWithIdOnly = await prisma.modelArtifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelArtifact.
     * @param {ModelArtifactDeleteArgs} args - Arguments to delete one ModelArtifact.
     * @example
     * // Delete one ModelArtifact
     * const ModelArtifact = await prisma.modelArtifact.delete({
     *   where: {
     *     // ... filter to delete one ModelArtifact
     *   }
     * })
     * 
     */
    delete<T extends ModelArtifactDeleteArgs>(args: SelectSubset<T, ModelArtifactDeleteArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelArtifact.
     * @param {ModelArtifactUpdateArgs} args - Arguments to update one ModelArtifact.
     * @example
     * // Update one ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelArtifactUpdateArgs>(args: SelectSubset<T, ModelArtifactUpdateArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelArtifacts.
     * @param {ModelArtifactDeleteManyArgs} args - Arguments to filter ModelArtifacts to delete.
     * @example
     * // Delete a few ModelArtifacts
     * const { count } = await prisma.modelArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelArtifactDeleteManyArgs>(args?: SelectSubset<T, ModelArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelArtifacts
     * const modelArtifact = await prisma.modelArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelArtifactUpdateManyArgs>(args: SelectSubset<T, ModelArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelArtifacts and returns the data updated in the database.
     * @param {ModelArtifactUpdateManyAndReturnArgs} args - Arguments to update many ModelArtifacts.
     * @example
     * // Update many ModelArtifacts
     * const modelArtifact = await prisma.modelArtifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelArtifacts and only return the `id`
     * const modelArtifactWithIdOnly = await prisma.modelArtifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelArtifact.
     * @param {ModelArtifactUpsertArgs} args - Arguments to update or create a ModelArtifact.
     * @example
     * // Update or create a ModelArtifact
     * const modelArtifact = await prisma.modelArtifact.upsert({
     *   create: {
     *     // ... data to create a ModelArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelArtifact we want to update
     *   }
     * })
     */
    upsert<T extends ModelArtifactUpsertArgs>(args: SelectSubset<T, ModelArtifactUpsertArgs<ExtArgs>>): Prisma__ModelArtifactClient<$Result.GetResult<Prisma.$ModelArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactCountArgs} args - Arguments to filter ModelArtifacts to count.
     * @example
     * // Count the number of ModelArtifacts
     * const count = await prisma.modelArtifact.count({
     *   where: {
     *     // ... the filter for the ModelArtifacts we want to count
     *   }
     * })
    **/
    count<T extends ModelArtifactCountArgs>(
      args?: Subset<T, ModelArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelArtifactAggregateArgs>(args: Subset<T, ModelArtifactAggregateArgs>): Prisma.PrismaPromise<GetModelArtifactAggregateType<T>>

    /**
     * Group by ModelArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ModelArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelArtifact model
   */
  readonly fields: ModelArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelArtifact model
   */
  interface ModelArtifactFieldRefs {
    readonly id: FieldRef<"ModelArtifact", 'Int'>
    readonly name: FieldRef<"ModelArtifact", 'String'>
    readonly version: FieldRef<"ModelArtifact", 'String'>
    readonly status: FieldRef<"ModelArtifact", 'ModelStatus'>
    readonly path: FieldRef<"ModelArtifact", 'String'>
    readonly fileSize: FieldRef<"ModelArtifact", 'BigInt'>
    readonly trainedAt: FieldRef<"ModelArtifact", 'DateTime'>
    readonly trainedBy: FieldRef<"ModelArtifact", 'String'>
    readonly trainingData: FieldRef<"ModelArtifact", 'Json'>
    readonly hyperparams: FieldRef<"ModelArtifact", 'Json'>
    readonly trainMetrics: FieldRef<"ModelArtifact", 'Json'>
    readonly valMetrics: FieldRef<"ModelArtifact", 'Json'>
    readonly testMetrics: FieldRef<"ModelArtifact", 'Json'>
    readonly meta: FieldRef<"ModelArtifact", 'Json'>
    readonly createdAt: FieldRef<"ModelArtifact", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelArtifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelArtifact findUnique
   */
  export type ModelArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter, which ModelArtifact to fetch.
     */
    where: ModelArtifactWhereUniqueInput
  }

  /**
   * ModelArtifact findUniqueOrThrow
   */
  export type ModelArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter, which ModelArtifact to fetch.
     */
    where: ModelArtifactWhereUniqueInput
  }

  /**
   * ModelArtifact findFirst
   */
  export type ModelArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter, which ModelArtifact to fetch.
     */
    where?: ModelArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelArtifacts to fetch.
     */
    orderBy?: ModelArtifactOrderByWithRelationInput | ModelArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelArtifacts.
     */
    cursor?: ModelArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelArtifacts.
     */
    distinct?: ModelArtifactScalarFieldEnum | ModelArtifactScalarFieldEnum[]
  }

  /**
   * ModelArtifact findFirstOrThrow
   */
  export type ModelArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter, which ModelArtifact to fetch.
     */
    where?: ModelArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelArtifacts to fetch.
     */
    orderBy?: ModelArtifactOrderByWithRelationInput | ModelArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelArtifacts.
     */
    cursor?: ModelArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelArtifacts.
     */
    distinct?: ModelArtifactScalarFieldEnum | ModelArtifactScalarFieldEnum[]
  }

  /**
   * ModelArtifact findMany
   */
  export type ModelArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter, which ModelArtifacts to fetch.
     */
    where?: ModelArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelArtifacts to fetch.
     */
    orderBy?: ModelArtifactOrderByWithRelationInput | ModelArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelArtifacts.
     */
    cursor?: ModelArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelArtifacts.
     */
    skip?: number
    distinct?: ModelArtifactScalarFieldEnum | ModelArtifactScalarFieldEnum[]
  }

  /**
   * ModelArtifact create
   */
  export type ModelArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * The data needed to create a ModelArtifact.
     */
    data: XOR<ModelArtifactCreateInput, ModelArtifactUncheckedCreateInput>
  }

  /**
   * ModelArtifact createMany
   */
  export type ModelArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelArtifacts.
     */
    data: ModelArtifactCreateManyInput | ModelArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelArtifact createManyAndReturn
   */
  export type ModelArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many ModelArtifacts.
     */
    data: ModelArtifactCreateManyInput | ModelArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelArtifact update
   */
  export type ModelArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * The data needed to update a ModelArtifact.
     */
    data: XOR<ModelArtifactUpdateInput, ModelArtifactUncheckedUpdateInput>
    /**
     * Choose, which ModelArtifact to update.
     */
    where: ModelArtifactWhereUniqueInput
  }

  /**
   * ModelArtifact updateMany
   */
  export type ModelArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelArtifacts.
     */
    data: XOR<ModelArtifactUpdateManyMutationInput, ModelArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ModelArtifacts to update
     */
    where?: ModelArtifactWhereInput
    /**
     * Limit how many ModelArtifacts to update.
     */
    limit?: number
  }

  /**
   * ModelArtifact updateManyAndReturn
   */
  export type ModelArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * The data used to update ModelArtifacts.
     */
    data: XOR<ModelArtifactUpdateManyMutationInput, ModelArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ModelArtifacts to update
     */
    where?: ModelArtifactWhereInput
    /**
     * Limit how many ModelArtifacts to update.
     */
    limit?: number
  }

  /**
   * ModelArtifact upsert
   */
  export type ModelArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * The filter to search for the ModelArtifact to update in case it exists.
     */
    where: ModelArtifactWhereUniqueInput
    /**
     * In case the ModelArtifact found by the `where` argument doesn't exist, create a new ModelArtifact with this data.
     */
    create: XOR<ModelArtifactCreateInput, ModelArtifactUncheckedCreateInput>
    /**
     * In case the ModelArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelArtifactUpdateInput, ModelArtifactUncheckedUpdateInput>
  }

  /**
   * ModelArtifact delete
   */
  export type ModelArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
    /**
     * Filter which ModelArtifact to delete.
     */
    where: ModelArtifactWhereUniqueInput
  }

  /**
   * ModelArtifact deleteMany
   */
  export type ModelArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelArtifacts to delete
     */
    where?: ModelArtifactWhereInput
    /**
     * Limit how many ModelArtifacts to delete.
     */
    limit?: number
  }

  /**
   * ModelArtifact without action
   */
  export type ModelArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelArtifact
     */
    select?: ModelArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelArtifact
     */
    omit?: ModelArtifactOmit<ExtArgs> | null
  }


  /**
   * Model Metric
   */

  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    id: number | null
    mae_days: number | null
    rmse_days: number | null
    mape: number | null
    accuracy_within_2d: number | null
    accuracy_within_3d: number | null
    accuracy_within_5d: number | null
    c_index: number | null
    precision: number | null
    recall: number | null
    f1_score: number | null
    totalPredictions: number | null
    totalFires: number | null
    truePositives: number | null
    falsePositives: number | null
    falseNegatives: number | null
    trueNegatives: number | null
  }

  export type MetricSumAggregateOutputType = {
    id: number | null
    mae_days: number | null
    rmse_days: number | null
    mape: number | null
    accuracy_within_2d: number | null
    accuracy_within_3d: number | null
    accuracy_within_5d: number | null
    c_index: number | null
    precision: number | null
    recall: number | null
    f1_score: number | null
    totalPredictions: number | null
    totalFires: number | null
    truePositives: number | null
    falsePositives: number | null
    falseNegatives: number | null
    trueNegatives: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: number | null
    modelName: string | null
    modelVersion: string | null
    periodStart: Date | null
    periodEnd: Date | null
    mae_days: number | null
    rmse_days: number | null
    mape: number | null
    accuracy_within_2d: number | null
    accuracy_within_3d: number | null
    accuracy_within_5d: number | null
    c_index: number | null
    precision: number | null
    recall: number | null
    f1_score: number | null
    totalPredictions: number | null
    totalFires: number | null
    truePositives: number | null
    falsePositives: number | null
    falseNegatives: number | null
    trueNegatives: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetricMaxAggregateOutputType = {
    id: number | null
    modelName: string | null
    modelVersion: string | null
    periodStart: Date | null
    periodEnd: Date | null
    mae_days: number | null
    rmse_days: number | null
    mape: number | null
    accuracy_within_2d: number | null
    accuracy_within_3d: number | null
    accuracy_within_5d: number | null
    c_index: number | null
    precision: number | null
    recall: number | null
    f1_score: number | null
    totalPredictions: number | null
    totalFires: number | null
    truePositives: number | null
    falsePositives: number | null
    falseNegatives: number | null
    trueNegatives: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    modelName: number
    modelVersion: number
    periodStart: number
    periodEnd: number
    mae_days: number
    rmse_days: number
    mape: number
    accuracy_within_2d: number
    accuracy_within_3d: number
    accuracy_within_5d: number
    c_index: number
    precision: number
    recall: number
    f1_score: number
    totalPredictions: number
    totalFires: number
    truePositives: number
    falsePositives: number
    falseNegatives: number
    trueNegatives: number
    raw: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    id?: true
    mae_days?: true
    rmse_days?: true
    mape?: true
    accuracy_within_2d?: true
    accuracy_within_3d?: true
    accuracy_within_5d?: true
    c_index?: true
    precision?: true
    recall?: true
    f1_score?: true
    totalPredictions?: true
    totalFires?: true
    truePositives?: true
    falsePositives?: true
    falseNegatives?: true
    trueNegatives?: true
  }

  export type MetricSumAggregateInputType = {
    id?: true
    mae_days?: true
    rmse_days?: true
    mape?: true
    accuracy_within_2d?: true
    accuracy_within_3d?: true
    accuracy_within_5d?: true
    c_index?: true
    precision?: true
    recall?: true
    f1_score?: true
    totalPredictions?: true
    totalFires?: true
    truePositives?: true
    falsePositives?: true
    falseNegatives?: true
    trueNegatives?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    modelName?: true
    modelVersion?: true
    periodStart?: true
    periodEnd?: true
    mae_days?: true
    rmse_days?: true
    mape?: true
    accuracy_within_2d?: true
    accuracy_within_3d?: true
    accuracy_within_5d?: true
    c_index?: true
    precision?: true
    recall?: true
    f1_score?: true
    totalPredictions?: true
    totalFires?: true
    truePositives?: true
    falsePositives?: true
    falseNegatives?: true
    trueNegatives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    modelName?: true
    modelVersion?: true
    periodStart?: true
    periodEnd?: true
    mae_days?: true
    rmse_days?: true
    mape?: true
    accuracy_within_2d?: true
    accuracy_within_3d?: true
    accuracy_within_5d?: true
    c_index?: true
    precision?: true
    recall?: true
    f1_score?: true
    totalPredictions?: true
    totalFires?: true
    truePositives?: true
    falsePositives?: true
    falseNegatives?: true
    trueNegatives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    modelName?: true
    modelVersion?: true
    periodStart?: true
    periodEnd?: true
    mae_days?: true
    rmse_days?: true
    mape?: true
    accuracy_within_2d?: true
    accuracy_within_3d?: true
    accuracy_within_5d?: true
    c_index?: true
    precision?: true
    recall?: true
    f1_score?: true
    totalPredictions?: true
    totalFires?: true
    truePositives?: true
    falsePositives?: true
    falseNegatives?: true
    trueNegatives?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithAggregationInput | MetricOrderByWithAggregationInput[]
    by: MetricScalarFieldEnum[] | MetricScalarFieldEnum
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }

  export type MetricGroupByOutputType = {
    id: number
    modelName: string
    modelVersion: string | null
    periodStart: Date
    periodEnd: Date
    mae_days: number | null
    rmse_days: number | null
    mape: number | null
    accuracy_within_2d: number | null
    accuracy_within_3d: number | null
    accuracy_within_5d: number | null
    c_index: number | null
    precision: number | null
    recall: number | null
    f1_score: number | null
    totalPredictions: number | null
    totalFires: number | null
    truePositives: number | null
    falsePositives: number | null
    falseNegatives: number | null
    trueNegatives: number | null
    raw: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelVersion?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    mae_days?: boolean
    rmse_days?: boolean
    mape?: boolean
    accuracy_within_2d?: boolean
    accuracy_within_3d?: boolean
    accuracy_within_5d?: boolean
    c_index?: boolean
    precision?: boolean
    recall?: boolean
    f1_score?: boolean
    totalPredictions?: boolean
    totalFires?: boolean
    truePositives?: boolean
    falsePositives?: boolean
    falseNegatives?: boolean
    trueNegatives?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelVersion?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    mae_days?: boolean
    rmse_days?: boolean
    mape?: boolean
    accuracy_within_2d?: boolean
    accuracy_within_3d?: boolean
    accuracy_within_5d?: boolean
    c_index?: boolean
    precision?: boolean
    recall?: boolean
    f1_score?: boolean
    totalPredictions?: boolean
    totalFires?: boolean
    truePositives?: boolean
    falsePositives?: boolean
    falseNegatives?: boolean
    trueNegatives?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelVersion?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    mae_days?: boolean
    rmse_days?: boolean
    mape?: boolean
    accuracy_within_2d?: boolean
    accuracy_within_3d?: boolean
    accuracy_within_5d?: boolean
    c_index?: boolean
    precision?: boolean
    recall?: boolean
    f1_score?: boolean
    totalPredictions?: boolean
    totalFires?: boolean
    truePositives?: boolean
    falsePositives?: boolean
    falseNegatives?: boolean
    trueNegatives?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectScalar = {
    id?: boolean
    modelName?: boolean
    modelVersion?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    mae_days?: boolean
    rmse_days?: boolean
    mape?: boolean
    accuracy_within_2d?: boolean
    accuracy_within_3d?: boolean
    accuracy_within_5d?: boolean
    c_index?: boolean
    precision?: boolean
    recall?: boolean
    f1_score?: boolean
    totalPredictions?: boolean
    totalFires?: boolean
    truePositives?: boolean
    falsePositives?: boolean
    falseNegatives?: boolean
    trueNegatives?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelName" | "modelVersion" | "periodStart" | "periodEnd" | "mae_days" | "rmse_days" | "mape" | "accuracy_within_2d" | "accuracy_within_3d" | "accuracy_within_5d" | "c_index" | "precision" | "recall" | "f1_score" | "totalPredictions" | "totalFires" | "truePositives" | "falsePositives" | "falseNegatives" | "trueNegatives" | "raw" | "createdAt" | "updatedAt", ExtArgs["result"]["metric"]>

  export type $MetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      modelName: string
      modelVersion: string | null
      periodStart: Date
      periodEnd: Date
      mae_days: number | null
      rmse_days: number | null
      mape: number | null
      accuracy_within_2d: number | null
      accuracy_within_3d: number | null
      accuracy_within_5d: number | null
      c_index: number | null
      precision: number | null
      recall: number | null
      f1_score: number | null
      totalPredictions: number | null
      totalFires: number | null
      truePositives: number | null
      falsePositives: number | null
      falseNegatives: number | null
      trueNegatives: number | null
      raw: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["metric"]>
    composites: {}
  }

  type MetricGetPayload<S extends boolean | null | undefined | MetricDefaultArgs> = $Result.GetResult<Prisma.$MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricFindUniqueArgs>(args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricFindFirstArgs>(args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricFindManyArgs>(args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
     */
    create<T extends MetricCreateArgs>(args: SelectSubset<T, MetricCreateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metrics.
     * @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricCreateManyArgs>(args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metrics and returns the data saved in the database.
     * @param {MetricCreateManyAndReturnArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metrics and only return the `id`
     * const metricWithIdOnly = await prisma.metric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetricCreateManyAndReturnArgs>(args?: SelectSubset<T, MetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
     */
    delete<T extends MetricDeleteArgs>(args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricUpdateArgs>(args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricDeleteManyArgs>(args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricUpdateManyArgs>(args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics and returns the data updated in the database.
     * @param {MetricUpdateManyAndReturnArgs} args - Arguments to update many Metrics.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Metrics and only return the `id`
     * const metricWithIdOnly = await prisma.metric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetricUpdateManyAndReturnArgs>(args: SelectSubset<T, MetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
     */
    upsert<T extends MetricUpsertArgs>(args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metric model
   */
  readonly fields: MetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metric model
   */
  interface MetricFieldRefs {
    readonly id: FieldRef<"Metric", 'Int'>
    readonly modelName: FieldRef<"Metric", 'String'>
    readonly modelVersion: FieldRef<"Metric", 'String'>
    readonly periodStart: FieldRef<"Metric", 'DateTime'>
    readonly periodEnd: FieldRef<"Metric", 'DateTime'>
    readonly mae_days: FieldRef<"Metric", 'Float'>
    readonly rmse_days: FieldRef<"Metric", 'Float'>
    readonly mape: FieldRef<"Metric", 'Float'>
    readonly accuracy_within_2d: FieldRef<"Metric", 'Float'>
    readonly accuracy_within_3d: FieldRef<"Metric", 'Float'>
    readonly accuracy_within_5d: FieldRef<"Metric", 'Float'>
    readonly c_index: FieldRef<"Metric", 'Float'>
    readonly precision: FieldRef<"Metric", 'Float'>
    readonly recall: FieldRef<"Metric", 'Float'>
    readonly f1_score: FieldRef<"Metric", 'Float'>
    readonly totalPredictions: FieldRef<"Metric", 'Int'>
    readonly totalFires: FieldRef<"Metric", 'Int'>
    readonly truePositives: FieldRef<"Metric", 'Int'>
    readonly falsePositives: FieldRef<"Metric", 'Int'>
    readonly falseNegatives: FieldRef<"Metric", 'Int'>
    readonly trueNegatives: FieldRef<"Metric", 'Int'>
    readonly raw: FieldRef<"Metric", 'Json'>
    readonly createdAt: FieldRef<"Metric", 'DateTime'>
    readonly updatedAt: FieldRef<"Metric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Metric findUnique
   */
  export type MetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findFirst
   */
  export type MetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }

  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric createManyAndReturn
   */
  export type MetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to update.
     */
    limit?: number
  }

  /**
   * Metric updateManyAndReturn
   */
  export type MetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to update.
     */
    limit?: number
  }

  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }

  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to delete.
     */
    limit?: number
  }

  /**
   * Metric without action
   */
  export type MetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    predictionId: number | null
    shtabelId: number | null
    skladId: number | null
    telegramMsgId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    predictionId: number | null
    shtabelId: number | null
    skladId: number | null
    telegramMsgId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    title: string | null
    message: string | null
    predictionId: number | null
    shtabelId: number | null
    skladId: number | null
    telegramSent: boolean | null
    telegramMsgId: number | null
    readAt: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    title: string | null
    message: string | null
    predictionId: number | null
    shtabelId: number | null
    skladId: number | null
    telegramSent: boolean | null
    telegramMsgId: number | null
    readAt: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    title: number
    message: number
    data: number
    predictionId: number
    shtabelId: number
    skladId: number
    telegramSent: number
    telegramMsgId: number
    readAt: number
    sentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
    predictionId?: true
    shtabelId?: true
    skladId?: true
    telegramMsgId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
    predictionId?: true
    shtabelId?: true
    skladId?: true
    telegramMsgId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    title?: true
    message?: true
    predictionId?: true
    shtabelId?: true
    skladId?: true
    telegramSent?: true
    telegramMsgId?: true
    readAt?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    title?: true
    message?: true
    predictionId?: true
    shtabelId?: true
    skladId?: true
    telegramSent?: true
    telegramMsgId?: true
    readAt?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    title?: true
    message?: true
    data?: true
    predictionId?: true
    shtabelId?: true
    skladId?: true
    telegramSent?: true
    telegramMsgId?: true
    readAt?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    title: string
    message: string
    data: JsonValue | null
    predictionId: number | null
    shtabelId: number | null
    skladId: number | null
    telegramSent: boolean
    telegramMsgId: number | null
    readAt: Date | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    predictionId?: boolean
    shtabelId?: boolean
    skladId?: boolean
    telegramSent?: boolean
    telegramMsgId?: boolean
    readAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    predictionId?: boolean
    shtabelId?: boolean
    skladId?: boolean
    telegramSent?: boolean
    telegramMsgId?: boolean
    readAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    predictionId?: boolean
    shtabelId?: boolean
    skladId?: boolean
    telegramSent?: boolean
    telegramMsgId?: boolean
    readAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    predictionId?: boolean
    shtabelId?: boolean
    skladId?: boolean
    telegramSent?: boolean
    telegramMsgId?: boolean
    readAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "status" | "title" | "message" | "data" | "predictionId" | "shtabelId" | "skladId" | "telegramSent" | "telegramMsgId" | "readAt" | "sentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.NotificationType
      status: $Enums.NotificationStatus
      title: string
      message: string
      data: Prisma.JsonValue | null
      predictionId: number | null
      shtabelId: number | null
      skladId: number | null
      telegramSent: boolean
      telegramMsgId: number | null
      readAt: Date | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly predictionId: FieldRef<"Notification", 'Int'>
    readonly shtabelId: FieldRef<"Notification", 'Int'>
    readonly skladId: FieldRef<"Notification", 'Int'>
    readonly telegramSent: FieldRef<"Notification", 'Boolean'>
    readonly telegramMsgId: FieldRef<"Notification", 'Int'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    resourceId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    resourceId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: $Enums.AuditAction | null
    resource: string | null
    resourceId: number | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: $Enums.AuditAction | null
    resource: string | null
    resourceId: number | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    description: number
    payload: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    resourceId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    resourceId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    description?: true
    payload?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number | null
    action: $Enums.AuditAction
    resource: string | null
    resourceId: number | null
    description: string | null
    payload: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    errorMessage: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    description?: boolean
    payload?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    description?: boolean
    payload?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    description?: boolean
    payload?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    description?: boolean
    payload?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "description" | "payload" | "ipAddress" | "userAgent" | "success" | "errorMessage" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      action: $Enums.AuditAction
      resource: string | null
      resourceId: number | null
      description: string | null
      payload: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'Int'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly payload: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly success: FieldRef<"AuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    id?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    id?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: number
    key: string
    value: string
    description: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      description: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'Int'>
    readonly key: FieldRef<"SystemSettings", 'String'>
    readonly value: FieldRef<"SystemSettings", 'String'>
    readonly description: FieldRef<"SystemSettings", 'String'>
    readonly category: FieldRef<"SystemSettings", 'String'>
    readonly createdAt: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    role: 'role',
    status: 'status',
    lang: 'lang',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notifyCritical: 'notifyCritical',
    notifyHigh: 'notifyHigh',
    notifyMedium: 'notifyMedium',
    notifyLow: 'notifyLow',
    defaultSkladId: 'defaultSkladId',
    defaultView: 'defaultView',
    predictionHorizon: 'predictionHorizon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const UploadScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    fileType: 'fileType',
    uploadedBy: 'uploadedBy',
    status: 'status',
    rowsTotal: 'rowsTotal',
    rowsProcessed: 'rowsProcessed',
    rowsFailed: 'rowsFailed',
    errors: 'errors',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UploadScalarFieldEnum = (typeof UploadScalarFieldEnum)[keyof typeof UploadScalarFieldEnum]


  export const SkladScalarFieldEnum: {
    id: 'id',
    number: 'number',
    name: 'name',
    locationRaw: 'locationRaw',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkladScalarFieldEnum = (typeof SkladScalarFieldEnum)[keyof typeof SkladScalarFieldEnum]


  export const ShtabelScalarFieldEnum: {
    id: 'id',
    skladId: 'skladId',
    label: 'label',
    mark: 'mark',
    formedAt: 'formedAt',
    height_m: 'height_m',
    width_m: 'width_m',
    length_m: 'length_m',
    mass_t: 'mass_t',
    status: 'status',
    currentMass: 'currentMass',
    lastTemp: 'lastTemp',
    lastTempDate: 'lastTempDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShtabelScalarFieldEnum = (typeof ShtabelScalarFieldEnum)[keyof typeof ShtabelScalarFieldEnum]


  export const SupplyScalarFieldEnum: {
    id: 'id',
    skladId: 'skladId',
    shtabelId: 'shtabelId',
    dateIn: 'dateIn',
    mark: 'mark',
    dateShip: 'dateShip',
    toStorage_t: 'toStorage_t',
    toShip_t: 'toShip_t',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplyScalarFieldEnum = (typeof SupplyScalarFieldEnum)[keyof typeof SupplyScalarFieldEnum]


  export const FireRecordScalarFieldEnum: {
    id: 'id',
    skladId: 'skladId',
    shtabelId: 'shtabelId',
    reportDate: 'reportDate',
    mark: 'mark',
    weight_t: 'weight_t',
    startDate: 'startDate',
    endDate: 'endDate',
    formedAt: 'formedAt',
    duration_hours: 'duration_hours',
    damage_t: 'damage_t',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FireRecordScalarFieldEnum = (typeof FireRecordScalarFieldEnum)[keyof typeof FireRecordScalarFieldEnum]


  export const TempRecordScalarFieldEnum: {
    id: 'id',
    skladId: 'skladId',
    shtabelId: 'shtabelId',
    mark: 'mark',
    maxTemp: 'maxTemp',
    piket: 'piket',
    recordDate: 'recordDate',
    shift: 'shift',
    riskLevel: 'riskLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TempRecordScalarFieldEnum = (typeof TempRecordScalarFieldEnum)[keyof typeof TempRecordScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    t: 't',
    p: 'p',
    humidity: 'humidity',
    precipitation: 'precipitation',
    wind_dir: 'wind_dir',
    v_avg: 'v_avg',
    v_max: 'v_max',
    cloudcover: 'cloudcover',
    visibility: 'visibility',
    weather_code: 'weather_code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const FeatureVectorScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    skladId: 'skladId',
    shtabelId: 'shtabelId',
    features: 'features',
    modelVersion: 'modelVersion',
    createdAt: 'createdAt'
  };

  export type FeatureVectorScalarFieldEnum = (typeof FeatureVectorScalarFieldEnum)[keyof typeof FeatureVectorScalarFieldEnum]


  export const PredictionScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    skladId: 'skladId',
    shtabelId: 'shtabelId',
    modelName: 'modelName',
    modelVersion: 'modelVersion',
    predictedDate: 'predictedDate',
    probEvent: 'probEvent',
    riskLevel: 'riskLevel',
    horizonDays: 'horizonDays',
    intervalLow: 'intervalLow',
    intervalHigh: 'intervalHigh',
    confidence: 'confidence',
    actualFireDate: 'actualFireDate',
    accuracy_days: 'accuracy_days',
    isAccurate: 'isAccurate',
    meta: 'meta',
    notified: 'notified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PredictionScalarFieldEnum = (typeof PredictionScalarFieldEnum)[keyof typeof PredictionScalarFieldEnum]


  export const ModelArtifactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    status: 'status',
    path: 'path',
    fileSize: 'fileSize',
    trainedAt: 'trainedAt',
    trainedBy: 'trainedBy',
    trainingData: 'trainingData',
    hyperparams: 'hyperparams',
    trainMetrics: 'trainMetrics',
    valMetrics: 'valMetrics',
    testMetrics: 'testMetrics',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelArtifactScalarFieldEnum = (typeof ModelArtifactScalarFieldEnum)[keyof typeof ModelArtifactScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    modelVersion: 'modelVersion',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    mae_days: 'mae_days',
    rmse_days: 'rmse_days',
    mape: 'mape',
    accuracy_within_2d: 'accuracy_within_2d',
    accuracy_within_3d: 'accuracy_within_3d',
    accuracy_within_5d: 'accuracy_within_5d',
    c_index: 'c_index',
    precision: 'precision',
    recall: 'recall',
    f1_score: 'f1_score',
    totalPredictions: 'totalPredictions',
    totalFires: 'totalFires',
    truePositives: 'truePositives',
    falsePositives: 'falsePositives',
    falseNegatives: 'falseNegatives',
    trueNegatives: 'trueNegatives',
    raw: 'raw',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    title: 'title',
    message: 'message',
    data: 'data',
    predictionId: 'predictionId',
    shtabelId: 'shtabelId',
    skladId: 'skladId',
    telegramSent: 'telegramSent',
    telegramMsgId: 'telegramMsgId',
    readAt: 'readAt',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    description: 'description',
    payload: 'payload',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'UploadStatus'
   */
  export type EnumUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadStatus'>
    


  /**
   * Reference to a field of type 'UploadStatus[]'
   */
  export type ListEnumUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ShtabelStatus'
   */
  export type EnumShtabelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShtabelStatus'>
    


  /**
   * Reference to a field of type 'ShtabelStatus[]'
   */
  export type ListEnumShtabelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShtabelStatus[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'ModelStatus'
   */
  export type EnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus'>
    


  /**
   * Reference to a field of type 'ModelStatus[]'
   */
  export type ListEnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lang?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    uploads?: UploadListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    lang?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploads?: UploadOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    userSettings?: UserSettingsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telegramId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lang?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    uploads?: UploadListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
  }, "id" | "telegramId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    lang?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    telegramId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    lang?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: IntFilter<"UserSettings"> | number
    userId?: IntFilter<"UserSettings"> | number
    notifyCritical?: BoolFilter<"UserSettings"> | boolean
    notifyHigh?: BoolFilter<"UserSettings"> | boolean
    notifyMedium?: BoolFilter<"UserSettings"> | boolean
    notifyLow?: BoolFilter<"UserSettings"> | boolean
    defaultSkladId?: IntNullableFilter<"UserSettings"> | number | null
    defaultView?: StringFilter<"UserSettings"> | string
    predictionHorizon?: IntFilter<"UserSettings"> | number
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyCritical?: SortOrder
    notifyHigh?: SortOrder
    notifyMedium?: SortOrder
    notifyLow?: SortOrder
    defaultSkladId?: SortOrderInput | SortOrder
    defaultView?: SortOrder
    predictionHorizon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    notifyCritical?: BoolFilter<"UserSettings"> | boolean
    notifyHigh?: BoolFilter<"UserSettings"> | boolean
    notifyMedium?: BoolFilter<"UserSettings"> | boolean
    notifyLow?: BoolFilter<"UserSettings"> | boolean
    defaultSkladId?: IntNullableFilter<"UserSettings"> | number | null
    defaultView?: StringFilter<"UserSettings"> | string
    predictionHorizon?: IntFilter<"UserSettings"> | number
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyCritical?: SortOrder
    notifyHigh?: SortOrder
    notifyMedium?: SortOrder
    notifyLow?: SortOrder
    defaultSkladId?: SortOrderInput | SortOrder
    defaultView?: SortOrder
    predictionHorizon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSettings"> | number
    userId?: IntWithAggregatesFilter<"UserSettings"> | number
    notifyCritical?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    notifyHigh?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    notifyMedium?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    notifyLow?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    defaultSkladId?: IntNullableWithAggregatesFilter<"UserSettings"> | number | null
    defaultView?: StringWithAggregatesFilter<"UserSettings"> | string
    predictionHorizon?: IntWithAggregatesFilter<"UserSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type UploadWhereInput = {
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    id?: IntFilter<"Upload"> | number
    filename?: StringFilter<"Upload"> | string
    fileType?: EnumFileTypeFilter<"Upload"> | $Enums.FileType
    uploadedBy?: IntNullableFilter<"Upload"> | number | null
    status?: EnumUploadStatusFilter<"Upload"> | $Enums.UploadStatus
    rowsTotal?: IntNullableFilter<"Upload"> | number | null
    rowsProcessed?: IntNullableFilter<"Upload"> | number | null
    rowsFailed?: IntNullableFilter<"Upload"> | number | null
    errors?: JsonNullableFilter<"Upload">
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
    updatedAt?: DateTimeFilter<"Upload"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UploadOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    rowsTotal?: SortOrderInput | SortOrder
    rowsProcessed?: SortOrderInput | SortOrder
    rowsFailed?: SortOrderInput | SortOrder
    errors?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UploadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    filename?: StringFilter<"Upload"> | string
    fileType?: EnumFileTypeFilter<"Upload"> | $Enums.FileType
    uploadedBy?: IntNullableFilter<"Upload"> | number | null
    status?: EnumUploadStatusFilter<"Upload"> | $Enums.UploadStatus
    rowsTotal?: IntNullableFilter<"Upload"> | number | null
    rowsProcessed?: IntNullableFilter<"Upload"> | number | null
    rowsFailed?: IntNullableFilter<"Upload"> | number | null
    errors?: JsonNullableFilter<"Upload">
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
    updatedAt?: DateTimeFilter<"Upload"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UploadOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    rowsTotal?: SortOrderInput | SortOrder
    rowsProcessed?: SortOrderInput | SortOrder
    rowsFailed?: SortOrderInput | SortOrder
    errors?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UploadCountOrderByAggregateInput
    _avg?: UploadAvgOrderByAggregateInput
    _max?: UploadMaxOrderByAggregateInput
    _min?: UploadMinOrderByAggregateInput
    _sum?: UploadSumOrderByAggregateInput
  }

  export type UploadScalarWhereWithAggregatesInput = {
    AND?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    OR?: UploadScalarWhereWithAggregatesInput[]
    NOT?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Upload"> | number
    filename?: StringWithAggregatesFilter<"Upload"> | string
    fileType?: EnumFileTypeWithAggregatesFilter<"Upload"> | $Enums.FileType
    uploadedBy?: IntNullableWithAggregatesFilter<"Upload"> | number | null
    status?: EnumUploadStatusWithAggregatesFilter<"Upload"> | $Enums.UploadStatus
    rowsTotal?: IntNullableWithAggregatesFilter<"Upload"> | number | null
    rowsProcessed?: IntNullableWithAggregatesFilter<"Upload"> | number | null
    rowsFailed?: IntNullableWithAggregatesFilter<"Upload"> | number | null
    errors?: JsonNullableWithAggregatesFilter<"Upload">
    metadata?: JsonNullableWithAggregatesFilter<"Upload">
    createdAt?: DateTimeWithAggregatesFilter<"Upload"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Upload"> | Date | string
  }

  export type SkladWhereInput = {
    AND?: SkladWhereInput | SkladWhereInput[]
    OR?: SkladWhereInput[]
    NOT?: SkladWhereInput | SkladWhereInput[]
    id?: IntFilter<"Sklad"> | number
    number?: IntFilter<"Sklad"> | number
    name?: StringNullableFilter<"Sklad"> | string | null
    locationRaw?: StringNullableFilter<"Sklad"> | string | null
    description?: StringNullableFilter<"Sklad"> | string | null
    createdAt?: DateTimeFilter<"Sklad"> | Date | string
    updatedAt?: DateTimeFilter<"Sklad"> | Date | string
    shtabels?: ShtabelListRelationFilter
    fires?: FireRecordListRelationFilter
    temps?: TempRecordListRelationFilter
    supplies?: SupplyListRelationFilter
    predictions?: PredictionListRelationFilter
    featureVectors?: FeatureVectorListRelationFilter
  }

  export type SkladOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    locationRaw?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shtabels?: ShtabelOrderByRelationAggregateInput
    fires?: FireRecordOrderByRelationAggregateInput
    temps?: TempRecordOrderByRelationAggregateInput
    supplies?: SupplyOrderByRelationAggregateInput
    predictions?: PredictionOrderByRelationAggregateInput
    featureVectors?: FeatureVectorOrderByRelationAggregateInput
  }

  export type SkladWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    number?: number
    AND?: SkladWhereInput | SkladWhereInput[]
    OR?: SkladWhereInput[]
    NOT?: SkladWhereInput | SkladWhereInput[]
    name?: StringNullableFilter<"Sklad"> | string | null
    locationRaw?: StringNullableFilter<"Sklad"> | string | null
    description?: StringNullableFilter<"Sklad"> | string | null
    createdAt?: DateTimeFilter<"Sklad"> | Date | string
    updatedAt?: DateTimeFilter<"Sklad"> | Date | string
    shtabels?: ShtabelListRelationFilter
    fires?: FireRecordListRelationFilter
    temps?: TempRecordListRelationFilter
    supplies?: SupplyListRelationFilter
    predictions?: PredictionListRelationFilter
    featureVectors?: FeatureVectorListRelationFilter
  }, "id" | "number">

  export type SkladOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    locationRaw?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkladCountOrderByAggregateInput
    _avg?: SkladAvgOrderByAggregateInput
    _max?: SkladMaxOrderByAggregateInput
    _min?: SkladMinOrderByAggregateInput
    _sum?: SkladSumOrderByAggregateInput
  }

  export type SkladScalarWhereWithAggregatesInput = {
    AND?: SkladScalarWhereWithAggregatesInput | SkladScalarWhereWithAggregatesInput[]
    OR?: SkladScalarWhereWithAggregatesInput[]
    NOT?: SkladScalarWhereWithAggregatesInput | SkladScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sklad"> | number
    number?: IntWithAggregatesFilter<"Sklad"> | number
    name?: StringNullableWithAggregatesFilter<"Sklad"> | string | null
    locationRaw?: StringNullableWithAggregatesFilter<"Sklad"> | string | null
    description?: StringNullableWithAggregatesFilter<"Sklad"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sklad"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sklad"> | Date | string
  }

  export type ShtabelWhereInput = {
    AND?: ShtabelWhereInput | ShtabelWhereInput[]
    OR?: ShtabelWhereInput[]
    NOT?: ShtabelWhereInput | ShtabelWhereInput[]
    id?: IntFilter<"Shtabel"> | number
    skladId?: IntFilter<"Shtabel"> | number
    label?: StringFilter<"Shtabel"> | string
    mark?: StringNullableFilter<"Shtabel"> | string | null
    formedAt?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    height_m?: FloatNullableFilter<"Shtabel"> | number | null
    width_m?: FloatNullableFilter<"Shtabel"> | number | null
    length_m?: FloatNullableFilter<"Shtabel"> | number | null
    mass_t?: FloatNullableFilter<"Shtabel"> | number | null
    status?: EnumShtabelStatusFilter<"Shtabel"> | $Enums.ShtabelStatus
    currentMass?: FloatNullableFilter<"Shtabel"> | number | null
    lastTemp?: FloatNullableFilter<"Shtabel"> | number | null
    lastTempDate?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    createdAt?: DateTimeFilter<"Shtabel"> | Date | string
    updatedAt?: DateTimeFilter<"Shtabel"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    supplies?: SupplyListRelationFilter
    temps?: TempRecordListRelationFilter
    predictions?: PredictionListRelationFilter
    fires?: FireRecordListRelationFilter
    featureVectors?: FeatureVectorListRelationFilter
  }

  export type ShtabelOrderByWithRelationInput = {
    id?: SortOrder
    skladId?: SortOrder
    label?: SortOrder
    mark?: SortOrderInput | SortOrder
    formedAt?: SortOrderInput | SortOrder
    height_m?: SortOrderInput | SortOrder
    width_m?: SortOrderInput | SortOrder
    length_m?: SortOrderInput | SortOrder
    mass_t?: SortOrderInput | SortOrder
    status?: SortOrder
    currentMass?: SortOrderInput | SortOrder
    lastTemp?: SortOrderInput | SortOrder
    lastTempDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    supplies?: SupplyOrderByRelationAggregateInput
    temps?: TempRecordOrderByRelationAggregateInput
    predictions?: PredictionOrderByRelationAggregateInput
    fires?: FireRecordOrderByRelationAggregateInput
    featureVectors?: FeatureVectorOrderByRelationAggregateInput
  }

  export type ShtabelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    skladId_label?: ShtabelSkladIdLabelCompoundUniqueInput
    AND?: ShtabelWhereInput | ShtabelWhereInput[]
    OR?: ShtabelWhereInput[]
    NOT?: ShtabelWhereInput | ShtabelWhereInput[]
    skladId?: IntFilter<"Shtabel"> | number
    label?: StringFilter<"Shtabel"> | string
    mark?: StringNullableFilter<"Shtabel"> | string | null
    formedAt?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    height_m?: FloatNullableFilter<"Shtabel"> | number | null
    width_m?: FloatNullableFilter<"Shtabel"> | number | null
    length_m?: FloatNullableFilter<"Shtabel"> | number | null
    mass_t?: FloatNullableFilter<"Shtabel"> | number | null
    status?: EnumShtabelStatusFilter<"Shtabel"> | $Enums.ShtabelStatus
    currentMass?: FloatNullableFilter<"Shtabel"> | number | null
    lastTemp?: FloatNullableFilter<"Shtabel"> | number | null
    lastTempDate?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    createdAt?: DateTimeFilter<"Shtabel"> | Date | string
    updatedAt?: DateTimeFilter<"Shtabel"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    supplies?: SupplyListRelationFilter
    temps?: TempRecordListRelationFilter
    predictions?: PredictionListRelationFilter
    fires?: FireRecordListRelationFilter
    featureVectors?: FeatureVectorListRelationFilter
  }, "id" | "skladId_label">

  export type ShtabelOrderByWithAggregationInput = {
    id?: SortOrder
    skladId?: SortOrder
    label?: SortOrder
    mark?: SortOrderInput | SortOrder
    formedAt?: SortOrderInput | SortOrder
    height_m?: SortOrderInput | SortOrder
    width_m?: SortOrderInput | SortOrder
    length_m?: SortOrderInput | SortOrder
    mass_t?: SortOrderInput | SortOrder
    status?: SortOrder
    currentMass?: SortOrderInput | SortOrder
    lastTemp?: SortOrderInput | SortOrder
    lastTempDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShtabelCountOrderByAggregateInput
    _avg?: ShtabelAvgOrderByAggregateInput
    _max?: ShtabelMaxOrderByAggregateInput
    _min?: ShtabelMinOrderByAggregateInput
    _sum?: ShtabelSumOrderByAggregateInput
  }

  export type ShtabelScalarWhereWithAggregatesInput = {
    AND?: ShtabelScalarWhereWithAggregatesInput | ShtabelScalarWhereWithAggregatesInput[]
    OR?: ShtabelScalarWhereWithAggregatesInput[]
    NOT?: ShtabelScalarWhereWithAggregatesInput | ShtabelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shtabel"> | number
    skladId?: IntWithAggregatesFilter<"Shtabel"> | number
    label?: StringWithAggregatesFilter<"Shtabel"> | string
    mark?: StringNullableWithAggregatesFilter<"Shtabel"> | string | null
    formedAt?: DateTimeNullableWithAggregatesFilter<"Shtabel"> | Date | string | null
    height_m?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    width_m?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    length_m?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    mass_t?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    status?: EnumShtabelStatusWithAggregatesFilter<"Shtabel"> | $Enums.ShtabelStatus
    currentMass?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    lastTemp?: FloatNullableWithAggregatesFilter<"Shtabel"> | number | null
    lastTempDate?: DateTimeNullableWithAggregatesFilter<"Shtabel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shtabel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shtabel"> | Date | string
  }

  export type SupplyWhereInput = {
    AND?: SupplyWhereInput | SupplyWhereInput[]
    OR?: SupplyWhereInput[]
    NOT?: SupplyWhereInput | SupplyWhereInput[]
    id?: IntFilter<"Supply"> | number
    skladId?: IntFilter<"Supply"> | number
    shtabelId?: IntFilter<"Supply"> | number
    dateIn?: DateTimeFilter<"Supply"> | Date | string
    mark?: StringNullableFilter<"Supply"> | string | null
    dateShip?: DateTimeNullableFilter<"Supply"> | Date | string | null
    toStorage_t?: FloatNullableFilter<"Supply"> | number | null
    toShip_t?: FloatNullableFilter<"Supply"> | number | null
    createdAt?: DateTimeFilter<"Supply"> | Date | string
    updatedAt?: DateTimeFilter<"Supply"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }

  export type SupplyOrderByWithRelationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    dateIn?: SortOrder
    mark?: SortOrderInput | SortOrder
    dateShip?: SortOrderInput | SortOrder
    toStorage_t?: SortOrderInput | SortOrder
    toShip_t?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    shtabel?: ShtabelOrderByWithRelationInput
  }

  export type SupplyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplyWhereInput | SupplyWhereInput[]
    OR?: SupplyWhereInput[]
    NOT?: SupplyWhereInput | SupplyWhereInput[]
    skladId?: IntFilter<"Supply"> | number
    shtabelId?: IntFilter<"Supply"> | number
    dateIn?: DateTimeFilter<"Supply"> | Date | string
    mark?: StringNullableFilter<"Supply"> | string | null
    dateShip?: DateTimeNullableFilter<"Supply"> | Date | string | null
    toStorage_t?: FloatNullableFilter<"Supply"> | number | null
    toShip_t?: FloatNullableFilter<"Supply"> | number | null
    createdAt?: DateTimeFilter<"Supply"> | Date | string
    updatedAt?: DateTimeFilter<"Supply"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }, "id">

  export type SupplyOrderByWithAggregationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    dateIn?: SortOrder
    mark?: SortOrderInput | SortOrder
    dateShip?: SortOrderInput | SortOrder
    toStorage_t?: SortOrderInput | SortOrder
    toShip_t?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplyCountOrderByAggregateInput
    _avg?: SupplyAvgOrderByAggregateInput
    _max?: SupplyMaxOrderByAggregateInput
    _min?: SupplyMinOrderByAggregateInput
    _sum?: SupplySumOrderByAggregateInput
  }

  export type SupplyScalarWhereWithAggregatesInput = {
    AND?: SupplyScalarWhereWithAggregatesInput | SupplyScalarWhereWithAggregatesInput[]
    OR?: SupplyScalarWhereWithAggregatesInput[]
    NOT?: SupplyScalarWhereWithAggregatesInput | SupplyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supply"> | number
    skladId?: IntWithAggregatesFilter<"Supply"> | number
    shtabelId?: IntWithAggregatesFilter<"Supply"> | number
    dateIn?: DateTimeWithAggregatesFilter<"Supply"> | Date | string
    mark?: StringNullableWithAggregatesFilter<"Supply"> | string | null
    dateShip?: DateTimeNullableWithAggregatesFilter<"Supply"> | Date | string | null
    toStorage_t?: FloatNullableWithAggregatesFilter<"Supply"> | number | null
    toShip_t?: FloatNullableWithAggregatesFilter<"Supply"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Supply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supply"> | Date | string
  }

  export type FireRecordWhereInput = {
    AND?: FireRecordWhereInput | FireRecordWhereInput[]
    OR?: FireRecordWhereInput[]
    NOT?: FireRecordWhereInput | FireRecordWhereInput[]
    id?: IntFilter<"FireRecord"> | number
    skladId?: IntFilter<"FireRecord"> | number
    shtabelId?: IntNullableFilter<"FireRecord"> | number | null
    reportDate?: DateTimeFilter<"FireRecord"> | Date | string
    mark?: StringNullableFilter<"FireRecord"> | string | null
    weight_t?: FloatNullableFilter<"FireRecord"> | number | null
    startDate?: DateTimeFilter<"FireRecord"> | Date | string
    endDate?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    formedAt?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    duration_hours?: FloatNullableFilter<"FireRecord"> | number | null
    damage_t?: FloatNullableFilter<"FireRecord"> | number | null
    createdAt?: DateTimeFilter<"FireRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FireRecord"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelNullableScalarRelationFilter, ShtabelWhereInput> | null
  }

  export type FireRecordOrderByWithRelationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    mark?: SortOrderInput | SortOrder
    weight_t?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    formedAt?: SortOrderInput | SortOrder
    duration_hours?: SortOrderInput | SortOrder
    damage_t?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    shtabel?: ShtabelOrderByWithRelationInput
  }

  export type FireRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FireRecordWhereInput | FireRecordWhereInput[]
    OR?: FireRecordWhereInput[]
    NOT?: FireRecordWhereInput | FireRecordWhereInput[]
    skladId?: IntFilter<"FireRecord"> | number
    shtabelId?: IntNullableFilter<"FireRecord"> | number | null
    reportDate?: DateTimeFilter<"FireRecord"> | Date | string
    mark?: StringNullableFilter<"FireRecord"> | string | null
    weight_t?: FloatNullableFilter<"FireRecord"> | number | null
    startDate?: DateTimeFilter<"FireRecord"> | Date | string
    endDate?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    formedAt?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    duration_hours?: FloatNullableFilter<"FireRecord"> | number | null
    damage_t?: FloatNullableFilter<"FireRecord"> | number | null
    createdAt?: DateTimeFilter<"FireRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FireRecord"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelNullableScalarRelationFilter, ShtabelWhereInput> | null
  }, "id">

  export type FireRecordOrderByWithAggregationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    mark?: SortOrderInput | SortOrder
    weight_t?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    formedAt?: SortOrderInput | SortOrder
    duration_hours?: SortOrderInput | SortOrder
    damage_t?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FireRecordCountOrderByAggregateInput
    _avg?: FireRecordAvgOrderByAggregateInput
    _max?: FireRecordMaxOrderByAggregateInput
    _min?: FireRecordMinOrderByAggregateInput
    _sum?: FireRecordSumOrderByAggregateInput
  }

  export type FireRecordScalarWhereWithAggregatesInput = {
    AND?: FireRecordScalarWhereWithAggregatesInput | FireRecordScalarWhereWithAggregatesInput[]
    OR?: FireRecordScalarWhereWithAggregatesInput[]
    NOT?: FireRecordScalarWhereWithAggregatesInput | FireRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FireRecord"> | number
    skladId?: IntWithAggregatesFilter<"FireRecord"> | number
    shtabelId?: IntNullableWithAggregatesFilter<"FireRecord"> | number | null
    reportDate?: DateTimeWithAggregatesFilter<"FireRecord"> | Date | string
    mark?: StringNullableWithAggregatesFilter<"FireRecord"> | string | null
    weight_t?: FloatNullableWithAggregatesFilter<"FireRecord"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"FireRecord"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"FireRecord"> | Date | string | null
    formedAt?: DateTimeNullableWithAggregatesFilter<"FireRecord"> | Date | string | null
    duration_hours?: FloatNullableWithAggregatesFilter<"FireRecord"> | number | null
    damage_t?: FloatNullableWithAggregatesFilter<"FireRecord"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"FireRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FireRecord"> | Date | string
  }

  export type TempRecordWhereInput = {
    AND?: TempRecordWhereInput | TempRecordWhereInput[]
    OR?: TempRecordWhereInput[]
    NOT?: TempRecordWhereInput | TempRecordWhereInput[]
    id?: IntFilter<"TempRecord"> | number
    skladId?: IntFilter<"TempRecord"> | number
    shtabelId?: IntFilter<"TempRecord"> | number
    mark?: StringNullableFilter<"TempRecord"> | string | null
    maxTemp?: FloatFilter<"TempRecord"> | number
    piket?: StringNullableFilter<"TempRecord"> | string | null
    recordDate?: DateTimeFilter<"TempRecord"> | Date | string
    shift?: FloatNullableFilter<"TempRecord"> | number | null
    riskLevel?: StringNullableFilter<"TempRecord"> | string | null
    createdAt?: DateTimeFilter<"TempRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TempRecord"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }

  export type TempRecordOrderByWithRelationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    mark?: SortOrderInput | SortOrder
    maxTemp?: SortOrder
    piket?: SortOrderInput | SortOrder
    recordDate?: SortOrder
    shift?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    shtabel?: ShtabelOrderByWithRelationInput
  }

  export type TempRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TempRecordWhereInput | TempRecordWhereInput[]
    OR?: TempRecordWhereInput[]
    NOT?: TempRecordWhereInput | TempRecordWhereInput[]
    skladId?: IntFilter<"TempRecord"> | number
    shtabelId?: IntFilter<"TempRecord"> | number
    mark?: StringNullableFilter<"TempRecord"> | string | null
    maxTemp?: FloatFilter<"TempRecord"> | number
    piket?: StringNullableFilter<"TempRecord"> | string | null
    recordDate?: DateTimeFilter<"TempRecord"> | Date | string
    shift?: FloatNullableFilter<"TempRecord"> | number | null
    riskLevel?: StringNullableFilter<"TempRecord"> | string | null
    createdAt?: DateTimeFilter<"TempRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TempRecord"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }, "id">

  export type TempRecordOrderByWithAggregationInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    mark?: SortOrderInput | SortOrder
    maxTemp?: SortOrder
    piket?: SortOrderInput | SortOrder
    recordDate?: SortOrder
    shift?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TempRecordCountOrderByAggregateInput
    _avg?: TempRecordAvgOrderByAggregateInput
    _max?: TempRecordMaxOrderByAggregateInput
    _min?: TempRecordMinOrderByAggregateInput
    _sum?: TempRecordSumOrderByAggregateInput
  }

  export type TempRecordScalarWhereWithAggregatesInput = {
    AND?: TempRecordScalarWhereWithAggregatesInput | TempRecordScalarWhereWithAggregatesInput[]
    OR?: TempRecordScalarWhereWithAggregatesInput[]
    NOT?: TempRecordScalarWhereWithAggregatesInput | TempRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TempRecord"> | number
    skladId?: IntWithAggregatesFilter<"TempRecord"> | number
    shtabelId?: IntWithAggregatesFilter<"TempRecord"> | number
    mark?: StringNullableWithAggregatesFilter<"TempRecord"> | string | null
    maxTemp?: FloatWithAggregatesFilter<"TempRecord"> | number
    piket?: StringNullableWithAggregatesFilter<"TempRecord"> | string | null
    recordDate?: DateTimeWithAggregatesFilter<"TempRecord"> | Date | string
    shift?: FloatNullableWithAggregatesFilter<"TempRecord"> | number | null
    riskLevel?: StringNullableWithAggregatesFilter<"TempRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TempRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TempRecord"> | Date | string
  }

  export type WeatherWhereInput = {
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    id?: IntFilter<"Weather"> | number
    ts?: DateTimeFilter<"Weather"> | Date | string
    t?: FloatNullableFilter<"Weather"> | number | null
    p?: FloatNullableFilter<"Weather"> | number | null
    humidity?: FloatNullableFilter<"Weather"> | number | null
    precipitation?: FloatNullableFilter<"Weather"> | number | null
    wind_dir?: IntNullableFilter<"Weather"> | number | null
    v_avg?: FloatNullableFilter<"Weather"> | number | null
    v_max?: FloatNullableFilter<"Weather"> | number | null
    cloudcover?: FloatNullableFilter<"Weather"> | number | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    weather_code?: IntNullableFilter<"Weather"> | number | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }

  export type WeatherOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    t?: SortOrderInput | SortOrder
    p?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    precipitation?: SortOrderInput | SortOrder
    wind_dir?: SortOrderInput | SortOrder
    v_avg?: SortOrderInput | SortOrder
    v_max?: SortOrderInput | SortOrder
    cloudcover?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    weather_code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ts?: Date | string
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    t?: FloatNullableFilter<"Weather"> | number | null
    p?: FloatNullableFilter<"Weather"> | number | null
    humidity?: FloatNullableFilter<"Weather"> | number | null
    precipitation?: FloatNullableFilter<"Weather"> | number | null
    wind_dir?: IntNullableFilter<"Weather"> | number | null
    v_avg?: FloatNullableFilter<"Weather"> | number | null
    v_max?: FloatNullableFilter<"Weather"> | number | null
    cloudcover?: FloatNullableFilter<"Weather"> | number | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    weather_code?: IntNullableFilter<"Weather"> | number | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }, "id" | "ts">

  export type WeatherOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    t?: SortOrderInput | SortOrder
    p?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    precipitation?: SortOrderInput | SortOrder
    wind_dir?: SortOrderInput | SortOrder
    v_avg?: SortOrderInput | SortOrder
    v_max?: SortOrderInput | SortOrder
    cloudcover?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    weather_code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeatherCountOrderByAggregateInput
    _avg?: WeatherAvgOrderByAggregateInput
    _max?: WeatherMaxOrderByAggregateInput
    _min?: WeatherMinOrderByAggregateInput
    _sum?: WeatherSumOrderByAggregateInput
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    OR?: WeatherScalarWhereWithAggregatesInput[]
    NOT?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Weather"> | number
    ts?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    t?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    p?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    humidity?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    precipitation?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    wind_dir?: IntNullableWithAggregatesFilter<"Weather"> | number | null
    v_avg?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    v_max?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    cloudcover?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    visibility?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    weather_code?: IntNullableWithAggregatesFilter<"Weather"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
  }

  export type FeatureVectorWhereInput = {
    AND?: FeatureVectorWhereInput | FeatureVectorWhereInput[]
    OR?: FeatureVectorWhereInput[]
    NOT?: FeatureVectorWhereInput | FeatureVectorWhereInput[]
    id?: IntFilter<"FeatureVector"> | number
    ts?: DateTimeFilter<"FeatureVector"> | Date | string
    skladId?: IntFilter<"FeatureVector"> | number
    shtabelId?: IntFilter<"FeatureVector"> | number
    features?: JsonFilter<"FeatureVector">
    modelVersion?: StringNullableFilter<"FeatureVector"> | string | null
    createdAt?: DateTimeFilter<"FeatureVector"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }

  export type FeatureVectorOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    features?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    shtabel?: ShtabelOrderByWithRelationInput
  }

  export type FeatureVectorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeatureVectorWhereInput | FeatureVectorWhereInput[]
    OR?: FeatureVectorWhereInput[]
    NOT?: FeatureVectorWhereInput | FeatureVectorWhereInput[]
    ts?: DateTimeFilter<"FeatureVector"> | Date | string
    skladId?: IntFilter<"FeatureVector"> | number
    shtabelId?: IntFilter<"FeatureVector"> | number
    features?: JsonFilter<"FeatureVector">
    modelVersion?: StringNullableFilter<"FeatureVector"> | string | null
    createdAt?: DateTimeFilter<"FeatureVector"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }, "id">

  export type FeatureVectorOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    features?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeatureVectorCountOrderByAggregateInput
    _avg?: FeatureVectorAvgOrderByAggregateInput
    _max?: FeatureVectorMaxOrderByAggregateInput
    _min?: FeatureVectorMinOrderByAggregateInput
    _sum?: FeatureVectorSumOrderByAggregateInput
  }

  export type FeatureVectorScalarWhereWithAggregatesInput = {
    AND?: FeatureVectorScalarWhereWithAggregatesInput | FeatureVectorScalarWhereWithAggregatesInput[]
    OR?: FeatureVectorScalarWhereWithAggregatesInput[]
    NOT?: FeatureVectorScalarWhereWithAggregatesInput | FeatureVectorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeatureVector"> | number
    ts?: DateTimeWithAggregatesFilter<"FeatureVector"> | Date | string
    skladId?: IntWithAggregatesFilter<"FeatureVector"> | number
    shtabelId?: IntWithAggregatesFilter<"FeatureVector"> | number
    features?: JsonWithAggregatesFilter<"FeatureVector">
    modelVersion?: StringNullableWithAggregatesFilter<"FeatureVector"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeatureVector"> | Date | string
  }

  export type PredictionWhereInput = {
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    id?: IntFilter<"Prediction"> | number
    ts?: DateTimeFilter<"Prediction"> | Date | string
    skladId?: IntFilter<"Prediction"> | number
    shtabelId?: IntFilter<"Prediction"> | number
    modelName?: StringFilter<"Prediction"> | string
    modelVersion?: StringNullableFilter<"Prediction"> | string | null
    predictedDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    probEvent?: FloatNullableFilter<"Prediction"> | number | null
    riskLevel?: EnumRiskLevelFilter<"Prediction"> | $Enums.RiskLevel
    horizonDays?: IntFilter<"Prediction"> | number
    intervalLow?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    intervalHigh?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    confidence?: FloatNullableFilter<"Prediction"> | number | null
    actualFireDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    accuracy_days?: FloatNullableFilter<"Prediction"> | number | null
    isAccurate?: BoolNullableFilter<"Prediction"> | boolean | null
    meta?: JsonNullableFilter<"Prediction">
    notified?: BoolFilter<"Prediction"> | boolean
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }

  export type PredictionOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    predictedDate?: SortOrderInput | SortOrder
    probEvent?: SortOrderInput | SortOrder
    riskLevel?: SortOrder
    horizonDays?: SortOrder
    intervalLow?: SortOrderInput | SortOrder
    intervalHigh?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    actualFireDate?: SortOrderInput | SortOrder
    accuracy_days?: SortOrderInput | SortOrder
    isAccurate?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    notified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sklad?: SkladOrderByWithRelationInput
    shtabel?: ShtabelOrderByWithRelationInput
  }

  export type PredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    ts?: DateTimeFilter<"Prediction"> | Date | string
    skladId?: IntFilter<"Prediction"> | number
    shtabelId?: IntFilter<"Prediction"> | number
    modelName?: StringFilter<"Prediction"> | string
    modelVersion?: StringNullableFilter<"Prediction"> | string | null
    predictedDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    probEvent?: FloatNullableFilter<"Prediction"> | number | null
    riskLevel?: EnumRiskLevelFilter<"Prediction"> | $Enums.RiskLevel
    horizonDays?: IntFilter<"Prediction"> | number
    intervalLow?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    intervalHigh?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    confidence?: FloatNullableFilter<"Prediction"> | number | null
    actualFireDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    accuracy_days?: FloatNullableFilter<"Prediction"> | number | null
    isAccurate?: BoolNullableFilter<"Prediction"> | boolean | null
    meta?: JsonNullableFilter<"Prediction">
    notified?: BoolFilter<"Prediction"> | boolean
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
    sklad?: XOR<SkladScalarRelationFilter, SkladWhereInput>
    shtabel?: XOR<ShtabelScalarRelationFilter, ShtabelWhereInput>
  }, "id">

  export type PredictionOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    predictedDate?: SortOrderInput | SortOrder
    probEvent?: SortOrderInput | SortOrder
    riskLevel?: SortOrder
    horizonDays?: SortOrder
    intervalLow?: SortOrderInput | SortOrder
    intervalHigh?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    actualFireDate?: SortOrderInput | SortOrder
    accuracy_days?: SortOrderInput | SortOrder
    isAccurate?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    notified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PredictionCountOrderByAggregateInput
    _avg?: PredictionAvgOrderByAggregateInput
    _max?: PredictionMaxOrderByAggregateInput
    _min?: PredictionMinOrderByAggregateInput
    _sum?: PredictionSumOrderByAggregateInput
  }

  export type PredictionScalarWhereWithAggregatesInput = {
    AND?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    OR?: PredictionScalarWhereWithAggregatesInput[]
    NOT?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prediction"> | number
    ts?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
    skladId?: IntWithAggregatesFilter<"Prediction"> | number
    shtabelId?: IntWithAggregatesFilter<"Prediction"> | number
    modelName?: StringWithAggregatesFilter<"Prediction"> | string
    modelVersion?: StringNullableWithAggregatesFilter<"Prediction"> | string | null
    predictedDate?: DateTimeNullableWithAggregatesFilter<"Prediction"> | Date | string | null
    probEvent?: FloatNullableWithAggregatesFilter<"Prediction"> | number | null
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"Prediction"> | $Enums.RiskLevel
    horizonDays?: IntWithAggregatesFilter<"Prediction"> | number
    intervalLow?: DateTimeNullableWithAggregatesFilter<"Prediction"> | Date | string | null
    intervalHigh?: DateTimeNullableWithAggregatesFilter<"Prediction"> | Date | string | null
    confidence?: FloatNullableWithAggregatesFilter<"Prediction"> | number | null
    actualFireDate?: DateTimeNullableWithAggregatesFilter<"Prediction"> | Date | string | null
    accuracy_days?: FloatNullableWithAggregatesFilter<"Prediction"> | number | null
    isAccurate?: BoolNullableWithAggregatesFilter<"Prediction"> | boolean | null
    meta?: JsonNullableWithAggregatesFilter<"Prediction">
    notified?: BoolWithAggregatesFilter<"Prediction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
  }

  export type ModelArtifactWhereInput = {
    AND?: ModelArtifactWhereInput | ModelArtifactWhereInput[]
    OR?: ModelArtifactWhereInput[]
    NOT?: ModelArtifactWhereInput | ModelArtifactWhereInput[]
    id?: IntFilter<"ModelArtifact"> | number
    name?: StringFilter<"ModelArtifact"> | string
    version?: StringFilter<"ModelArtifact"> | string
    status?: EnumModelStatusFilter<"ModelArtifact"> | $Enums.ModelStatus
    path?: StringFilter<"ModelArtifact"> | string
    fileSize?: BigIntNullableFilter<"ModelArtifact"> | bigint | number | null
    trainedAt?: DateTimeNullableFilter<"ModelArtifact"> | Date | string | null
    trainedBy?: StringNullableFilter<"ModelArtifact"> | string | null
    trainingData?: JsonNullableFilter<"ModelArtifact">
    hyperparams?: JsonNullableFilter<"ModelArtifact">
    trainMetrics?: JsonNullableFilter<"ModelArtifact">
    valMetrics?: JsonNullableFilter<"ModelArtifact">
    testMetrics?: JsonNullableFilter<"ModelArtifact">
    meta?: JsonNullableFilter<"ModelArtifact">
    createdAt?: DateTimeFilter<"ModelArtifact"> | Date | string
    updatedAt?: DateTimeFilter<"ModelArtifact"> | Date | string
  }

  export type ModelArtifactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    path?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    trainedAt?: SortOrderInput | SortOrder
    trainedBy?: SortOrderInput | SortOrder
    trainingData?: SortOrderInput | SortOrder
    hyperparams?: SortOrderInput | SortOrder
    trainMetrics?: SortOrderInput | SortOrder
    valMetrics?: SortOrderInput | SortOrder
    testMetrics?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_version?: ModelArtifactName_versionCompoundUniqueInput
    AND?: ModelArtifactWhereInput | ModelArtifactWhereInput[]
    OR?: ModelArtifactWhereInput[]
    NOT?: ModelArtifactWhereInput | ModelArtifactWhereInput[]
    name?: StringFilter<"ModelArtifact"> | string
    version?: StringFilter<"ModelArtifact"> | string
    status?: EnumModelStatusFilter<"ModelArtifact"> | $Enums.ModelStatus
    path?: StringFilter<"ModelArtifact"> | string
    fileSize?: BigIntNullableFilter<"ModelArtifact"> | bigint | number | null
    trainedAt?: DateTimeNullableFilter<"ModelArtifact"> | Date | string | null
    trainedBy?: StringNullableFilter<"ModelArtifact"> | string | null
    trainingData?: JsonNullableFilter<"ModelArtifact">
    hyperparams?: JsonNullableFilter<"ModelArtifact">
    trainMetrics?: JsonNullableFilter<"ModelArtifact">
    valMetrics?: JsonNullableFilter<"ModelArtifact">
    testMetrics?: JsonNullableFilter<"ModelArtifact">
    meta?: JsonNullableFilter<"ModelArtifact">
    createdAt?: DateTimeFilter<"ModelArtifact"> | Date | string
    updatedAt?: DateTimeFilter<"ModelArtifact"> | Date | string
  }, "id" | "name_version">

  export type ModelArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    path?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    trainedAt?: SortOrderInput | SortOrder
    trainedBy?: SortOrderInput | SortOrder
    trainingData?: SortOrderInput | SortOrder
    hyperparams?: SortOrderInput | SortOrder
    trainMetrics?: SortOrderInput | SortOrder
    valMetrics?: SortOrderInput | SortOrder
    testMetrics?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelArtifactCountOrderByAggregateInput
    _avg?: ModelArtifactAvgOrderByAggregateInput
    _max?: ModelArtifactMaxOrderByAggregateInput
    _min?: ModelArtifactMinOrderByAggregateInput
    _sum?: ModelArtifactSumOrderByAggregateInput
  }

  export type ModelArtifactScalarWhereWithAggregatesInput = {
    AND?: ModelArtifactScalarWhereWithAggregatesInput | ModelArtifactScalarWhereWithAggregatesInput[]
    OR?: ModelArtifactScalarWhereWithAggregatesInput[]
    NOT?: ModelArtifactScalarWhereWithAggregatesInput | ModelArtifactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModelArtifact"> | number
    name?: StringWithAggregatesFilter<"ModelArtifact"> | string
    version?: StringWithAggregatesFilter<"ModelArtifact"> | string
    status?: EnumModelStatusWithAggregatesFilter<"ModelArtifact"> | $Enums.ModelStatus
    path?: StringWithAggregatesFilter<"ModelArtifact"> | string
    fileSize?: BigIntNullableWithAggregatesFilter<"ModelArtifact"> | bigint | number | null
    trainedAt?: DateTimeNullableWithAggregatesFilter<"ModelArtifact"> | Date | string | null
    trainedBy?: StringNullableWithAggregatesFilter<"ModelArtifact"> | string | null
    trainingData?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    hyperparams?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    trainMetrics?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    valMetrics?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    testMetrics?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    meta?: JsonNullableWithAggregatesFilter<"ModelArtifact">
    createdAt?: DateTimeWithAggregatesFilter<"ModelArtifact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelArtifact"> | Date | string
  }

  export type MetricWhereInput = {
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    id?: IntFilter<"Metric"> | number
    modelName?: StringFilter<"Metric"> | string
    modelVersion?: StringNullableFilter<"Metric"> | string | null
    periodStart?: DateTimeFilter<"Metric"> | Date | string
    periodEnd?: DateTimeFilter<"Metric"> | Date | string
    mae_days?: FloatNullableFilter<"Metric"> | number | null
    rmse_days?: FloatNullableFilter<"Metric"> | number | null
    mape?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_2d?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_3d?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_5d?: FloatNullableFilter<"Metric"> | number | null
    c_index?: FloatNullableFilter<"Metric"> | number | null
    precision?: FloatNullableFilter<"Metric"> | number | null
    recall?: FloatNullableFilter<"Metric"> | number | null
    f1_score?: FloatNullableFilter<"Metric"> | number | null
    totalPredictions?: IntNullableFilter<"Metric"> | number | null
    totalFires?: IntNullableFilter<"Metric"> | number | null
    truePositives?: IntNullableFilter<"Metric"> | number | null
    falsePositives?: IntNullableFilter<"Metric"> | number | null
    falseNegatives?: IntNullableFilter<"Metric"> | number | null
    trueNegatives?: IntNullableFilter<"Metric"> | number | null
    raw?: JsonNullableFilter<"Metric">
    createdAt?: DateTimeFilter<"Metric"> | Date | string
    updatedAt?: DateTimeFilter<"Metric"> | Date | string
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    mae_days?: SortOrderInput | SortOrder
    rmse_days?: SortOrderInput | SortOrder
    mape?: SortOrderInput | SortOrder
    accuracy_within_2d?: SortOrderInput | SortOrder
    accuracy_within_3d?: SortOrderInput | SortOrder
    accuracy_within_5d?: SortOrderInput | SortOrder
    c_index?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1_score?: SortOrderInput | SortOrder
    totalPredictions?: SortOrderInput | SortOrder
    totalFires?: SortOrderInput | SortOrder
    truePositives?: SortOrderInput | SortOrder
    falsePositives?: SortOrderInput | SortOrder
    falseNegatives?: SortOrderInput | SortOrder
    trueNegatives?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    modelName?: StringFilter<"Metric"> | string
    modelVersion?: StringNullableFilter<"Metric"> | string | null
    periodStart?: DateTimeFilter<"Metric"> | Date | string
    periodEnd?: DateTimeFilter<"Metric"> | Date | string
    mae_days?: FloatNullableFilter<"Metric"> | number | null
    rmse_days?: FloatNullableFilter<"Metric"> | number | null
    mape?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_2d?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_3d?: FloatNullableFilter<"Metric"> | number | null
    accuracy_within_5d?: FloatNullableFilter<"Metric"> | number | null
    c_index?: FloatNullableFilter<"Metric"> | number | null
    precision?: FloatNullableFilter<"Metric"> | number | null
    recall?: FloatNullableFilter<"Metric"> | number | null
    f1_score?: FloatNullableFilter<"Metric"> | number | null
    totalPredictions?: IntNullableFilter<"Metric"> | number | null
    totalFires?: IntNullableFilter<"Metric"> | number | null
    truePositives?: IntNullableFilter<"Metric"> | number | null
    falsePositives?: IntNullableFilter<"Metric"> | number | null
    falseNegatives?: IntNullableFilter<"Metric"> | number | null
    trueNegatives?: IntNullableFilter<"Metric"> | number | null
    raw?: JsonNullableFilter<"Metric">
    createdAt?: DateTimeFilter<"Metric"> | Date | string
    updatedAt?: DateTimeFilter<"Metric"> | Date | string
  }, "id">

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    mae_days?: SortOrderInput | SortOrder
    rmse_days?: SortOrderInput | SortOrder
    mape?: SortOrderInput | SortOrder
    accuracy_within_2d?: SortOrderInput | SortOrder
    accuracy_within_3d?: SortOrderInput | SortOrder
    accuracy_within_5d?: SortOrderInput | SortOrder
    c_index?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1_score?: SortOrderInput | SortOrder
    totalPredictions?: SortOrderInput | SortOrder
    totalFires?: SortOrderInput | SortOrder
    truePositives?: SortOrderInput | SortOrder
    falsePositives?: SortOrderInput | SortOrder
    falseNegatives?: SortOrderInput | SortOrder
    trueNegatives?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    OR?: MetricScalarWhereWithAggregatesInput[]
    NOT?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Metric"> | number
    modelName?: StringWithAggregatesFilter<"Metric"> | string
    modelVersion?: StringNullableWithAggregatesFilter<"Metric"> | string | null
    periodStart?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    mae_days?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    rmse_days?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    mape?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    accuracy_within_2d?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    accuracy_within_3d?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    accuracy_within_5d?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    c_index?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    precision?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    recall?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    f1_score?: FloatNullableWithAggregatesFilter<"Metric"> | number | null
    totalPredictions?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    totalFires?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    truePositives?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    falsePositives?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    falseNegatives?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    trueNegatives?: IntNullableWithAggregatesFilter<"Metric"> | number | null
    raw?: JsonNullableWithAggregatesFilter<"Metric">
    createdAt?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    predictionId?: IntNullableFilter<"Notification"> | number | null
    shtabelId?: IntNullableFilter<"Notification"> | number | null
    skladId?: IntNullableFilter<"Notification"> | number | null
    telegramSent?: BoolFilter<"Notification"> | boolean
    telegramMsgId?: IntNullableFilter<"Notification"> | number | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    predictionId?: SortOrderInput | SortOrder
    shtabelId?: SortOrderInput | SortOrder
    skladId?: SortOrderInput | SortOrder
    telegramSent?: SortOrder
    telegramMsgId?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    predictionId?: IntNullableFilter<"Notification"> | number | null
    shtabelId?: IntNullableFilter<"Notification"> | number | null
    skladId?: IntNullableFilter<"Notification"> | number | null
    telegramSent?: BoolFilter<"Notification"> | boolean
    telegramMsgId?: IntNullableFilter<"Notification"> | number | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    predictionId?: SortOrderInput | SortOrder
    shtabelId?: SortOrderInput | SortOrder
    skladId?: SortOrderInput | SortOrder
    telegramSent?: SortOrder
    telegramMsgId?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    predictionId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    shtabelId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    skladId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    telegramSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    telegramMsgId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: IntNullableFilter<"AuditLog"> | number | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: IntNullableFilter<"AuditLog"> | number | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: IntFilter<"SystemSettings"> | number
    key?: StringFilter<"SystemSettings"> | string
    value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    category?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    category?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id" | "key">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSettings"> | number
    key?: StringWithAggregatesFilter<"SystemSettings"> | string
    value?: StringWithAggregatesFilter<"SystemSettings"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    category?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type UserCreateInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: number | null
    defaultView?: string
    predictionHorizon?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: number
    userId: number
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: number | null
    defaultView?: string
    predictionHorizon?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: number
    userId: number
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: number | null
    defaultView?: string
    predictionHorizon?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadCreateInput = {
    filename: string
    fileType: $Enums.FileType
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUploadsInput
  }

  export type UploadUncheckedCreateInput = {
    id?: number
    filename: string
    fileType: $Enums.FileType
    uploadedBy?: number | null
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUploadsNestedInput
  }

  export type UploadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadCreateManyInput = {
    id?: number
    filename: string
    fileType: $Enums.FileType
    uploadedBy?: number | null
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkladCreateInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type SkladCreateManyInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkladUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkladUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShtabelCreateInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelCreateManyInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShtabelUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShtabelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyCreateInput = {
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutSuppliesInput
    shtabel: ShtabelCreateNestedOneWithoutSuppliesInput
  }

  export type SupplyUncheckedCreateInput = {
    id?: number
    skladId: number
    shtabelId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyUpdateInput = {
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutSuppliesNestedInput
    shtabel?: ShtabelUpdateOneRequiredWithoutSuppliesNestedInput
  }

  export type SupplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyCreateManyInput = {
    id?: number
    skladId: number
    shtabelId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyUpdateManyMutationInput = {
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordCreateInput = {
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutFiresInput
    shtabel?: ShtabelCreateNestedOneWithoutFiresInput
  }

  export type FireRecordUncheckedCreateInput = {
    id?: number
    skladId: number
    shtabelId?: number | null
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordUpdateInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutFiresNestedInput
    shtabel?: ShtabelUpdateOneWithoutFiresNestedInput
  }

  export type FireRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordCreateManyInput = {
    id?: number
    skladId: number
    shtabelId?: number | null
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordUpdateManyMutationInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordCreateInput = {
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutTempsInput
    shtabel: ShtabelCreateNestedOneWithoutTempsInput
  }

  export type TempRecordUncheckedCreateInput = {
    id?: number
    skladId: number
    shtabelId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordUpdateInput = {
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutTempsNestedInput
    shtabel?: ShtabelUpdateOneRequiredWithoutTempsNestedInput
  }

  export type TempRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordCreateManyInput = {
    id?: number
    skladId: number
    shtabelId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordUpdateManyMutationInput = {
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateInput = {
    ts: Date | string
    t?: number | null
    p?: number | null
    humidity?: number | null
    precipitation?: number | null
    wind_dir?: number | null
    v_avg?: number | null
    v_max?: number | null
    cloudcover?: number | null
    visibility?: number | null
    weather_code?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUncheckedCreateInput = {
    id?: number
    ts: Date | string
    t?: number | null
    p?: number | null
    humidity?: number | null
    precipitation?: number | null
    wind_dir?: number | null
    v_avg?: number | null
    v_max?: number | null
    cloudcover?: number | null
    visibility?: number | null
    weather_code?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    t?: NullableFloatFieldUpdateOperationsInput | number | null
    p?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    precipitation?: NullableFloatFieldUpdateOperationsInput | number | null
    wind_dir?: NullableIntFieldUpdateOperationsInput | number | null
    v_avg?: NullableFloatFieldUpdateOperationsInput | number | null
    v_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cloudcover?: NullableFloatFieldUpdateOperationsInput | number | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    weather_code?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    t?: NullableFloatFieldUpdateOperationsInput | number | null
    p?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    precipitation?: NullableFloatFieldUpdateOperationsInput | number | null
    wind_dir?: NullableIntFieldUpdateOperationsInput | number | null
    v_avg?: NullableFloatFieldUpdateOperationsInput | number | null
    v_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cloudcover?: NullableFloatFieldUpdateOperationsInput | number | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    weather_code?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateManyInput = {
    id?: number
    ts: Date | string
    t?: number | null
    p?: number | null
    humidity?: number | null
    precipitation?: number | null
    wind_dir?: number | null
    v_avg?: number | null
    v_max?: number | null
    cloudcover?: number | null
    visibility?: number | null
    weather_code?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateManyMutationInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    t?: NullableFloatFieldUpdateOperationsInput | number | null
    p?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    precipitation?: NullableFloatFieldUpdateOperationsInput | number | null
    wind_dir?: NullableIntFieldUpdateOperationsInput | number | null
    v_avg?: NullableFloatFieldUpdateOperationsInput | number | null
    v_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cloudcover?: NullableFloatFieldUpdateOperationsInput | number | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    weather_code?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    t?: NullableFloatFieldUpdateOperationsInput | number | null
    p?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    precipitation?: NullableFloatFieldUpdateOperationsInput | number | null
    wind_dir?: NullableIntFieldUpdateOperationsInput | number | null
    v_avg?: NullableFloatFieldUpdateOperationsInput | number | null
    v_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cloudcover?: NullableFloatFieldUpdateOperationsInput | number | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    weather_code?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorCreateInput = {
    ts: Date | string
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
    sklad: SkladCreateNestedOneWithoutFeatureVectorsInput
    shtabel: ShtabelCreateNestedOneWithoutFeatureVectorsInput
  }

  export type FeatureVectorUncheckedCreateInput = {
    id?: number
    ts: Date | string
    skladId: number
    shtabelId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type FeatureVectorUpdateInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutFeatureVectorsNestedInput
    shtabel?: ShtabelUpdateOneRequiredWithoutFeatureVectorsNestedInput
  }

  export type FeatureVectorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorCreateManyInput = {
    id?: number
    ts: Date | string
    skladId: number
    shtabelId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type FeatureVectorUpdateManyMutationInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateInput = {
    ts: Date | string
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutPredictionsInput
    shtabel: ShtabelCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateInput = {
    id?: number
    ts: Date | string
    skladId: number
    shtabelId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionUpdateInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutPredictionsNestedInput
    shtabel?: ShtabelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateManyInput = {
    id?: number
    ts: Date | string
    skladId: number
    shtabelId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionUpdateManyMutationInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelArtifactCreateInput = {
    name: string
    version: string
    status?: $Enums.ModelStatus
    path: string
    fileSize?: bigint | number | null
    trainedAt?: Date | string | null
    trainedBy?: string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelArtifactUncheckedCreateInput = {
    id?: number
    name: string
    version: string
    status?: $Enums.ModelStatus
    path: string
    fileSize?: bigint | number | null
    trainedAt?: Date | string | null
    trainedBy?: string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelArtifactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    path?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelArtifactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    path?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelArtifactCreateManyInput = {
    id?: number
    name: string
    version: string
    status?: $Enums.ModelStatus
    path: string
    fileSize?: bigint | number | null
    trainedAt?: Date | string | null
    trainedBy?: string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelArtifactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    path?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelArtifactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    path?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trainingData?: NullableJsonNullValueInput | InputJsonValue
    hyperparams?: NullableJsonNullValueInput | InputJsonValue
    trainMetrics?: NullableJsonNullValueInput | InputJsonValue
    valMetrics?: NullableJsonNullValueInput | InputJsonValue
    testMetrics?: NullableJsonNullValueInput | InputJsonValue
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateInput = {
    modelName: string
    modelVersion?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    mae_days?: number | null
    rmse_days?: number | null
    mape?: number | null
    accuracy_within_2d?: number | null
    accuracy_within_3d?: number | null
    accuracy_within_5d?: number | null
    c_index?: number | null
    precision?: number | null
    recall?: number | null
    f1_score?: number | null
    totalPredictions?: number | null
    totalFires?: number | null
    truePositives?: number | null
    falsePositives?: number | null
    falseNegatives?: number | null
    trueNegatives?: number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUncheckedCreateInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    mae_days?: number | null
    rmse_days?: number | null
    mape?: number | null
    accuracy_within_2d?: number | null
    accuracy_within_3d?: number | null
    accuracy_within_5d?: number | null
    c_index?: number | null
    precision?: number | null
    recall?: number | null
    f1_score?: number | null
    totalPredictions?: number | null
    totalFires?: number | null
    truePositives?: number | null
    falsePositives?: number | null
    falseNegatives?: number | null
    trueNegatives?: number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUpdateInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    mae_days?: NullableFloatFieldUpdateOperationsInput | number | null
    rmse_days?: NullableFloatFieldUpdateOperationsInput | number | null
    mape?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_2d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_3d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_5d?: NullableFloatFieldUpdateOperationsInput | number | null
    c_index?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1_score?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPredictions?: NullableIntFieldUpdateOperationsInput | number | null
    totalFires?: NullableIntFieldUpdateOperationsInput | number | null
    truePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falsePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falseNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    trueNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    mae_days?: NullableFloatFieldUpdateOperationsInput | number | null
    rmse_days?: NullableFloatFieldUpdateOperationsInput | number | null
    mape?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_2d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_3d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_5d?: NullableFloatFieldUpdateOperationsInput | number | null
    c_index?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1_score?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPredictions?: NullableIntFieldUpdateOperationsInput | number | null
    totalFires?: NullableIntFieldUpdateOperationsInput | number | null
    truePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falsePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falseNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    trueNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateManyInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    mae_days?: number | null
    rmse_days?: number | null
    mape?: number | null
    accuracy_within_2d?: number | null
    accuracy_within_3d?: number | null
    accuracy_within_5d?: number | null
    c_index?: number | null
    precision?: number | null
    recall?: number | null
    f1_score?: number | null
    totalPredictions?: number | null
    totalFires?: number | null
    truePositives?: number | null
    falsePositives?: number | null
    falseNegatives?: number | null
    trueNegatives?: number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricUpdateManyMutationInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    mae_days?: NullableFloatFieldUpdateOperationsInput | number | null
    rmse_days?: NullableFloatFieldUpdateOperationsInput | number | null
    mape?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_2d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_3d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_5d?: NullableFloatFieldUpdateOperationsInput | number | null
    c_index?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1_score?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPredictions?: NullableIntFieldUpdateOperationsInput | number | null
    totalFires?: NullableIntFieldUpdateOperationsInput | number | null
    truePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falsePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falseNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    trueNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    mae_days?: NullableFloatFieldUpdateOperationsInput | number | null
    rmse_days?: NullableFloatFieldUpdateOperationsInput | number | null
    mape?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_2d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_3d?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracy_within_5d?: NullableFloatFieldUpdateOperationsInput | number | null
    c_index?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1_score?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPredictions?: NullableIntFieldUpdateOperationsInput | number | null
    totalFires?: NullableIntFieldUpdateOperationsInput | number | null
    truePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falsePositives?: NullableIntFieldUpdateOperationsInput | number | null
    falseNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    trueNegatives?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId?: number | null
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: number
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UploadListRelationFilter = {
    every?: UploadWhereInput
    some?: UploadWhereInput
    none?: UploadWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    lang?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    lang?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    lang?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyCritical?: SortOrder
    notifyHigh?: SortOrder
    notifyMedium?: SortOrder
    notifyLow?: SortOrder
    defaultSkladId?: SortOrder
    defaultView?: SortOrder
    predictionHorizon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultSkladId?: SortOrder
    predictionHorizon?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyCritical?: SortOrder
    notifyHigh?: SortOrder
    notifyMedium?: SortOrder
    notifyLow?: SortOrder
    defaultSkladId?: SortOrder
    defaultView?: SortOrder
    predictionHorizon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyCritical?: SortOrder
    notifyHigh?: SortOrder
    notifyMedium?: SortOrder
    notifyLow?: SortOrder
    defaultSkladId?: SortOrder
    defaultView?: SortOrder
    predictionHorizon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultSkladId?: SortOrder
    predictionHorizon?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type EnumUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusFilter<$PrismaModel> | $Enums.UploadStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UploadCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    status?: SortOrder
    rowsTotal?: SortOrder
    rowsProcessed?: SortOrder
    rowsFailed?: SortOrder
    errors?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadAvgOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
    rowsTotal?: SortOrder
    rowsProcessed?: SortOrder
    rowsFailed?: SortOrder
  }

  export type UploadMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    status?: SortOrder
    rowsTotal?: SortOrder
    rowsProcessed?: SortOrder
    rowsFailed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    status?: SortOrder
    rowsTotal?: SortOrder
    rowsProcessed?: SortOrder
    rowsFailed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadSumOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
    rowsTotal?: SortOrder
    rowsProcessed?: SortOrder
    rowsFailed?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type EnumUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.UploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumUploadStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ShtabelListRelationFilter = {
    every?: ShtabelWhereInput
    some?: ShtabelWhereInput
    none?: ShtabelWhereInput
  }

  export type FireRecordListRelationFilter = {
    every?: FireRecordWhereInput
    some?: FireRecordWhereInput
    none?: FireRecordWhereInput
  }

  export type TempRecordListRelationFilter = {
    every?: TempRecordWhereInput
    some?: TempRecordWhereInput
    none?: TempRecordWhereInput
  }

  export type SupplyListRelationFilter = {
    every?: SupplyWhereInput
    some?: SupplyWhereInput
    none?: SupplyWhereInput
  }

  export type PredictionListRelationFilter = {
    every?: PredictionWhereInput
    some?: PredictionWhereInput
    none?: PredictionWhereInput
  }

  export type FeatureVectorListRelationFilter = {
    every?: FeatureVectorWhereInput
    some?: FeatureVectorWhereInput
    none?: FeatureVectorWhereInput
  }

  export type ShtabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FireRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TempRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PredictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureVectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkladCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    name?: SortOrder
    locationRaw?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkladAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type SkladMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    name?: SortOrder
    locationRaw?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkladMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    name?: SortOrder
    locationRaw?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkladSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumShtabelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShtabelStatus | EnumShtabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShtabelStatusFilter<$PrismaModel> | $Enums.ShtabelStatus
  }

  export type SkladScalarRelationFilter = {
    is?: SkladWhereInput
    isNot?: SkladWhereInput
  }

  export type ShtabelSkladIdLabelCompoundUniqueInput = {
    skladId: number
    label: string
  }

  export type ShtabelCountOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    label?: SortOrder
    mark?: SortOrder
    formedAt?: SortOrder
    height_m?: SortOrder
    width_m?: SortOrder
    length_m?: SortOrder
    mass_t?: SortOrder
    status?: SortOrder
    currentMass?: SortOrder
    lastTemp?: SortOrder
    lastTempDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShtabelAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    height_m?: SortOrder
    width_m?: SortOrder
    length_m?: SortOrder
    mass_t?: SortOrder
    currentMass?: SortOrder
    lastTemp?: SortOrder
  }

  export type ShtabelMaxOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    label?: SortOrder
    mark?: SortOrder
    formedAt?: SortOrder
    height_m?: SortOrder
    width_m?: SortOrder
    length_m?: SortOrder
    mass_t?: SortOrder
    status?: SortOrder
    currentMass?: SortOrder
    lastTemp?: SortOrder
    lastTempDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShtabelMinOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    label?: SortOrder
    mark?: SortOrder
    formedAt?: SortOrder
    height_m?: SortOrder
    width_m?: SortOrder
    length_m?: SortOrder
    mass_t?: SortOrder
    status?: SortOrder
    currentMass?: SortOrder
    lastTemp?: SortOrder
    lastTempDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShtabelSumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    height_m?: SortOrder
    width_m?: SortOrder
    length_m?: SortOrder
    mass_t?: SortOrder
    currentMass?: SortOrder
    lastTemp?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumShtabelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShtabelStatus | EnumShtabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShtabelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShtabelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShtabelStatusFilter<$PrismaModel>
    _max?: NestedEnumShtabelStatusFilter<$PrismaModel>
  }

  export type ShtabelScalarRelationFilter = {
    is?: ShtabelWhereInput
    isNot?: ShtabelWhereInput
  }

  export type SupplyCountOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    dateIn?: SortOrder
    mark?: SortOrder
    dateShip?: SortOrder
    toStorage_t?: SortOrder
    toShip_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    toStorage_t?: SortOrder
    toShip_t?: SortOrder
  }

  export type SupplyMaxOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    dateIn?: SortOrder
    mark?: SortOrder
    dateShip?: SortOrder
    toStorage_t?: SortOrder
    toShip_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyMinOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    dateIn?: SortOrder
    mark?: SortOrder
    dateShip?: SortOrder
    toStorage_t?: SortOrder
    toShip_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplySumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    toStorage_t?: SortOrder
    toShip_t?: SortOrder
  }

  export type ShtabelNullableScalarRelationFilter = {
    is?: ShtabelWhereInput | null
    isNot?: ShtabelWhereInput | null
  }

  export type FireRecordCountOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    reportDate?: SortOrder
    mark?: SortOrder
    weight_t?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    formedAt?: SortOrder
    duration_hours?: SortOrder
    damage_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FireRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    weight_t?: SortOrder
    duration_hours?: SortOrder
    damage_t?: SortOrder
  }

  export type FireRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    reportDate?: SortOrder
    mark?: SortOrder
    weight_t?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    formedAt?: SortOrder
    duration_hours?: SortOrder
    damage_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FireRecordMinOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    reportDate?: SortOrder
    mark?: SortOrder
    weight_t?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    formedAt?: SortOrder
    duration_hours?: SortOrder
    damage_t?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FireRecordSumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    weight_t?: SortOrder
    duration_hours?: SortOrder
    damage_t?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TempRecordCountOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    mark?: SortOrder
    maxTemp?: SortOrder
    piket?: SortOrder
    recordDate?: SortOrder
    shift?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    maxTemp?: SortOrder
    shift?: SortOrder
  }

  export type TempRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    mark?: SortOrder
    maxTemp?: SortOrder
    piket?: SortOrder
    recordDate?: SortOrder
    shift?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempRecordMinOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    mark?: SortOrder
    maxTemp?: SortOrder
    piket?: SortOrder
    recordDate?: SortOrder
    shift?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempRecordSumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    maxTemp?: SortOrder
    shift?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type WeatherCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    t?: SortOrder
    p?: SortOrder
    humidity?: SortOrder
    precipitation?: SortOrder
    wind_dir?: SortOrder
    v_avg?: SortOrder
    v_max?: SortOrder
    cloudcover?: SortOrder
    visibility?: SortOrder
    weather_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherAvgOrderByAggregateInput = {
    id?: SortOrder
    t?: SortOrder
    p?: SortOrder
    humidity?: SortOrder
    precipitation?: SortOrder
    wind_dir?: SortOrder
    v_avg?: SortOrder
    v_max?: SortOrder
    cloudcover?: SortOrder
    visibility?: SortOrder
    weather_code?: SortOrder
  }

  export type WeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    t?: SortOrder
    p?: SortOrder
    humidity?: SortOrder
    precipitation?: SortOrder
    wind_dir?: SortOrder
    v_avg?: SortOrder
    v_max?: SortOrder
    cloudcover?: SortOrder
    visibility?: SortOrder
    weather_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    t?: SortOrder
    p?: SortOrder
    humidity?: SortOrder
    precipitation?: SortOrder
    wind_dir?: SortOrder
    v_avg?: SortOrder
    v_max?: SortOrder
    cloudcover?: SortOrder
    visibility?: SortOrder
    weather_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherSumOrderByAggregateInput = {
    id?: SortOrder
    t?: SortOrder
    p?: SortOrder
    humidity?: SortOrder
    precipitation?: SortOrder
    wind_dir?: SortOrder
    v_avg?: SortOrder
    v_max?: SortOrder
    cloudcover?: SortOrder
    visibility?: SortOrder
    weather_code?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeatureVectorCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    features?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type FeatureVectorAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
  }

  export type FeatureVectorMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type FeatureVectorMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type FeatureVectorSumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PredictionCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    predictedDate?: SortOrder
    probEvent?: SortOrder
    riskLevel?: SortOrder
    horizonDays?: SortOrder
    intervalLow?: SortOrder
    intervalHigh?: SortOrder
    confidence?: SortOrder
    actualFireDate?: SortOrder
    accuracy_days?: SortOrder
    isAccurate?: SortOrder
    meta?: SortOrder
    notified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionAvgOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    probEvent?: SortOrder
    horizonDays?: SortOrder
    confidence?: SortOrder
    accuracy_days?: SortOrder
  }

  export type PredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    predictedDate?: SortOrder
    probEvent?: SortOrder
    riskLevel?: SortOrder
    horizonDays?: SortOrder
    intervalLow?: SortOrder
    intervalHigh?: SortOrder
    confidence?: SortOrder
    actualFireDate?: SortOrder
    accuracy_days?: SortOrder
    isAccurate?: SortOrder
    notified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    predictedDate?: SortOrder
    probEvent?: SortOrder
    riskLevel?: SortOrder
    horizonDays?: SortOrder
    intervalLow?: SortOrder
    intervalHigh?: SortOrder
    confidence?: SortOrder
    actualFireDate?: SortOrder
    accuracy_days?: SortOrder
    isAccurate?: SortOrder
    notified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionSumOrderByAggregateInput = {
    id?: SortOrder
    skladId?: SortOrder
    shtabelId?: SortOrder
    probEvent?: SortOrder
    horizonDays?: SortOrder
    confidence?: SortOrder
    accuracy_days?: SortOrder
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ModelArtifactName_versionCompoundUniqueInput = {
    name: string
    version: string
  }

  export type ModelArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    path?: SortOrder
    fileSize?: SortOrder
    trainedAt?: SortOrder
    trainedBy?: SortOrder
    trainingData?: SortOrder
    hyperparams?: SortOrder
    trainMetrics?: SortOrder
    valMetrics?: SortOrder
    testMetrics?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelArtifactAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
  }

  export type ModelArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    path?: SortOrder
    fileSize?: SortOrder
    trainedAt?: SortOrder
    trainedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    path?: SortOrder
    fileSize?: SortOrder
    trainedAt?: SortOrder
    trainedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelArtifactSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    mae_days?: SortOrder
    rmse_days?: SortOrder
    mape?: SortOrder
    accuracy_within_2d?: SortOrder
    accuracy_within_3d?: SortOrder
    accuracy_within_5d?: SortOrder
    c_index?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1_score?: SortOrder
    totalPredictions?: SortOrder
    totalFires?: SortOrder
    truePositives?: SortOrder
    falsePositives?: SortOrder
    falseNegatives?: SortOrder
    trueNegatives?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    id?: SortOrder
    mae_days?: SortOrder
    rmse_days?: SortOrder
    mape?: SortOrder
    accuracy_within_2d?: SortOrder
    accuracy_within_3d?: SortOrder
    accuracy_within_5d?: SortOrder
    c_index?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1_score?: SortOrder
    totalPredictions?: SortOrder
    totalFires?: SortOrder
    truePositives?: SortOrder
    falsePositives?: SortOrder
    falseNegatives?: SortOrder
    trueNegatives?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    mae_days?: SortOrder
    rmse_days?: SortOrder
    mape?: SortOrder
    accuracy_within_2d?: SortOrder
    accuracy_within_3d?: SortOrder
    accuracy_within_5d?: SortOrder
    c_index?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1_score?: SortOrder
    totalPredictions?: SortOrder
    totalFires?: SortOrder
    truePositives?: SortOrder
    falsePositives?: SortOrder
    falseNegatives?: SortOrder
    trueNegatives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    mae_days?: SortOrder
    rmse_days?: SortOrder
    mape?: SortOrder
    accuracy_within_2d?: SortOrder
    accuracy_within_3d?: SortOrder
    accuracy_within_5d?: SortOrder
    c_index?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1_score?: SortOrder
    totalPredictions?: SortOrder
    totalFires?: SortOrder
    truePositives?: SortOrder
    falsePositives?: SortOrder
    falseNegatives?: SortOrder
    trueNegatives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    id?: SortOrder
    mae_days?: SortOrder
    rmse_days?: SortOrder
    mape?: SortOrder
    accuracy_within_2d?: SortOrder
    accuracy_within_3d?: SortOrder
    accuracy_within_5d?: SortOrder
    c_index?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1_score?: SortOrder
    totalPredictions?: SortOrder
    totalFires?: SortOrder
    truePositives?: SortOrder
    falsePositives?: SortOrder
    falseNegatives?: SortOrder
    trueNegatives?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    predictionId?: SortOrder
    shtabelId?: SortOrder
    skladId?: SortOrder
    telegramSent?: SortOrder
    telegramMsgId?: SortOrder
    readAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrder
    shtabelId?: SortOrder
    skladId?: SortOrder
    telegramMsgId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    message?: SortOrder
    predictionId?: SortOrder
    shtabelId?: SortOrder
    skladId?: SortOrder
    telegramSent?: SortOrder
    telegramMsgId?: SortOrder
    readAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    message?: SortOrder
    predictionId?: SortOrder
    shtabelId?: SortOrder
    skladId?: SortOrder
    telegramSent?: SortOrder
    telegramMsgId?: SortOrder
    readAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrder
    shtabelId?: SortOrder
    skladId?: SortOrder
    telegramMsgId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    payload?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UploadCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type UploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserCreateNestedOneWithoutUploadsInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type EnumUploadStatusFieldUpdateOperationsInput = {
    set?: $Enums.UploadStatus
  }

  export type UserUpdateOneWithoutUploadsNestedInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    upsert?: UserUpsertWithoutUploadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadsInput, UserUpdateWithoutUploadsInput>, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type ShtabelCreateNestedManyWithoutSkladInput = {
    create?: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput> | ShtabelCreateWithoutSkladInput[] | ShtabelUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: ShtabelCreateOrConnectWithoutSkladInput | ShtabelCreateOrConnectWithoutSkladInput[]
    createMany?: ShtabelCreateManySkladInputEnvelope
    connect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
  }

  export type FireRecordCreateNestedManyWithoutSkladInput = {
    create?: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput> | FireRecordCreateWithoutSkladInput[] | FireRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutSkladInput | FireRecordCreateOrConnectWithoutSkladInput[]
    createMany?: FireRecordCreateManySkladInputEnvelope
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
  }

  export type TempRecordCreateNestedManyWithoutSkladInput = {
    create?: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput> | TempRecordCreateWithoutSkladInput[] | TempRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutSkladInput | TempRecordCreateOrConnectWithoutSkladInput[]
    createMany?: TempRecordCreateManySkladInputEnvelope
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
  }

  export type SupplyCreateNestedManyWithoutSkladInput = {
    create?: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput> | SupplyCreateWithoutSkladInput[] | SupplyUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutSkladInput | SupplyCreateOrConnectWithoutSkladInput[]
    createMany?: SupplyCreateManySkladInputEnvelope
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
  }

  export type PredictionCreateNestedManyWithoutSkladInput = {
    create?: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput> | PredictionCreateWithoutSkladInput[] | PredictionUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutSkladInput | PredictionCreateOrConnectWithoutSkladInput[]
    createMany?: PredictionCreateManySkladInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type FeatureVectorCreateNestedManyWithoutSkladInput = {
    create?: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput> | FeatureVectorCreateWithoutSkladInput[] | FeatureVectorUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutSkladInput | FeatureVectorCreateOrConnectWithoutSkladInput[]
    createMany?: FeatureVectorCreateManySkladInputEnvelope
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
  }

  export type ShtabelUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput> | ShtabelCreateWithoutSkladInput[] | ShtabelUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: ShtabelCreateOrConnectWithoutSkladInput | ShtabelCreateOrConnectWithoutSkladInput[]
    createMany?: ShtabelCreateManySkladInputEnvelope
    connect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
  }

  export type FireRecordUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput> | FireRecordCreateWithoutSkladInput[] | FireRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutSkladInput | FireRecordCreateOrConnectWithoutSkladInput[]
    createMany?: FireRecordCreateManySkladInputEnvelope
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
  }

  export type TempRecordUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput> | TempRecordCreateWithoutSkladInput[] | TempRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutSkladInput | TempRecordCreateOrConnectWithoutSkladInput[]
    createMany?: TempRecordCreateManySkladInputEnvelope
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
  }

  export type SupplyUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput> | SupplyCreateWithoutSkladInput[] | SupplyUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutSkladInput | SupplyCreateOrConnectWithoutSkladInput[]
    createMany?: SupplyCreateManySkladInputEnvelope
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
  }

  export type PredictionUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput> | PredictionCreateWithoutSkladInput[] | PredictionUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutSkladInput | PredictionCreateOrConnectWithoutSkladInput[]
    createMany?: PredictionCreateManySkladInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type FeatureVectorUncheckedCreateNestedManyWithoutSkladInput = {
    create?: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput> | FeatureVectorCreateWithoutSkladInput[] | FeatureVectorUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutSkladInput | FeatureVectorCreateOrConnectWithoutSkladInput[]
    createMany?: FeatureVectorCreateManySkladInputEnvelope
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
  }

  export type ShtabelUpdateManyWithoutSkladNestedInput = {
    create?: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput> | ShtabelCreateWithoutSkladInput[] | ShtabelUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: ShtabelCreateOrConnectWithoutSkladInput | ShtabelCreateOrConnectWithoutSkladInput[]
    upsert?: ShtabelUpsertWithWhereUniqueWithoutSkladInput | ShtabelUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: ShtabelCreateManySkladInputEnvelope
    set?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    disconnect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    delete?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    connect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    update?: ShtabelUpdateWithWhereUniqueWithoutSkladInput | ShtabelUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: ShtabelUpdateManyWithWhereWithoutSkladInput | ShtabelUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: ShtabelScalarWhereInput | ShtabelScalarWhereInput[]
  }

  export type FireRecordUpdateManyWithoutSkladNestedInput = {
    create?: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput> | FireRecordCreateWithoutSkladInput[] | FireRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutSkladInput | FireRecordCreateOrConnectWithoutSkladInput[]
    upsert?: FireRecordUpsertWithWhereUniqueWithoutSkladInput | FireRecordUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: FireRecordCreateManySkladInputEnvelope
    set?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    disconnect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    delete?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    update?: FireRecordUpdateWithWhereUniqueWithoutSkladInput | FireRecordUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: FireRecordUpdateManyWithWhereWithoutSkladInput | FireRecordUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
  }

  export type TempRecordUpdateManyWithoutSkladNestedInput = {
    create?: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput> | TempRecordCreateWithoutSkladInput[] | TempRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutSkladInput | TempRecordCreateOrConnectWithoutSkladInput[]
    upsert?: TempRecordUpsertWithWhereUniqueWithoutSkladInput | TempRecordUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: TempRecordCreateManySkladInputEnvelope
    set?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    disconnect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    delete?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    update?: TempRecordUpdateWithWhereUniqueWithoutSkladInput | TempRecordUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: TempRecordUpdateManyWithWhereWithoutSkladInput | TempRecordUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
  }

  export type SupplyUpdateManyWithoutSkladNestedInput = {
    create?: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput> | SupplyCreateWithoutSkladInput[] | SupplyUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutSkladInput | SupplyCreateOrConnectWithoutSkladInput[]
    upsert?: SupplyUpsertWithWhereUniqueWithoutSkladInput | SupplyUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: SupplyCreateManySkladInputEnvelope
    set?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    disconnect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    delete?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    update?: SupplyUpdateWithWhereUniqueWithoutSkladInput | SupplyUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: SupplyUpdateManyWithWhereWithoutSkladInput | SupplyUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
  }

  export type PredictionUpdateManyWithoutSkladNestedInput = {
    create?: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput> | PredictionCreateWithoutSkladInput[] | PredictionUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutSkladInput | PredictionCreateOrConnectWithoutSkladInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutSkladInput | PredictionUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: PredictionCreateManySkladInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutSkladInput | PredictionUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutSkladInput | PredictionUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type FeatureVectorUpdateManyWithoutSkladNestedInput = {
    create?: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput> | FeatureVectorCreateWithoutSkladInput[] | FeatureVectorUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutSkladInput | FeatureVectorCreateOrConnectWithoutSkladInput[]
    upsert?: FeatureVectorUpsertWithWhereUniqueWithoutSkladInput | FeatureVectorUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: FeatureVectorCreateManySkladInputEnvelope
    set?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    disconnect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    delete?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    update?: FeatureVectorUpdateWithWhereUniqueWithoutSkladInput | FeatureVectorUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: FeatureVectorUpdateManyWithWhereWithoutSkladInput | FeatureVectorUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
  }

  export type ShtabelUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput> | ShtabelCreateWithoutSkladInput[] | ShtabelUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: ShtabelCreateOrConnectWithoutSkladInput | ShtabelCreateOrConnectWithoutSkladInput[]
    upsert?: ShtabelUpsertWithWhereUniqueWithoutSkladInput | ShtabelUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: ShtabelCreateManySkladInputEnvelope
    set?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    disconnect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    delete?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    connect?: ShtabelWhereUniqueInput | ShtabelWhereUniqueInput[]
    update?: ShtabelUpdateWithWhereUniqueWithoutSkladInput | ShtabelUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: ShtabelUpdateManyWithWhereWithoutSkladInput | ShtabelUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: ShtabelScalarWhereInput | ShtabelScalarWhereInput[]
  }

  export type FireRecordUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput> | FireRecordCreateWithoutSkladInput[] | FireRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutSkladInput | FireRecordCreateOrConnectWithoutSkladInput[]
    upsert?: FireRecordUpsertWithWhereUniqueWithoutSkladInput | FireRecordUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: FireRecordCreateManySkladInputEnvelope
    set?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    disconnect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    delete?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    update?: FireRecordUpdateWithWhereUniqueWithoutSkladInput | FireRecordUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: FireRecordUpdateManyWithWhereWithoutSkladInput | FireRecordUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
  }

  export type TempRecordUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput> | TempRecordCreateWithoutSkladInput[] | TempRecordUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutSkladInput | TempRecordCreateOrConnectWithoutSkladInput[]
    upsert?: TempRecordUpsertWithWhereUniqueWithoutSkladInput | TempRecordUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: TempRecordCreateManySkladInputEnvelope
    set?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    disconnect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    delete?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    update?: TempRecordUpdateWithWhereUniqueWithoutSkladInput | TempRecordUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: TempRecordUpdateManyWithWhereWithoutSkladInput | TempRecordUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
  }

  export type SupplyUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput> | SupplyCreateWithoutSkladInput[] | SupplyUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutSkladInput | SupplyCreateOrConnectWithoutSkladInput[]
    upsert?: SupplyUpsertWithWhereUniqueWithoutSkladInput | SupplyUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: SupplyCreateManySkladInputEnvelope
    set?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    disconnect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    delete?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    update?: SupplyUpdateWithWhereUniqueWithoutSkladInput | SupplyUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: SupplyUpdateManyWithWhereWithoutSkladInput | SupplyUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
  }

  export type PredictionUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput> | PredictionCreateWithoutSkladInput[] | PredictionUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutSkladInput | PredictionCreateOrConnectWithoutSkladInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutSkladInput | PredictionUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: PredictionCreateManySkladInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutSkladInput | PredictionUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutSkladInput | PredictionUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput = {
    create?: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput> | FeatureVectorCreateWithoutSkladInput[] | FeatureVectorUncheckedCreateWithoutSkladInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutSkladInput | FeatureVectorCreateOrConnectWithoutSkladInput[]
    upsert?: FeatureVectorUpsertWithWhereUniqueWithoutSkladInput | FeatureVectorUpsertWithWhereUniqueWithoutSkladInput[]
    createMany?: FeatureVectorCreateManySkladInputEnvelope
    set?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    disconnect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    delete?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    update?: FeatureVectorUpdateWithWhereUniqueWithoutSkladInput | FeatureVectorUpdateWithWhereUniqueWithoutSkladInput[]
    updateMany?: FeatureVectorUpdateManyWithWhereWithoutSkladInput | FeatureVectorUpdateManyWithWhereWithoutSkladInput[]
    deleteMany?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
  }

  export type SkladCreateNestedOneWithoutShtabelsInput = {
    create?: XOR<SkladCreateWithoutShtabelsInput, SkladUncheckedCreateWithoutShtabelsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutShtabelsInput
    connect?: SkladWhereUniqueInput
  }

  export type SupplyCreateNestedManyWithoutShtabelInput = {
    create?: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput> | SupplyCreateWithoutShtabelInput[] | SupplyUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutShtabelInput | SupplyCreateOrConnectWithoutShtabelInput[]
    createMany?: SupplyCreateManyShtabelInputEnvelope
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
  }

  export type TempRecordCreateNestedManyWithoutShtabelInput = {
    create?: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput> | TempRecordCreateWithoutShtabelInput[] | TempRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutShtabelInput | TempRecordCreateOrConnectWithoutShtabelInput[]
    createMany?: TempRecordCreateManyShtabelInputEnvelope
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
  }

  export type PredictionCreateNestedManyWithoutShtabelInput = {
    create?: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput> | PredictionCreateWithoutShtabelInput[] | PredictionUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutShtabelInput | PredictionCreateOrConnectWithoutShtabelInput[]
    createMany?: PredictionCreateManyShtabelInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type FireRecordCreateNestedManyWithoutShtabelInput = {
    create?: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput> | FireRecordCreateWithoutShtabelInput[] | FireRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutShtabelInput | FireRecordCreateOrConnectWithoutShtabelInput[]
    createMany?: FireRecordCreateManyShtabelInputEnvelope
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
  }

  export type FeatureVectorCreateNestedManyWithoutShtabelInput = {
    create?: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput> | FeatureVectorCreateWithoutShtabelInput[] | FeatureVectorUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutShtabelInput | FeatureVectorCreateOrConnectWithoutShtabelInput[]
    createMany?: FeatureVectorCreateManyShtabelInputEnvelope
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
  }

  export type SupplyUncheckedCreateNestedManyWithoutShtabelInput = {
    create?: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput> | SupplyCreateWithoutShtabelInput[] | SupplyUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutShtabelInput | SupplyCreateOrConnectWithoutShtabelInput[]
    createMany?: SupplyCreateManyShtabelInputEnvelope
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
  }

  export type TempRecordUncheckedCreateNestedManyWithoutShtabelInput = {
    create?: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput> | TempRecordCreateWithoutShtabelInput[] | TempRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutShtabelInput | TempRecordCreateOrConnectWithoutShtabelInput[]
    createMany?: TempRecordCreateManyShtabelInputEnvelope
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
  }

  export type PredictionUncheckedCreateNestedManyWithoutShtabelInput = {
    create?: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput> | PredictionCreateWithoutShtabelInput[] | PredictionUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutShtabelInput | PredictionCreateOrConnectWithoutShtabelInput[]
    createMany?: PredictionCreateManyShtabelInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type FireRecordUncheckedCreateNestedManyWithoutShtabelInput = {
    create?: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput> | FireRecordCreateWithoutShtabelInput[] | FireRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutShtabelInput | FireRecordCreateOrConnectWithoutShtabelInput[]
    createMany?: FireRecordCreateManyShtabelInputEnvelope
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
  }

  export type FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput = {
    create?: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput> | FeatureVectorCreateWithoutShtabelInput[] | FeatureVectorUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutShtabelInput | FeatureVectorCreateOrConnectWithoutShtabelInput[]
    createMany?: FeatureVectorCreateManyShtabelInputEnvelope
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumShtabelStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShtabelStatus
  }

  export type SkladUpdateOneRequiredWithoutShtabelsNestedInput = {
    create?: XOR<SkladCreateWithoutShtabelsInput, SkladUncheckedCreateWithoutShtabelsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutShtabelsInput
    upsert?: SkladUpsertWithoutShtabelsInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutShtabelsInput, SkladUpdateWithoutShtabelsInput>, SkladUncheckedUpdateWithoutShtabelsInput>
  }

  export type SupplyUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput> | SupplyCreateWithoutShtabelInput[] | SupplyUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutShtabelInput | SupplyCreateOrConnectWithoutShtabelInput[]
    upsert?: SupplyUpsertWithWhereUniqueWithoutShtabelInput | SupplyUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: SupplyCreateManyShtabelInputEnvelope
    set?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    disconnect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    delete?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    update?: SupplyUpdateWithWhereUniqueWithoutShtabelInput | SupplyUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: SupplyUpdateManyWithWhereWithoutShtabelInput | SupplyUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
  }

  export type TempRecordUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput> | TempRecordCreateWithoutShtabelInput[] | TempRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutShtabelInput | TempRecordCreateOrConnectWithoutShtabelInput[]
    upsert?: TempRecordUpsertWithWhereUniqueWithoutShtabelInput | TempRecordUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: TempRecordCreateManyShtabelInputEnvelope
    set?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    disconnect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    delete?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    update?: TempRecordUpdateWithWhereUniqueWithoutShtabelInput | TempRecordUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: TempRecordUpdateManyWithWhereWithoutShtabelInput | TempRecordUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
  }

  export type PredictionUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput> | PredictionCreateWithoutShtabelInput[] | PredictionUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutShtabelInput | PredictionCreateOrConnectWithoutShtabelInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutShtabelInput | PredictionUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: PredictionCreateManyShtabelInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutShtabelInput | PredictionUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutShtabelInput | PredictionUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type FireRecordUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput> | FireRecordCreateWithoutShtabelInput[] | FireRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutShtabelInput | FireRecordCreateOrConnectWithoutShtabelInput[]
    upsert?: FireRecordUpsertWithWhereUniqueWithoutShtabelInput | FireRecordUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: FireRecordCreateManyShtabelInputEnvelope
    set?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    disconnect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    delete?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    update?: FireRecordUpdateWithWhereUniqueWithoutShtabelInput | FireRecordUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: FireRecordUpdateManyWithWhereWithoutShtabelInput | FireRecordUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
  }

  export type FeatureVectorUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput> | FeatureVectorCreateWithoutShtabelInput[] | FeatureVectorUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutShtabelInput | FeatureVectorCreateOrConnectWithoutShtabelInput[]
    upsert?: FeatureVectorUpsertWithWhereUniqueWithoutShtabelInput | FeatureVectorUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: FeatureVectorCreateManyShtabelInputEnvelope
    set?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    disconnect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    delete?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    update?: FeatureVectorUpdateWithWhereUniqueWithoutShtabelInput | FeatureVectorUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: FeatureVectorUpdateManyWithWhereWithoutShtabelInput | FeatureVectorUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
  }

  export type SupplyUncheckedUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput> | SupplyCreateWithoutShtabelInput[] | SupplyUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: SupplyCreateOrConnectWithoutShtabelInput | SupplyCreateOrConnectWithoutShtabelInput[]
    upsert?: SupplyUpsertWithWhereUniqueWithoutShtabelInput | SupplyUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: SupplyCreateManyShtabelInputEnvelope
    set?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    disconnect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    delete?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    connect?: SupplyWhereUniqueInput | SupplyWhereUniqueInput[]
    update?: SupplyUpdateWithWhereUniqueWithoutShtabelInput | SupplyUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: SupplyUpdateManyWithWhereWithoutShtabelInput | SupplyUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
  }

  export type TempRecordUncheckedUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput> | TempRecordCreateWithoutShtabelInput[] | TempRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: TempRecordCreateOrConnectWithoutShtabelInput | TempRecordCreateOrConnectWithoutShtabelInput[]
    upsert?: TempRecordUpsertWithWhereUniqueWithoutShtabelInput | TempRecordUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: TempRecordCreateManyShtabelInputEnvelope
    set?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    disconnect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    delete?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    connect?: TempRecordWhereUniqueInput | TempRecordWhereUniqueInput[]
    update?: TempRecordUpdateWithWhereUniqueWithoutShtabelInput | TempRecordUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: TempRecordUpdateManyWithWhereWithoutShtabelInput | TempRecordUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
  }

  export type PredictionUncheckedUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput> | PredictionCreateWithoutShtabelInput[] | PredictionUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutShtabelInput | PredictionCreateOrConnectWithoutShtabelInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutShtabelInput | PredictionUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: PredictionCreateManyShtabelInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutShtabelInput | PredictionUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutShtabelInput | PredictionUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type FireRecordUncheckedUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput> | FireRecordCreateWithoutShtabelInput[] | FireRecordUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FireRecordCreateOrConnectWithoutShtabelInput | FireRecordCreateOrConnectWithoutShtabelInput[]
    upsert?: FireRecordUpsertWithWhereUniqueWithoutShtabelInput | FireRecordUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: FireRecordCreateManyShtabelInputEnvelope
    set?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    disconnect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    delete?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    connect?: FireRecordWhereUniqueInput | FireRecordWhereUniqueInput[]
    update?: FireRecordUpdateWithWhereUniqueWithoutShtabelInput | FireRecordUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: FireRecordUpdateManyWithWhereWithoutShtabelInput | FireRecordUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
  }

  export type FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput = {
    create?: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput> | FeatureVectorCreateWithoutShtabelInput[] | FeatureVectorUncheckedCreateWithoutShtabelInput[]
    connectOrCreate?: FeatureVectorCreateOrConnectWithoutShtabelInput | FeatureVectorCreateOrConnectWithoutShtabelInput[]
    upsert?: FeatureVectorUpsertWithWhereUniqueWithoutShtabelInput | FeatureVectorUpsertWithWhereUniqueWithoutShtabelInput[]
    createMany?: FeatureVectorCreateManyShtabelInputEnvelope
    set?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    disconnect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    delete?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    connect?: FeatureVectorWhereUniqueInput | FeatureVectorWhereUniqueInput[]
    update?: FeatureVectorUpdateWithWhereUniqueWithoutShtabelInput | FeatureVectorUpdateWithWhereUniqueWithoutShtabelInput[]
    updateMany?: FeatureVectorUpdateManyWithWhereWithoutShtabelInput | FeatureVectorUpdateManyWithWhereWithoutShtabelInput[]
    deleteMany?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
  }

  export type SkladCreateNestedOneWithoutSuppliesInput = {
    create?: XOR<SkladCreateWithoutSuppliesInput, SkladUncheckedCreateWithoutSuppliesInput>
    connectOrCreate?: SkladCreateOrConnectWithoutSuppliesInput
    connect?: SkladWhereUniqueInput
  }

  export type ShtabelCreateNestedOneWithoutSuppliesInput = {
    create?: XOR<ShtabelCreateWithoutSuppliesInput, ShtabelUncheckedCreateWithoutSuppliesInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutSuppliesInput
    connect?: ShtabelWhereUniqueInput
  }

  export type SkladUpdateOneRequiredWithoutSuppliesNestedInput = {
    create?: XOR<SkladCreateWithoutSuppliesInput, SkladUncheckedCreateWithoutSuppliesInput>
    connectOrCreate?: SkladCreateOrConnectWithoutSuppliesInput
    upsert?: SkladUpsertWithoutSuppliesInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutSuppliesInput, SkladUpdateWithoutSuppliesInput>, SkladUncheckedUpdateWithoutSuppliesInput>
  }

  export type ShtabelUpdateOneRequiredWithoutSuppliesNestedInput = {
    create?: XOR<ShtabelCreateWithoutSuppliesInput, ShtabelUncheckedCreateWithoutSuppliesInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutSuppliesInput
    upsert?: ShtabelUpsertWithoutSuppliesInput
    connect?: ShtabelWhereUniqueInput
    update?: XOR<XOR<ShtabelUpdateToOneWithWhereWithoutSuppliesInput, ShtabelUpdateWithoutSuppliesInput>, ShtabelUncheckedUpdateWithoutSuppliesInput>
  }

  export type SkladCreateNestedOneWithoutFiresInput = {
    create?: XOR<SkladCreateWithoutFiresInput, SkladUncheckedCreateWithoutFiresInput>
    connectOrCreate?: SkladCreateOrConnectWithoutFiresInput
    connect?: SkladWhereUniqueInput
  }

  export type ShtabelCreateNestedOneWithoutFiresInput = {
    create?: XOR<ShtabelCreateWithoutFiresInput, ShtabelUncheckedCreateWithoutFiresInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutFiresInput
    connect?: ShtabelWhereUniqueInput
  }

  export type SkladUpdateOneRequiredWithoutFiresNestedInput = {
    create?: XOR<SkladCreateWithoutFiresInput, SkladUncheckedCreateWithoutFiresInput>
    connectOrCreate?: SkladCreateOrConnectWithoutFiresInput
    upsert?: SkladUpsertWithoutFiresInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutFiresInput, SkladUpdateWithoutFiresInput>, SkladUncheckedUpdateWithoutFiresInput>
  }

  export type ShtabelUpdateOneWithoutFiresNestedInput = {
    create?: XOR<ShtabelCreateWithoutFiresInput, ShtabelUncheckedCreateWithoutFiresInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutFiresInput
    upsert?: ShtabelUpsertWithoutFiresInput
    disconnect?: ShtabelWhereInput | boolean
    delete?: ShtabelWhereInput | boolean
    connect?: ShtabelWhereUniqueInput
    update?: XOR<XOR<ShtabelUpdateToOneWithWhereWithoutFiresInput, ShtabelUpdateWithoutFiresInput>, ShtabelUncheckedUpdateWithoutFiresInput>
  }

  export type SkladCreateNestedOneWithoutTempsInput = {
    create?: XOR<SkladCreateWithoutTempsInput, SkladUncheckedCreateWithoutTempsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutTempsInput
    connect?: SkladWhereUniqueInput
  }

  export type ShtabelCreateNestedOneWithoutTempsInput = {
    create?: XOR<ShtabelCreateWithoutTempsInput, ShtabelUncheckedCreateWithoutTempsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutTempsInput
    connect?: ShtabelWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SkladUpdateOneRequiredWithoutTempsNestedInput = {
    create?: XOR<SkladCreateWithoutTempsInput, SkladUncheckedCreateWithoutTempsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutTempsInput
    upsert?: SkladUpsertWithoutTempsInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutTempsInput, SkladUpdateWithoutTempsInput>, SkladUncheckedUpdateWithoutTempsInput>
  }

  export type ShtabelUpdateOneRequiredWithoutTempsNestedInput = {
    create?: XOR<ShtabelCreateWithoutTempsInput, ShtabelUncheckedCreateWithoutTempsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutTempsInput
    upsert?: ShtabelUpsertWithoutTempsInput
    connect?: ShtabelWhereUniqueInput
    update?: XOR<XOR<ShtabelUpdateToOneWithWhereWithoutTempsInput, ShtabelUpdateWithoutTempsInput>, ShtabelUncheckedUpdateWithoutTempsInput>
  }

  export type SkladCreateNestedOneWithoutFeatureVectorsInput = {
    create?: XOR<SkladCreateWithoutFeatureVectorsInput, SkladUncheckedCreateWithoutFeatureVectorsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutFeatureVectorsInput
    connect?: SkladWhereUniqueInput
  }

  export type ShtabelCreateNestedOneWithoutFeatureVectorsInput = {
    create?: XOR<ShtabelCreateWithoutFeatureVectorsInput, ShtabelUncheckedCreateWithoutFeatureVectorsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutFeatureVectorsInput
    connect?: ShtabelWhereUniqueInput
  }

  export type SkladUpdateOneRequiredWithoutFeatureVectorsNestedInput = {
    create?: XOR<SkladCreateWithoutFeatureVectorsInput, SkladUncheckedCreateWithoutFeatureVectorsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutFeatureVectorsInput
    upsert?: SkladUpsertWithoutFeatureVectorsInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutFeatureVectorsInput, SkladUpdateWithoutFeatureVectorsInput>, SkladUncheckedUpdateWithoutFeatureVectorsInput>
  }

  export type ShtabelUpdateOneRequiredWithoutFeatureVectorsNestedInput = {
    create?: XOR<ShtabelCreateWithoutFeatureVectorsInput, ShtabelUncheckedCreateWithoutFeatureVectorsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutFeatureVectorsInput
    upsert?: ShtabelUpsertWithoutFeatureVectorsInput
    connect?: ShtabelWhereUniqueInput
    update?: XOR<XOR<ShtabelUpdateToOneWithWhereWithoutFeatureVectorsInput, ShtabelUpdateWithoutFeatureVectorsInput>, ShtabelUncheckedUpdateWithoutFeatureVectorsInput>
  }

  export type SkladCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<SkladCreateWithoutPredictionsInput, SkladUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutPredictionsInput
    connect?: SkladWhereUniqueInput
  }

  export type ShtabelCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<ShtabelCreateWithoutPredictionsInput, ShtabelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutPredictionsInput
    connect?: ShtabelWhereUniqueInput
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SkladUpdateOneRequiredWithoutPredictionsNestedInput = {
    create?: XOR<SkladCreateWithoutPredictionsInput, SkladUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: SkladCreateOrConnectWithoutPredictionsInput
    upsert?: SkladUpsertWithoutPredictionsInput
    connect?: SkladWhereUniqueInput
    update?: XOR<XOR<SkladUpdateToOneWithWhereWithoutPredictionsInput, SkladUpdateWithoutPredictionsInput>, SkladUncheckedUpdateWithoutPredictionsInput>
  }

  export type ShtabelUpdateOneRequiredWithoutPredictionsNestedInput = {
    create?: XOR<ShtabelCreateWithoutPredictionsInput, ShtabelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: ShtabelCreateOrConnectWithoutPredictionsInput
    upsert?: ShtabelUpsertWithoutPredictionsInput
    connect?: ShtabelWhereUniqueInput
    update?: XOR<XOR<ShtabelUpdateToOneWithWhereWithoutPredictionsInput, ShtabelUpdateWithoutPredictionsInput>, ShtabelUncheckedUpdateWithoutPredictionsInput>
  }

  export type EnumModelStatusFieldUpdateOperationsInput = {
    set?: $Enums.ModelStatus
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusFilter<$PrismaModel> | $Enums.UploadStatus
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.UploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumUploadStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumShtabelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShtabelStatus | EnumShtabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShtabelStatusFilter<$PrismaModel> | $Enums.ShtabelStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumShtabelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShtabelStatus | EnumShtabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShtabelStatus[] | ListEnumShtabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShtabelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShtabelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShtabelStatusFilter<$PrismaModel>
    _max?: NestedEnumShtabelStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type UploadCreateWithoutUserInput = {
    filename: string
    fileType: $Enums.FileType
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadUncheckedCreateWithoutUserInput = {
    id?: number
    filename: string
    fileType: $Enums.FileType
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadCreateOrConnectWithoutUserInput = {
    where: UploadWhereUniqueInput
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadCreateManyUserInputEnvelope = {
    data: UploadCreateManyUserInput | UploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: number | null
    defaultView?: string
    predictionHorizon?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: number
    notifyCritical?: boolean
    notifyHigh?: boolean
    notifyMedium?: boolean
    notifyLow?: boolean
    defaultSkladId?: number | null
    defaultView?: string
    predictionHorizon?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type UploadUpsertWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    update: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadUpdateWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    data: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
  }

  export type UploadUpdateManyWithWhereWithoutUserInput = {
    where: UploadScalarWhereInput
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyWithoutUserInput>
  }

  export type UploadScalarWhereInput = {
    AND?: UploadScalarWhereInput | UploadScalarWhereInput[]
    OR?: UploadScalarWhereInput[]
    NOT?: UploadScalarWhereInput | UploadScalarWhereInput[]
    id?: IntFilter<"Upload"> | number
    filename?: StringFilter<"Upload"> | string
    fileType?: EnumFileTypeFilter<"Upload"> | $Enums.FileType
    uploadedBy?: IntNullableFilter<"Upload"> | number | null
    status?: EnumUploadStatusFilter<"Upload"> | $Enums.UploadStatus
    rowsTotal?: IntNullableFilter<"Upload"> | number | null
    rowsProcessed?: IntNullableFilter<"Upload"> | number | null
    rowsFailed?: IntNullableFilter<"Upload"> | number | null
    errors?: JsonNullableFilter<"Upload">
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
    updatedAt?: DateTimeFilter<"Upload"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: IntNullableFilter<"AuditLog"> | number | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    payload?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    predictionId?: IntNullableFilter<"Notification"> | number | null
    shtabelId?: IntNullableFilter<"Notification"> | number | null
    skladId?: IntNullableFilter<"Notification"> | number | null
    telegramSent?: BoolFilter<"Notification"> | boolean
    telegramMsgId?: IntNullableFilter<"Notification"> | number | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notifyCritical?: BoolFieldUpdateOperationsInput | boolean
    notifyHigh?: BoolFieldUpdateOperationsInput | boolean
    notifyMedium?: BoolFieldUpdateOperationsInput | boolean
    notifyLow?: BoolFieldUpdateOperationsInput | boolean
    defaultSkladId?: NullableIntFieldUpdateOperationsInput | number | null
    defaultView?: StringFieldUpdateOperationsInput | string
    predictionHorizon?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserSettingsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUploadsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
  }

  export type UserUpsertWithoutUploadsInput = {
    update: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type UserUpdateWithoutUploadsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ShtabelCreateWithoutSkladInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutSkladInput = {
    id?: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutSkladInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput>
  }

  export type ShtabelCreateManySkladInputEnvelope = {
    data: ShtabelCreateManySkladInput | ShtabelCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type FireRecordCreateWithoutSkladInput = {
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabel?: ShtabelCreateNestedOneWithoutFiresInput
  }

  export type FireRecordUncheckedCreateWithoutSkladInput = {
    id?: number
    shtabelId?: number | null
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordCreateOrConnectWithoutSkladInput = {
    where: FireRecordWhereUniqueInput
    create: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput>
  }

  export type FireRecordCreateManySkladInputEnvelope = {
    data: FireRecordCreateManySkladInput | FireRecordCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type TempRecordCreateWithoutSkladInput = {
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabel: ShtabelCreateNestedOneWithoutTempsInput
  }

  export type TempRecordUncheckedCreateWithoutSkladInput = {
    id?: number
    shtabelId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordCreateOrConnectWithoutSkladInput = {
    where: TempRecordWhereUniqueInput
    create: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput>
  }

  export type TempRecordCreateManySkladInputEnvelope = {
    data: TempRecordCreateManySkladInput | TempRecordCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type SupplyCreateWithoutSkladInput = {
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabel: ShtabelCreateNestedOneWithoutSuppliesInput
  }

  export type SupplyUncheckedCreateWithoutSkladInput = {
    id?: number
    shtabelId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyCreateOrConnectWithoutSkladInput = {
    where: SupplyWhereUniqueInput
    create: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput>
  }

  export type SupplyCreateManySkladInputEnvelope = {
    data: SupplyCreateManySkladInput | SupplyCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type PredictionCreateWithoutSkladInput = {
    ts: Date | string
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabel: ShtabelCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateWithoutSkladInput = {
    id?: number
    ts: Date | string
    shtabelId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateOrConnectWithoutSkladInput = {
    where: PredictionWhereUniqueInput
    create: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput>
  }

  export type PredictionCreateManySkladInputEnvelope = {
    data: PredictionCreateManySkladInput | PredictionCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type FeatureVectorCreateWithoutSkladInput = {
    ts: Date | string
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
    shtabel: ShtabelCreateNestedOneWithoutFeatureVectorsInput
  }

  export type FeatureVectorUncheckedCreateWithoutSkladInput = {
    id?: number
    ts: Date | string
    shtabelId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type FeatureVectorCreateOrConnectWithoutSkladInput = {
    where: FeatureVectorWhereUniqueInput
    create: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput>
  }

  export type FeatureVectorCreateManySkladInputEnvelope = {
    data: FeatureVectorCreateManySkladInput | FeatureVectorCreateManySkladInput[]
    skipDuplicates?: boolean
  }

  export type ShtabelUpsertWithWhereUniqueWithoutSkladInput = {
    where: ShtabelWhereUniqueInput
    update: XOR<ShtabelUpdateWithoutSkladInput, ShtabelUncheckedUpdateWithoutSkladInput>
    create: XOR<ShtabelCreateWithoutSkladInput, ShtabelUncheckedCreateWithoutSkladInput>
  }

  export type ShtabelUpdateWithWhereUniqueWithoutSkladInput = {
    where: ShtabelWhereUniqueInput
    data: XOR<ShtabelUpdateWithoutSkladInput, ShtabelUncheckedUpdateWithoutSkladInput>
  }

  export type ShtabelUpdateManyWithWhereWithoutSkladInput = {
    where: ShtabelScalarWhereInput
    data: XOR<ShtabelUpdateManyMutationInput, ShtabelUncheckedUpdateManyWithoutSkladInput>
  }

  export type ShtabelScalarWhereInput = {
    AND?: ShtabelScalarWhereInput | ShtabelScalarWhereInput[]
    OR?: ShtabelScalarWhereInput[]
    NOT?: ShtabelScalarWhereInput | ShtabelScalarWhereInput[]
    id?: IntFilter<"Shtabel"> | number
    skladId?: IntFilter<"Shtabel"> | number
    label?: StringFilter<"Shtabel"> | string
    mark?: StringNullableFilter<"Shtabel"> | string | null
    formedAt?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    height_m?: FloatNullableFilter<"Shtabel"> | number | null
    width_m?: FloatNullableFilter<"Shtabel"> | number | null
    length_m?: FloatNullableFilter<"Shtabel"> | number | null
    mass_t?: FloatNullableFilter<"Shtabel"> | number | null
    status?: EnumShtabelStatusFilter<"Shtabel"> | $Enums.ShtabelStatus
    currentMass?: FloatNullableFilter<"Shtabel"> | number | null
    lastTemp?: FloatNullableFilter<"Shtabel"> | number | null
    lastTempDate?: DateTimeNullableFilter<"Shtabel"> | Date | string | null
    createdAt?: DateTimeFilter<"Shtabel"> | Date | string
    updatedAt?: DateTimeFilter<"Shtabel"> | Date | string
  }

  export type FireRecordUpsertWithWhereUniqueWithoutSkladInput = {
    where: FireRecordWhereUniqueInput
    update: XOR<FireRecordUpdateWithoutSkladInput, FireRecordUncheckedUpdateWithoutSkladInput>
    create: XOR<FireRecordCreateWithoutSkladInput, FireRecordUncheckedCreateWithoutSkladInput>
  }

  export type FireRecordUpdateWithWhereUniqueWithoutSkladInput = {
    where: FireRecordWhereUniqueInput
    data: XOR<FireRecordUpdateWithoutSkladInput, FireRecordUncheckedUpdateWithoutSkladInput>
  }

  export type FireRecordUpdateManyWithWhereWithoutSkladInput = {
    where: FireRecordScalarWhereInput
    data: XOR<FireRecordUpdateManyMutationInput, FireRecordUncheckedUpdateManyWithoutSkladInput>
  }

  export type FireRecordScalarWhereInput = {
    AND?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
    OR?: FireRecordScalarWhereInput[]
    NOT?: FireRecordScalarWhereInput | FireRecordScalarWhereInput[]
    id?: IntFilter<"FireRecord"> | number
    skladId?: IntFilter<"FireRecord"> | number
    shtabelId?: IntNullableFilter<"FireRecord"> | number | null
    reportDate?: DateTimeFilter<"FireRecord"> | Date | string
    mark?: StringNullableFilter<"FireRecord"> | string | null
    weight_t?: FloatNullableFilter<"FireRecord"> | number | null
    startDate?: DateTimeFilter<"FireRecord"> | Date | string
    endDate?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    formedAt?: DateTimeNullableFilter<"FireRecord"> | Date | string | null
    duration_hours?: FloatNullableFilter<"FireRecord"> | number | null
    damage_t?: FloatNullableFilter<"FireRecord"> | number | null
    createdAt?: DateTimeFilter<"FireRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FireRecord"> | Date | string
  }

  export type TempRecordUpsertWithWhereUniqueWithoutSkladInput = {
    where: TempRecordWhereUniqueInput
    update: XOR<TempRecordUpdateWithoutSkladInput, TempRecordUncheckedUpdateWithoutSkladInput>
    create: XOR<TempRecordCreateWithoutSkladInput, TempRecordUncheckedCreateWithoutSkladInput>
  }

  export type TempRecordUpdateWithWhereUniqueWithoutSkladInput = {
    where: TempRecordWhereUniqueInput
    data: XOR<TempRecordUpdateWithoutSkladInput, TempRecordUncheckedUpdateWithoutSkladInput>
  }

  export type TempRecordUpdateManyWithWhereWithoutSkladInput = {
    where: TempRecordScalarWhereInput
    data: XOR<TempRecordUpdateManyMutationInput, TempRecordUncheckedUpdateManyWithoutSkladInput>
  }

  export type TempRecordScalarWhereInput = {
    AND?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
    OR?: TempRecordScalarWhereInput[]
    NOT?: TempRecordScalarWhereInput | TempRecordScalarWhereInput[]
    id?: IntFilter<"TempRecord"> | number
    skladId?: IntFilter<"TempRecord"> | number
    shtabelId?: IntFilter<"TempRecord"> | number
    mark?: StringNullableFilter<"TempRecord"> | string | null
    maxTemp?: FloatFilter<"TempRecord"> | number
    piket?: StringNullableFilter<"TempRecord"> | string | null
    recordDate?: DateTimeFilter<"TempRecord"> | Date | string
    shift?: FloatNullableFilter<"TempRecord"> | number | null
    riskLevel?: StringNullableFilter<"TempRecord"> | string | null
    createdAt?: DateTimeFilter<"TempRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TempRecord"> | Date | string
  }

  export type SupplyUpsertWithWhereUniqueWithoutSkladInput = {
    where: SupplyWhereUniqueInput
    update: XOR<SupplyUpdateWithoutSkladInput, SupplyUncheckedUpdateWithoutSkladInput>
    create: XOR<SupplyCreateWithoutSkladInput, SupplyUncheckedCreateWithoutSkladInput>
  }

  export type SupplyUpdateWithWhereUniqueWithoutSkladInput = {
    where: SupplyWhereUniqueInput
    data: XOR<SupplyUpdateWithoutSkladInput, SupplyUncheckedUpdateWithoutSkladInput>
  }

  export type SupplyUpdateManyWithWhereWithoutSkladInput = {
    where: SupplyScalarWhereInput
    data: XOR<SupplyUpdateManyMutationInput, SupplyUncheckedUpdateManyWithoutSkladInput>
  }

  export type SupplyScalarWhereInput = {
    AND?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
    OR?: SupplyScalarWhereInput[]
    NOT?: SupplyScalarWhereInput | SupplyScalarWhereInput[]
    id?: IntFilter<"Supply"> | number
    skladId?: IntFilter<"Supply"> | number
    shtabelId?: IntFilter<"Supply"> | number
    dateIn?: DateTimeFilter<"Supply"> | Date | string
    mark?: StringNullableFilter<"Supply"> | string | null
    dateShip?: DateTimeNullableFilter<"Supply"> | Date | string | null
    toStorage_t?: FloatNullableFilter<"Supply"> | number | null
    toShip_t?: FloatNullableFilter<"Supply"> | number | null
    createdAt?: DateTimeFilter<"Supply"> | Date | string
    updatedAt?: DateTimeFilter<"Supply"> | Date | string
  }

  export type PredictionUpsertWithWhereUniqueWithoutSkladInput = {
    where: PredictionWhereUniqueInput
    update: XOR<PredictionUpdateWithoutSkladInput, PredictionUncheckedUpdateWithoutSkladInput>
    create: XOR<PredictionCreateWithoutSkladInput, PredictionUncheckedCreateWithoutSkladInput>
  }

  export type PredictionUpdateWithWhereUniqueWithoutSkladInput = {
    where: PredictionWhereUniqueInput
    data: XOR<PredictionUpdateWithoutSkladInput, PredictionUncheckedUpdateWithoutSkladInput>
  }

  export type PredictionUpdateManyWithWhereWithoutSkladInput = {
    where: PredictionScalarWhereInput
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyWithoutSkladInput>
  }

  export type PredictionScalarWhereInput = {
    AND?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
    OR?: PredictionScalarWhereInput[]
    NOT?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
    id?: IntFilter<"Prediction"> | number
    ts?: DateTimeFilter<"Prediction"> | Date | string
    skladId?: IntFilter<"Prediction"> | number
    shtabelId?: IntFilter<"Prediction"> | number
    modelName?: StringFilter<"Prediction"> | string
    modelVersion?: StringNullableFilter<"Prediction"> | string | null
    predictedDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    probEvent?: FloatNullableFilter<"Prediction"> | number | null
    riskLevel?: EnumRiskLevelFilter<"Prediction"> | $Enums.RiskLevel
    horizonDays?: IntFilter<"Prediction"> | number
    intervalLow?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    intervalHigh?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    confidence?: FloatNullableFilter<"Prediction"> | number | null
    actualFireDate?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    accuracy_days?: FloatNullableFilter<"Prediction"> | number | null
    isAccurate?: BoolNullableFilter<"Prediction"> | boolean | null
    meta?: JsonNullableFilter<"Prediction">
    notified?: BoolFilter<"Prediction"> | boolean
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
  }

  export type FeatureVectorUpsertWithWhereUniqueWithoutSkladInput = {
    where: FeatureVectorWhereUniqueInput
    update: XOR<FeatureVectorUpdateWithoutSkladInput, FeatureVectorUncheckedUpdateWithoutSkladInput>
    create: XOR<FeatureVectorCreateWithoutSkladInput, FeatureVectorUncheckedCreateWithoutSkladInput>
  }

  export type FeatureVectorUpdateWithWhereUniqueWithoutSkladInput = {
    where: FeatureVectorWhereUniqueInput
    data: XOR<FeatureVectorUpdateWithoutSkladInput, FeatureVectorUncheckedUpdateWithoutSkladInput>
  }

  export type FeatureVectorUpdateManyWithWhereWithoutSkladInput = {
    where: FeatureVectorScalarWhereInput
    data: XOR<FeatureVectorUpdateManyMutationInput, FeatureVectorUncheckedUpdateManyWithoutSkladInput>
  }

  export type FeatureVectorScalarWhereInput = {
    AND?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
    OR?: FeatureVectorScalarWhereInput[]
    NOT?: FeatureVectorScalarWhereInput | FeatureVectorScalarWhereInput[]
    id?: IntFilter<"FeatureVector"> | number
    ts?: DateTimeFilter<"FeatureVector"> | Date | string
    skladId?: IntFilter<"FeatureVector"> | number
    shtabelId?: IntFilter<"FeatureVector"> | number
    features?: JsonFilter<"FeatureVector">
    modelVersion?: StringNullableFilter<"FeatureVector"> | string | null
    createdAt?: DateTimeFilter<"FeatureVector"> | Date | string
  }

  export type SkladCreateWithoutShtabelsInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutShtabelsInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutShtabelsInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutShtabelsInput, SkladUncheckedCreateWithoutShtabelsInput>
  }

  export type SupplyCreateWithoutShtabelInput = {
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutSuppliesInput
  }

  export type SupplyUncheckedCreateWithoutShtabelInput = {
    id?: number
    skladId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyCreateOrConnectWithoutShtabelInput = {
    where: SupplyWhereUniqueInput
    create: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput>
  }

  export type SupplyCreateManyShtabelInputEnvelope = {
    data: SupplyCreateManyShtabelInput | SupplyCreateManyShtabelInput[]
    skipDuplicates?: boolean
  }

  export type TempRecordCreateWithoutShtabelInput = {
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutTempsInput
  }

  export type TempRecordUncheckedCreateWithoutShtabelInput = {
    id?: number
    skladId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordCreateOrConnectWithoutShtabelInput = {
    where: TempRecordWhereUniqueInput
    create: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput>
  }

  export type TempRecordCreateManyShtabelInputEnvelope = {
    data: TempRecordCreateManyShtabelInput | TempRecordCreateManyShtabelInput[]
    skipDuplicates?: boolean
  }

  export type PredictionCreateWithoutShtabelInput = {
    ts: Date | string
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateWithoutShtabelInput = {
    id?: number
    ts: Date | string
    skladId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateOrConnectWithoutShtabelInput = {
    where: PredictionWhereUniqueInput
    create: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput>
  }

  export type PredictionCreateManyShtabelInputEnvelope = {
    data: PredictionCreateManyShtabelInput | PredictionCreateManyShtabelInput[]
    skipDuplicates?: boolean
  }

  export type FireRecordCreateWithoutShtabelInput = {
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutFiresInput
  }

  export type FireRecordUncheckedCreateWithoutShtabelInput = {
    id?: number
    skladId: number
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordCreateOrConnectWithoutShtabelInput = {
    where: FireRecordWhereUniqueInput
    create: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput>
  }

  export type FireRecordCreateManyShtabelInputEnvelope = {
    data: FireRecordCreateManyShtabelInput | FireRecordCreateManyShtabelInput[]
    skipDuplicates?: boolean
  }

  export type FeatureVectorCreateWithoutShtabelInput = {
    ts: Date | string
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
    sklad: SkladCreateNestedOneWithoutFeatureVectorsInput
  }

  export type FeatureVectorUncheckedCreateWithoutShtabelInput = {
    id?: number
    ts: Date | string
    skladId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type FeatureVectorCreateOrConnectWithoutShtabelInput = {
    where: FeatureVectorWhereUniqueInput
    create: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput>
  }

  export type FeatureVectorCreateManyShtabelInputEnvelope = {
    data: FeatureVectorCreateManyShtabelInput | FeatureVectorCreateManyShtabelInput[]
    skipDuplicates?: boolean
  }

  export type SkladUpsertWithoutShtabelsInput = {
    update: XOR<SkladUpdateWithoutShtabelsInput, SkladUncheckedUpdateWithoutShtabelsInput>
    create: XOR<SkladCreateWithoutShtabelsInput, SkladUncheckedCreateWithoutShtabelsInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutShtabelsInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutShtabelsInput, SkladUncheckedUpdateWithoutShtabelsInput>
  }

  export type SkladUpdateWithoutShtabelsInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutShtabelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type SupplyUpsertWithWhereUniqueWithoutShtabelInput = {
    where: SupplyWhereUniqueInput
    update: XOR<SupplyUpdateWithoutShtabelInput, SupplyUncheckedUpdateWithoutShtabelInput>
    create: XOR<SupplyCreateWithoutShtabelInput, SupplyUncheckedCreateWithoutShtabelInput>
  }

  export type SupplyUpdateWithWhereUniqueWithoutShtabelInput = {
    where: SupplyWhereUniqueInput
    data: XOR<SupplyUpdateWithoutShtabelInput, SupplyUncheckedUpdateWithoutShtabelInput>
  }

  export type SupplyUpdateManyWithWhereWithoutShtabelInput = {
    where: SupplyScalarWhereInput
    data: XOR<SupplyUpdateManyMutationInput, SupplyUncheckedUpdateManyWithoutShtabelInput>
  }

  export type TempRecordUpsertWithWhereUniqueWithoutShtabelInput = {
    where: TempRecordWhereUniqueInput
    update: XOR<TempRecordUpdateWithoutShtabelInput, TempRecordUncheckedUpdateWithoutShtabelInput>
    create: XOR<TempRecordCreateWithoutShtabelInput, TempRecordUncheckedCreateWithoutShtabelInput>
  }

  export type TempRecordUpdateWithWhereUniqueWithoutShtabelInput = {
    where: TempRecordWhereUniqueInput
    data: XOR<TempRecordUpdateWithoutShtabelInput, TempRecordUncheckedUpdateWithoutShtabelInput>
  }

  export type TempRecordUpdateManyWithWhereWithoutShtabelInput = {
    where: TempRecordScalarWhereInput
    data: XOR<TempRecordUpdateManyMutationInput, TempRecordUncheckedUpdateManyWithoutShtabelInput>
  }

  export type PredictionUpsertWithWhereUniqueWithoutShtabelInput = {
    where: PredictionWhereUniqueInput
    update: XOR<PredictionUpdateWithoutShtabelInput, PredictionUncheckedUpdateWithoutShtabelInput>
    create: XOR<PredictionCreateWithoutShtabelInput, PredictionUncheckedCreateWithoutShtabelInput>
  }

  export type PredictionUpdateWithWhereUniqueWithoutShtabelInput = {
    where: PredictionWhereUniqueInput
    data: XOR<PredictionUpdateWithoutShtabelInput, PredictionUncheckedUpdateWithoutShtabelInput>
  }

  export type PredictionUpdateManyWithWhereWithoutShtabelInput = {
    where: PredictionScalarWhereInput
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyWithoutShtabelInput>
  }

  export type FireRecordUpsertWithWhereUniqueWithoutShtabelInput = {
    where: FireRecordWhereUniqueInput
    update: XOR<FireRecordUpdateWithoutShtabelInput, FireRecordUncheckedUpdateWithoutShtabelInput>
    create: XOR<FireRecordCreateWithoutShtabelInput, FireRecordUncheckedCreateWithoutShtabelInput>
  }

  export type FireRecordUpdateWithWhereUniqueWithoutShtabelInput = {
    where: FireRecordWhereUniqueInput
    data: XOR<FireRecordUpdateWithoutShtabelInput, FireRecordUncheckedUpdateWithoutShtabelInput>
  }

  export type FireRecordUpdateManyWithWhereWithoutShtabelInput = {
    where: FireRecordScalarWhereInput
    data: XOR<FireRecordUpdateManyMutationInput, FireRecordUncheckedUpdateManyWithoutShtabelInput>
  }

  export type FeatureVectorUpsertWithWhereUniqueWithoutShtabelInput = {
    where: FeatureVectorWhereUniqueInput
    update: XOR<FeatureVectorUpdateWithoutShtabelInput, FeatureVectorUncheckedUpdateWithoutShtabelInput>
    create: XOR<FeatureVectorCreateWithoutShtabelInput, FeatureVectorUncheckedCreateWithoutShtabelInput>
  }

  export type FeatureVectorUpdateWithWhereUniqueWithoutShtabelInput = {
    where: FeatureVectorWhereUniqueInput
    data: XOR<FeatureVectorUpdateWithoutShtabelInput, FeatureVectorUncheckedUpdateWithoutShtabelInput>
  }

  export type FeatureVectorUpdateManyWithWhereWithoutShtabelInput = {
    where: FeatureVectorScalarWhereInput
    data: XOR<FeatureVectorUpdateManyMutationInput, FeatureVectorUncheckedUpdateManyWithoutShtabelInput>
  }

  export type SkladCreateWithoutSuppliesInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutSuppliesInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutSuppliesInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutSuppliesInput, SkladUncheckedCreateWithoutSuppliesInput>
  }

  export type ShtabelCreateWithoutSuppliesInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutSuppliesInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutSuppliesInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutSuppliesInput, ShtabelUncheckedCreateWithoutSuppliesInput>
  }

  export type SkladUpsertWithoutSuppliesInput = {
    update: XOR<SkladUpdateWithoutSuppliesInput, SkladUncheckedUpdateWithoutSuppliesInput>
    create: XOR<SkladCreateWithoutSuppliesInput, SkladUncheckedCreateWithoutSuppliesInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutSuppliesInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutSuppliesInput, SkladUncheckedUpdateWithoutSuppliesInput>
  }

  export type SkladUpdateWithoutSuppliesInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutSuppliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type ShtabelUpsertWithoutSuppliesInput = {
    update: XOR<ShtabelUpdateWithoutSuppliesInput, ShtabelUncheckedUpdateWithoutSuppliesInput>
    create: XOR<ShtabelCreateWithoutSuppliesInput, ShtabelUncheckedCreateWithoutSuppliesInput>
    where?: ShtabelWhereInput
  }

  export type ShtabelUpdateToOneWithWhereWithoutSuppliesInput = {
    where?: ShtabelWhereInput
    data: XOR<ShtabelUpdateWithoutSuppliesInput, ShtabelUncheckedUpdateWithoutSuppliesInput>
  }

  export type ShtabelUpdateWithoutSuppliesInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutSuppliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type SkladCreateWithoutFiresInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutFiresInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutFiresInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutFiresInput, SkladUncheckedCreateWithoutFiresInput>
  }

  export type ShtabelCreateWithoutFiresInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutFiresInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutFiresInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutFiresInput, ShtabelUncheckedCreateWithoutFiresInput>
  }

  export type SkladUpsertWithoutFiresInput = {
    update: XOR<SkladUpdateWithoutFiresInput, SkladUncheckedUpdateWithoutFiresInput>
    create: XOR<SkladCreateWithoutFiresInput, SkladUncheckedCreateWithoutFiresInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutFiresInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutFiresInput, SkladUncheckedUpdateWithoutFiresInput>
  }

  export type SkladUpdateWithoutFiresInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutFiresInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type ShtabelUpsertWithoutFiresInput = {
    update: XOR<ShtabelUpdateWithoutFiresInput, ShtabelUncheckedUpdateWithoutFiresInput>
    create: XOR<ShtabelCreateWithoutFiresInput, ShtabelUncheckedCreateWithoutFiresInput>
    where?: ShtabelWhereInput
  }

  export type ShtabelUpdateToOneWithWhereWithoutFiresInput = {
    where?: ShtabelWhereInput
    data: XOR<ShtabelUpdateWithoutFiresInput, ShtabelUncheckedUpdateWithoutFiresInput>
  }

  export type ShtabelUpdateWithoutFiresInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutFiresInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type SkladCreateWithoutTempsInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutTempsInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutTempsInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutTempsInput, SkladUncheckedCreateWithoutTempsInput>
  }

  export type ShtabelCreateWithoutTempsInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutTempsInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutTempsInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutTempsInput, ShtabelUncheckedCreateWithoutTempsInput>
  }

  export type SkladUpsertWithoutTempsInput = {
    update: XOR<SkladUpdateWithoutTempsInput, SkladUncheckedUpdateWithoutTempsInput>
    create: XOR<SkladCreateWithoutTempsInput, SkladUncheckedCreateWithoutTempsInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutTempsInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutTempsInput, SkladUncheckedUpdateWithoutTempsInput>
  }

  export type SkladUpdateWithoutTempsInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type ShtabelUpsertWithoutTempsInput = {
    update: XOR<ShtabelUpdateWithoutTempsInput, ShtabelUncheckedUpdateWithoutTempsInput>
    create: XOR<ShtabelCreateWithoutTempsInput, ShtabelUncheckedCreateWithoutTempsInput>
    where?: ShtabelWhereInput
  }

  export type ShtabelUpdateToOneWithWhereWithoutTempsInput = {
    where?: ShtabelWhereInput
    data: XOR<ShtabelUpdateWithoutTempsInput, ShtabelUncheckedUpdateWithoutTempsInput>
  }

  export type ShtabelUpdateWithoutTempsInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type SkladCreateWithoutFeatureVectorsInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    predictions?: PredictionCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutFeatureVectorsInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutFeatureVectorsInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutFeatureVectorsInput, SkladUncheckedCreateWithoutFeatureVectorsInput>
  }

  export type ShtabelCreateWithoutFeatureVectorsInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    predictions?: PredictionCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutFeatureVectorsInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutFeatureVectorsInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutFeatureVectorsInput, ShtabelUncheckedCreateWithoutFeatureVectorsInput>
  }

  export type SkladUpsertWithoutFeatureVectorsInput = {
    update: XOR<SkladUpdateWithoutFeatureVectorsInput, SkladUncheckedUpdateWithoutFeatureVectorsInput>
    create: XOR<SkladCreateWithoutFeatureVectorsInput, SkladUncheckedCreateWithoutFeatureVectorsInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutFeatureVectorsInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutFeatureVectorsInput, SkladUncheckedUpdateWithoutFeatureVectorsInput>
  }

  export type SkladUpdateWithoutFeatureVectorsInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutFeatureVectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type ShtabelUpsertWithoutFeatureVectorsInput = {
    update: XOR<ShtabelUpdateWithoutFeatureVectorsInput, ShtabelUncheckedUpdateWithoutFeatureVectorsInput>
    create: XOR<ShtabelCreateWithoutFeatureVectorsInput, ShtabelUncheckedCreateWithoutFeatureVectorsInput>
    where?: ShtabelWhereInput
  }

  export type ShtabelUpdateToOneWithWhereWithoutFeatureVectorsInput = {
    where?: ShtabelWhereInput
    data: XOR<ShtabelUpdateWithoutFeatureVectorsInput, ShtabelUncheckedUpdateWithoutFeatureVectorsInput>
  }

  export type ShtabelUpdateWithoutFeatureVectorsInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutFeatureVectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type SkladCreateWithoutPredictionsInput = {
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelCreateNestedManyWithoutSkladInput
    fires?: FireRecordCreateNestedManyWithoutSkladInput
    temps?: TempRecordCreateNestedManyWithoutSkladInput
    supplies?: SupplyCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutSkladInput
  }

  export type SkladUncheckedCreateWithoutPredictionsInput = {
    id?: number
    number: number
    name?: string | null
    locationRaw?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shtabels?: ShtabelUncheckedCreateNestedManyWithoutSkladInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutSkladInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutSkladInput
    supplies?: SupplyUncheckedCreateNestedManyWithoutSkladInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutSkladInput
  }

  export type SkladCreateOrConnectWithoutPredictionsInput = {
    where: SkladWhereUniqueInput
    create: XOR<SkladCreateWithoutPredictionsInput, SkladUncheckedCreateWithoutPredictionsInput>
  }

  export type ShtabelCreateWithoutPredictionsInput = {
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sklad: SkladCreateNestedOneWithoutShtabelsInput
    supplies?: SupplyCreateNestedManyWithoutShtabelInput
    temps?: TempRecordCreateNestedManyWithoutShtabelInput
    fires?: FireRecordCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelUncheckedCreateWithoutPredictionsInput = {
    id?: number
    skladId: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplies?: SupplyUncheckedCreateNestedManyWithoutShtabelInput
    temps?: TempRecordUncheckedCreateNestedManyWithoutShtabelInput
    fires?: FireRecordUncheckedCreateNestedManyWithoutShtabelInput
    featureVectors?: FeatureVectorUncheckedCreateNestedManyWithoutShtabelInput
  }

  export type ShtabelCreateOrConnectWithoutPredictionsInput = {
    where: ShtabelWhereUniqueInput
    create: XOR<ShtabelCreateWithoutPredictionsInput, ShtabelUncheckedCreateWithoutPredictionsInput>
  }

  export type SkladUpsertWithoutPredictionsInput = {
    update: XOR<SkladUpdateWithoutPredictionsInput, SkladUncheckedUpdateWithoutPredictionsInput>
    create: XOR<SkladCreateWithoutPredictionsInput, SkladUncheckedCreateWithoutPredictionsInput>
    where?: SkladWhereInput
  }

  export type SkladUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: SkladWhereInput
    data: XOR<SkladUpdateWithoutPredictionsInput, SkladUncheckedUpdateWithoutPredictionsInput>
  }

  export type SkladUpdateWithoutPredictionsInput = {
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutSkladNestedInput
  }

  export type SkladUncheckedUpdateWithoutPredictionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    locationRaw?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabels?: ShtabelUncheckedUpdateManyWithoutSkladNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutSkladNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutSkladNestedInput
    supplies?: SupplyUncheckedUpdateManyWithoutSkladNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutSkladNestedInput
  }

  export type ShtabelUpsertWithoutPredictionsInput = {
    update: XOR<ShtabelUpdateWithoutPredictionsInput, ShtabelUncheckedUpdateWithoutPredictionsInput>
    create: XOR<ShtabelCreateWithoutPredictionsInput, ShtabelUncheckedCreateWithoutPredictionsInput>
    where?: ShtabelWhereInput
  }

  export type ShtabelUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: ShtabelWhereInput
    data: XOR<ShtabelUpdateWithoutPredictionsInput, ShtabelUncheckedUpdateWithoutPredictionsInput>
  }

  export type ShtabelUpdateWithoutPredictionsInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutShtabelsNestedInput
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutPredictionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    lang?: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lang?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UploadCreateManyUserInput = {
    id?: number
    filename: string
    fileType: $Enums.FileType
    status?: $Enums.UploadStatus
    rowsTotal?: number | null
    rowsProcessed?: number | null
    rowsFailed?: number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: $Enums.AuditAction
    resource?: string | null
    resourceId?: number | null
    description?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: number | null
    shtabelId?: number | null
    skladId?: number | null
    telegramSent?: boolean
    telegramMsgId?: number | null
    readAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadUpdateWithoutUserInput = {
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    rowsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    rowsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    rowsFailed?: NullableIntFieldUpdateOperationsInput | number | null
    errors?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    predictionId?: NullableIntFieldUpdateOperationsInput | number | null
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    skladId?: NullableIntFieldUpdateOperationsInput | number | null
    telegramSent?: BoolFieldUpdateOperationsInput | boolean
    telegramMsgId?: NullableIntFieldUpdateOperationsInput | number | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShtabelCreateManySkladInput = {
    id?: number
    label: string
    mark?: string | null
    formedAt?: Date | string | null
    height_m?: number | null
    width_m?: number | null
    length_m?: number | null
    mass_t?: number | null
    status?: $Enums.ShtabelStatus
    currentMass?: number | null
    lastTemp?: number | null
    lastTempDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordCreateManySkladInput = {
    id?: number
    shtabelId?: number | null
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordCreateManySkladInput = {
    id?: number
    shtabelId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyCreateManySkladInput = {
    id?: number
    shtabelId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateManySkladInput = {
    id?: number
    ts: Date | string
    shtabelId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureVectorCreateManySkladInput = {
    id?: number
    ts: Date | string
    shtabelId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type ShtabelUpdateWithoutSkladInput = {
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplies?: SupplyUncheckedUpdateManyWithoutShtabelNestedInput
    temps?: TempRecordUncheckedUpdateManyWithoutShtabelNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutShtabelNestedInput
    fires?: FireRecordUncheckedUpdateManyWithoutShtabelNestedInput
    featureVectors?: FeatureVectorUncheckedUpdateManyWithoutShtabelNestedInput
  }

  export type ShtabelUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height_m?: NullableFloatFieldUpdateOperationsInput | number | null
    width_m?: NullableFloatFieldUpdateOperationsInput | number | null
    length_m?: NullableFloatFieldUpdateOperationsInput | number | null
    mass_t?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumShtabelStatusFieldUpdateOperationsInput | $Enums.ShtabelStatus
    currentMass?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTempDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordUpdateWithoutSkladInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabel?: ShtabelUpdateOneWithoutFiresNestedInput
  }

  export type FireRecordUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordUpdateWithoutSkladInput = {
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabel?: ShtabelUpdateOneRequiredWithoutTempsNestedInput
  }

  export type TempRecordUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyUpdateWithoutSkladInput = {
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabel?: ShtabelUpdateOneRequiredWithoutSuppliesNestedInput
  }

  export type SupplyUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    shtabelId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUpdateWithoutSkladInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabel?: ShtabelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabelId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabelId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorUpdateWithoutSkladInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabel?: ShtabelUpdateOneRequiredWithoutFeatureVectorsNestedInput
  }

  export type FeatureVectorUncheckedUpdateWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabelId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorUncheckedUpdateManyWithoutSkladInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    shtabelId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyCreateManyShtabelInput = {
    id?: number
    skladId: number
    dateIn: Date | string
    mark?: string | null
    dateShip?: Date | string | null
    toStorage_t?: number | null
    toShip_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempRecordCreateManyShtabelInput = {
    id?: number
    skladId: number
    mark?: string | null
    maxTemp: number
    piket?: string | null
    recordDate: Date | string
    shift?: number | null
    riskLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateManyShtabelInput = {
    id?: number
    ts: Date | string
    skladId: number
    modelName: string
    modelVersion?: string | null
    predictedDate?: Date | string | null
    probEvent?: number | null
    riskLevel: $Enums.RiskLevel
    horizonDays?: number
    intervalLow?: Date | string | null
    intervalHigh?: Date | string | null
    confidence?: number | null
    actualFireDate?: Date | string | null
    accuracy_days?: number | null
    isAccurate?: boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FireRecordCreateManyShtabelInput = {
    id?: number
    skladId: number
    reportDate: Date | string
    mark?: string | null
    weight_t?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    formedAt?: Date | string | null
    duration_hours?: number | null
    damage_t?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureVectorCreateManyShtabelInput = {
    id?: number
    ts: Date | string
    skladId: number
    features: JsonNullValueInput | InputJsonValue
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type SupplyUpdateWithoutShtabelInput = {
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutSuppliesNestedInput
  }

  export type SupplyUncheckedUpdateWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyUncheckedUpdateManyWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    dateIn?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    dateShip?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toStorage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    toShip_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordUpdateWithoutShtabelInput = {
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutTempsNestedInput
  }

  export type TempRecordUncheckedUpdateWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempRecordUncheckedUpdateManyWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    maxTemp?: FloatFieldUpdateOperationsInput | number
    piket?: NullableStringFieldUpdateOperationsInput | string | null
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUpdateWithoutShtabelInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    predictedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probEvent?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    horizonDays?: IntFieldUpdateOperationsInput | number
    intervalLow?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervalHigh?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    actualFireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accuracy_days?: NullableFloatFieldUpdateOperationsInput | number | null
    isAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordUpdateWithoutShtabelInput = {
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutFiresNestedInput
  }

  export type FireRecordUncheckedUpdateWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FireRecordUncheckedUpdateManyWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    skladId?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mark?: NullableStringFieldUpdateOperationsInput | string | null
    weight_t?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    damage_t?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorUpdateWithoutShtabelInput = {
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sklad?: SkladUpdateOneRequiredWithoutFeatureVectorsNestedInput
  }

  export type FeatureVectorUncheckedUpdateWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureVectorUncheckedUpdateManyWithoutShtabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    skladId?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}